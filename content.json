{"meta":{"title":"Cytify","subtitle":"","description":"","author":"Cytify","url":"http://example.com","root":"/"},"pages":[{"title":"Tag","date":"2021-01-27T15:19:15.000Z","updated":"2021-01-27T15:21:27.868Z","comments":true,"path":"tag/index.html","permalink":"http://example.com/tag/index.html","excerpt":"","text":""},{"title":"Category","date":"2021-01-27T15:19:38.000Z","updated":"2021-01-27T15:21:12.419Z","comments":true,"path":"category/index.html","permalink":"http://example.com/category/index.html","excerpt":"","text":""}],"posts":[{"title":"apue_7_进程环境","slug":"apue-7-进程环境","date":"2021-03-05T08:52:21.000Z","updated":"2021-03-05T08:54:38.255Z","comments":true,"path":"2021/03/05/apue-7-进程环境/","link":"","permalink":"http://example.com/2021/03/05/apue-7-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/","excerpt":"","text":"1. main函数C程序总是从main函数开始执行，main函数原型是： int main(int argc, char* argv[]) argc是命令行参数的个数，argv是指向指针的数组。 在内核执行C程序时，即内核调用exec函数，在调用main函数之前，调用一个特殊的启动例程。可执行文件将次启动例程指定为程序的起始地址，这是由C编译器调用连接编辑器设置的。启动例程从内核获得命令行参数和环境变量值。 2. 进程终止有8种方式结束进程，其中5种是正常终止： 从main返回 调用exit 调用_exit或_Exit 最后一个线程从其启动例程返回 从最后一个线程调用pthread_exit 异常终止的方式有3种： 调用abort 接到一个信号 最后一个线程对取消请求做出响应 启动例程使得从main返回后，立即调用exit函数。启动例程通常由汇编语言编写，它调用main函数的C代码如下： exit(main(argc, argv)) 2.1 退出函数三个函数用于正常终止程序：_exit和_Exit立即进入内核，exit则先执行一些清理处理，然后返回内核。 1234567#include &lt;stdlib.h&gt;void exit(int status);void _Exit(int status);#include &lt;unistd.h&gt;void _exit(int status); exit函数总是执行一个标准IO库的清理操作，对所有打开的流调用fclose。 status是终止状态。在一下情况下，进程的终止状态是未定义的： 调用这三个函数，不带终止状态 main执行了无返回值的return语句 main没有声明返回类型为整型 如果main的返回类型是整型，且main执行到最后一条语句时返回，那么进程的终止状态是0 main返回整型与调用exit时等价的，即: 1exit(0); == return 0; 2.2 atexit函数ISO C规定一个进程可以登记最多32个函数，这些函数由exit调用，这些函数称为终止处理程序。atexit函数用于登记这些函数。 1234#include &lt;stdlib.h&gt;// 返回值：成功返回0；出错返回非0int atexit(void (*func)(void)); exit调用这些函数的顺序与登记的顺序相反，一个函数如果多次登记，也会被多次调用。 在程序结束时，exit首先调用终止处理程序，关闭所有打开的流。如果程序调用exec函数，则清除所有已登记的终止处理程序 下图为C程序的启动和执行方式，可以看出，内核执行程序的唯一方式是exec函数，进程自愿终止的唯一方法是调用退出函数，或非自愿的接收到一个信号 3. 命令行参数在执行一个程序时，调用exec的进程将命令行参数传递给新程序。在main函数中的表示如下： int main(int argc, char* argv[]) 其中argv[argc]是一个空指针，可以作为遍历结束的条件。 4. 环境表每个程序都接收到一张环境表。环境表也是一个字符指针数组，其中每个指针包含一个null字符结尾的字符串的地址。全局变量environ包含了该指针数组的地址。 如下图所示：**environ为环境指针，指针数组为环境表，指针指向的字符串为环境字符串** 通常，环境字符串由name = value形式组成 5. C程序的存储空间布局C程序一般由一下几部分组成： 正文段。CPU执行的机器指令部分。通常，正文段是可共享的，所以，需要频繁使用的程序只需要由一份副本即可，且只读，以防程序修改指令。 初始化数据段。包含了程序中明确需要赋初值的变量。即C程序中，任何函数之外的声明，即全局变量 未初始化数据段。通常称为bss段。在程序开始之前，内核将此段中的数据初始化为0或空指针。同样，该段数据是全局数据 栈。保存函数调用时的一些基本信息，参数压栈等信息。 堆。在堆中进行动态内存分配，位于未初始化数据段和栈之间。 其典型的排布如下： 可以看出，bss段不需要存储在磁盘中，磁盘只需要存储正文段和初始化的数据即可。 6. 共享库共享库使得可执行文件不需要包含公用的库函数，只需要在所有进程都可引用的存储区保存这种库的一个副本。 程序第一次执行或第一次调用库函数时，动态链接地将层序与共享库连接起来。减少了每个可执行文件的长度，但增加了一些时间开销。这些时间开销主要发生在程序第一次被执行时，或共享库函数被第一次调用。 共享库的优点是可以不重新编译程序的前提下，更换库函数的版本。 7. 存储空间分配ISO C说明了三个分配空间的函数 malloc，分配指定字节的存储区，其中的值不确定 calloc，为指定数量指定长度的对象分配存储区，每一位都为0 realloc，增加或减少以前分配区的长度。当增加长度时，可能需要将以前的内容移动到另外的地方，新增区域的值不确定 12345678#include &lt;stdlib.h&gt;// 返回值：成功返回非空指针；出错返回NULLvoid* malloc(size_t size);void* calloc(size_t nobj, size_t size);void* realloc(void* ptr, size_t newsize);void free(void* ptr); 这三个函数返回的指针一定是对齐的，适用于任何数据对象 函数返回值为void*，如果包含&lt;stdlib.h&gt;，将返回指针赋予不同类型指针时，不需要显式强制类型转换。 realloc函数的重新分配，如果在原有地址上由足够大小的空间，在原存储区域内向高地址方向扩充。如果原存储区大小不够，就重新分配一块足够大的区域，将数据复制过去 这些分配空间函数，通常使用sbrk系统调用实现 8. 环境变量ISO C定义了getenv函数，取出环境变量值 1234#include &lt;stdlib.h&gt;// 返回值：指向与name关联的value指针；未找到返回NULLchar* getenv(const char* name); 此函数返回name=value中的value指针 一些预定义的环境变量如下： 其余环境变量的操作函数如下： 12345678#include &lt;stdlib.h&gt;// 返回值：成功返回0；出错返回非0int putenv(char* str);// 返回值：成功返回0；出错返回-1int setenv(const char* name, const char* value, int rewrite);int unsetenv(const char* name); putenv将name=value的字符串转换为环境变量，如果name已经存在，删除原来的定义 setenv将name设置为value，如果name已经存在，则需要参考rewrite的值。如果rewrite非0，则删除原来定义；如果rewrite为0，则不删除原来定义，也不更新环境变量 unsetenv删除name环境变量，无论name是否存在 putenv直接将str放到环境中，所以str如果在栈上，就会出错。setenv根据name和value，创建环境字符串 环境字符串是存储在环境表中，环境表位于栈之上的，这个特殊位置使得环境字符串的增加变得困难，因为不能再向该地址扩展空间了。 删除环境字符串 删除环境字符串，现在环境表中找到该指针，将其后的指针依次移动即可。 修改现有的环境字符串 新value的长度小于或等于旧value的长度，将新字符串复制到旧value的位置即可 新value的长度大于旧value的长度，为新字符串分配空间，将新字符串复制过去，将指针指向新分配区 增加环境字符串 首先，为新字符串分配空间，将新字符串复制过去。 如果是第一次新增环境字符串，为新的环境表分配空间，将原来环境表复制到新环境表中，将新字符串指针放到新环境表表尾，将一个空指针放到最后位置。最后，使environ指向新环境表。 如果不是第一次新增环境字符串，可知原来的空间，直接调用realloc，多分配一个指针的空间，将新指针放入即可。最后位置放空指针。 9. setjmp 和 longjmp 函数setjmp和longjmp函数执行跳转功能，主要处理深层嵌套函数的出错情况 123456#include &lt;setjmp.h&gt;// 返回值：直接调用，返回0；从longjmp返回，返回非0int setjmp(jmp_buf env);void longjmp(jmp_buf env, int val); 在希望返回的位置调用setjmp函数 jmp_buf是一个特殊类型，是某种形式的数据，记录了调用longjmp时能够恢复栈状态的信息，env变量通常是全局变量 val是非0的值，称为setjmp返回的值。如果由多个longjmp，该参数就可以处理那个函数被调用 9.1 自动变量、寄存器变量、易失变量在调用longjmp时，自动变量、寄存器变量、易失变量是否会回滚到原先值时不确定的。声明为全局变量、易失变量和静态变量的值在调用longjmp后是保持变化的。 某个系统的setjmp说明，存放在存储中的变量保持longjmp时的值，在CPU和浮点寄存器中的值恢复为调用setjmp时的值。 在未使用优化的编译之前，五个变量都放在存储器中，忽略register；使用-O编译之后，autoval和regival都存放在寄存器中。volaval变量放在存储器中。 10. getrlimit 和 setrlimit 函数每个进程都有一组资源，使用getrlimit和setrlimit获得 12345#include &lt;sys/resource.h&gt;// 返回值：成功返回0；出错返回非0int getrlimit(int resource, struct rlimit* rlptr);int setrlimit(int resource, const struct rlimit* rlptr); 两个函数调用时，都指定一个资源和指针。struct rlimit结构如下： 1234struct rlimit &#123; rlim_t rlim_cur; // 软限制 当前限制 rlim_t rlim_max; // 硬限制 rlim_cur的最大值&#125;; 在更改资源限制时，遵循以下3条规则： 任何一个进程都可以将软限制值更改为小于等于硬限制值 任何一个进程都可以降低其硬限制值，但必须大于等于软限制值。这种改变对于普通用户来说不可逆 只有超级用户进程可以提高硬限制值 常量RLIM_INFINITY代表无限量的限制 resouce取值如下图： RLIMIT_AS，进程总的可用存储空间的最大字节值。 RLIMIT_CORE，core文件的最大字节数，若值为0，则阻止创建core文件 RLIMIT_CPU，CPU时间的最大秒量值，超过此软限制时，向进程发送SIGXFSZ信号 RLIMIT_DATA，数据段的最大字节 RLIMIT_FSIZE，可创建文件的最大字节，超过此软限制时，向进程发送SIGXFSZ信号 RLIMIT_MEMLOCK，进程使用mlock能够锁定在存储空间的最大字节 RLIMIT_MSGQUEUE，进程位POSIX消息队列可分配的最大存储字节数 RLIMIT_NICE，影响进程的调度优先级，nice值可设置的最大限制 RLIMIT_NOFILE，进程能打开的最多文件数 RLIMIT_NPROC，每个实际用户ID可拥有的最大进程数 RLIMIT_NPTS，用户可打开的伪终端的最大数量 RLIMIT_RSS，最大驻内存及字节长度。如果可用的物理存储器特别少，内核将从进程处取回超过RSS的部分 RLIMIT_SBSIZE，在任一给定时刻，用户可拥有的套接字缓冲区最大字节 RLIMIT_SIGPENDING，一个进程可排队的信号最大数量 RLIMIT_STACK，栈的最大字节长度 RLIMIT_SWAP，用户可消耗交换空间的最大字节 RLIMIT_VMEM，RLIMIT_AS的同义词 资源限制影响调用进程，以及其子进程","categories":[{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"}]},{"title":"apue_6_系统数据文件和信息","slug":"apue-6-系统数据文件和信息","date":"2021-03-05T08:48:55.000Z","updated":"2021-03-05T08:51:59.189Z","comments":true,"path":"2021/03/05/apue-6-系统数据文件和信息/","link":"","permalink":"http://example.com/2021/03/05/apue-6-%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/","excerpt":"","text":"1. 口令文件UNIX系统口令文件包含以下字段，这些字段包含在&lt;pwd.h&gt;的passwd结构中。 口令文件是/etc/passwd，是一个ACSII文件，字段之间用冒号隔开。 登录项也有些注意事项： 通常有一个root用户，ID为0，是超级用户 加密口令字段包含一个占位符 shell字段包含一个可执行程序名，被用作用户的登录shell。若该字段为空，通常有默认shell 为了阻止用户登录，可以将登录shell设置为/dev/null /bin/false /bin/true，还有nologin命令，打印出错信息，以非0终止 nobody用户的一个目的是，使得任何人可以登陆系统。但只能访问人人可读、写的文件 POSIX.1定义了两个获取口令文件项的函数。给出用户登录名或数值用户ID后，就可查看相关项。 12345#include &lt;pwd.h&gt;// 返回值: 成功返回指针 出错返回NULLstruct passwd* getpwuid(uid_t uid);struct passwd* getpwnam(const char* name); getpwuid函数由ls命令获取，将i节点中的数字用户ID转换为用户名 getpwnam函数在输入登录名时，由login程序调用 这两个函数指向passwd结构，该结构通常为函数内部静态变量 如果查看整个口令文件，也可以用以下函数 1234567#include &lt;pwd.h&gt;// 返回值: 成功返回指针 出错或达到文件尾端返回NULLstruct passwd* getpwent(void);void setpwent(void);void endpwent(void); getpwent函数返回口令文件的下一个记录项。 setpwent将口令文件指针指向开头 endpwent关闭这些文件。使用getpwent后，一定要调用endpwent关闭这些文件 2. 阴影口令加密口令是经过单向加密算法的用户口令副本，不能从加密后的口令转到原来的口令。 某些系统加这些加密过的口令存放在称为阴影口令中的文件。 其中只有用户登陆名和加密口令这两个字段是必须存在的。其他字段可选。 在Linux中，有以下几个函数可以读取阴影口令文件。 12345678#include &lt;shadow.h&gt;// 返回值: 成功返回指针 出错返回NULLstruct spwd* getspname(const char* name);struct spwd* getspent(void);void setspent(void);void endspent(void); 3. 组文件UNIX组文件包含下图字段。这些字段定义在&lt;grp.h&gt;的group结构 gr_mem字段是一个指针数组，其中每个指针指向一个属于该组的用户名。该数组以null结尾。 POSIX.1定义的下两个函数可以查看组名或数值组ID 12345#include &lt;grp.h&gt;// 返回值: 成功返回指针 出错返回NULLstruct group* getgrid(gid_t gid);struct group* getgrnam(const char* name); 返回指向静态变量的指针，在每次调用时，都会重写该变量。 搜索整个组文件，需要下面三个函数 1234567#include &lt;grp.h&gt;// 返回值: 成功返回指针 出错或达到文件尾，返回NULLstruct group* getgrent(void);void setgrent(void);void endgrent(void); 这三个函数与口令文件的三个函数作用相同 4. 附属组ID是用复数组ID可以不必显式更换组ID，用于参与多个项目时，只需同时属于多个组即可。 获取和设置组ID有以下三个函数 12345678910#include &lt;unistd.h&gt;// 返回值: 成功 返回附属组ID数量 出错 返回-1int getgroups(int gidsetsize, gid_t grouplist[]);#include &lt;grp.h&gt;// 返回值: 成功 返回0 出错 返回-1int setgroups(int ngroups, const gid_t grouplist[]);int initgroups(const char* username, gid_t basegid); getgroups函数将进程所属用户的附属组ID填写到数组grouplist中，个数最多为gidsetsize，实际填写的个数为返回值 如果gidsetsize为0，函数返回附属组ID个数，不填写grouplist数组。通常用这种方法确定 grouplist长度。 setgroups由超级用户调用，为调用进程设置附属组ID。grouplist是组ID数组，ngroups说明数组中的元素个数，该值不能超过NGROUPS_MAX initgroups读取整个组文件，对username确定组的成员关系，以便为该用户初始化附属组ID表。initgroups也会调用setgroups，所以同样需要超级用户权限。baseid是username在口令文件中的组ID 5. 其他数据文件一般来说，每个数据文件都至少有以下三个函数： get函数。读下一个记录，如果需要，还会打开文件。函数成功返回指针，达到文件尾端返回空指针。大多数返回的指针是指向静态数据，保存数据需要手动复制。 set函数。打开相应数据文件，定位到文件开头位置。 end函数。关闭相应数据文件。 如果数据文件支持某种形式的键搜索，也需要提供对应的函数。如口令文件的getpwnam 6. 登陆账户记录大多数UNIX系统提供一下两个文件： utmp文件，记录当前登录到系统的每个用户 wtmp文件，跟踪每个登录和注销事件 一般来说，每次写入这两个文件的是下列结构的二进制值： 12345struct utmp &#123; char ut_line[8]; // tty char ut_name[8]; // login name long ut_time; // seconds each epoch&#125;; 登陆时，login程序填写该结构，将其写遇到utmp文件和wtmp文件。注销时，init进程将utmp内记录消除，将一个新纪录添加到wtmp文件。在wtmp的注销记录中，ut_name字段清除为0。在系统再启动，或更改系统时间和日期的前后，都会对wtmp文件添加特殊的记录项。 7. 系统标识POSIX.1定义了uname函数，返回与主机和操作系统有关的信息。 1234#include &lt;sys/utsname.h&gt;// 返回值：成功返回非负值；出错返回-1int uname(struct utsname* name); 该函数传递一个name参数，并由该函数填写该结构。结构的最少需要提供的字段如下，每个数组的长度由实现确定 1234567struct utsname &#123; char sysname[]; // 操作系统名字 char nodename[]; // 该节点名字 char release[]; // 当前系统的release char version[]; // 当前系统发布的版本 char machine[]; // 硬件类型名字&#125;; 每个字符串以null字节结尾。utsname结构信息可用uanme命令打印。 POSIX.1定义了gethostname函数，返回主机名，通常为TCP/IP网络上的主机名 1234#include &lt;unistd.h&gt; // 返回值：成功返回0；出错返回-1int gethostname(char* name, int namelen); namelen指定缓冲区长度，最大值为HOST_NAME_MAX，name返回的字符串以null字节结尾。 下图为最大名字长度在不同系统上的值。 8. 时间、日期UNIX内核提供的时间是计算从协调世界时 UTC，公元1970年1月1日00:00:00以来，经过的秒数。这种秒数以time_t存储，称之为日历时间，日历时间包括时间和日期。 time函数可返回当前时间和日期 1234#include &lt;time.h&gt;// 返回值：成功返回时间值；出错返回-1time_t time(time_t* calptr); 时间值作为结果返回，如果calptr非空，时间值也存放在calptr中。 POSIX.1扩展了多个系统时钟。时钟通过clockid_t类型标识，具体值如下： clock_gettime函数获取指定时钟的时间。 1234#include &lt;sys/time.h&gt;// 返回值：成功返回0；出错返回-1int clock_gettime(clockid_t clock_id, struct timespec* tsp); 当时钟ID设置为CLOCK_REALTIME，clock_gettime功能与time类似。但是精度高的系统中，时间值的精度可能更高。 clock_getres函数获取指定时钟的时间 1234#include &lt;sys/time.h&gt;// 返回值：成功返回0；出错返回-1int clock_getres(clockid_t clock_id, struct timespec* tsp); 该函数将tsp所指结构初始化为clock_id对应的时钟精度。 clock_settime函数对特定的时钟设定时间 1234#include &lt;sys/time.h&gt;// 返回值：成功返回0；出错返回-1int clock_settime(clockid_t clock_id, const struct timespec* tsp); gettimeofday函数已被弃用，但一些程序还在使用它，他对比time可提供更高的精度 1234#include &lt;sys/time.h&gt;// 返回值：总是返回0int gettimeofday(struct timeval* tp, void* restrict tzp); tzp的唯一合法值为NULL。 gettimeofday函数将秒数存放在timeval结构中，该结构将当前时间表示为秒和微妙。 取得了从特定时间经过的秒数之后，需要调用函数将其转换为分解的时间结构，调用另一个函数生成可读的时间和日期。它们之间的关系变化如下图所示 localtime和gmtime将日历时间转换分解后的时间，存放在tm结构中 12345#include &lt;time.h&gt;// 返回值：指向`tm`结构的指针；出错返回NULLstruct tm* gmtime(const time_t* calptr);struct tm* localtime(const time_t* calptr); tm结构定义如下： 1234567891011struct tm &#123; int tm_sec; // 秒 [0-60] int tm_min; // 分钟 [0-59] int tm_hour; // 小时 [0-23] int tm_mday; // 天数 [1-31] int tm_mon; // 月份 [0-11] int tm_year; // 1900后的年数 int tm_wday; // 周日以来的天数 [0-6] int tm_yday; // 一月一日以来的天数 [0-365] int tm_isdst; // 夏令时的标志&#125;; 夏令时生效，该标志为正；非夏令时，该标志为0；如果此信息不可用，则为负。 localtime返回的是本地时间 gmtime返回的是协调通用时间，UTC mktime函数以本地时间作为参数，转换为time_t值 1234#include &lt;time.h&gt;// 返回值：成功返回日历世家；出错返回-1time_t mktime(struct tm* tmptr); strftime类似于printf，打印时间值字符串 123456789#include &lt;time.h&gt;// 返回值：若有空间，返回存入数组的字符数；否则返回0size_t strftime(char* restrict buf, size_t maxsize, const char* restrict format, const struct tm* restrict tmptr);size_t strftime_l(char* restrict buf, size_t maxsize, const char* restrict format, const struct tm* restrict tmptr, locale_t locale); strftime_l函数可将区域作为参数，除此之外，二者功能一致。strftime通过环境变量TZ指定区域 tmptr是需要格式化的时间值。格式化的结果存放在长度为maxsize的buf中。若有空间，返回存入数组的字符数，不包括结尾空字符。 format控制时间值的格式，但是与printf有所不同，具体值如下： %U为相应日期在该年的周数，包含第一个星期日的周是第一周。%W为相应日期在该年的周数，包含第一个星期一的周是第一周。%V为相应日期在该年的周数，如果包含了1月1日的哪一周，包含了新一年的四天或更多，则该周算第一周，否则算去年的最后一周，在这两种情况下，周一都是每周的第一天。 strptime函数是strftime函数反过来，将字符串时间转换为分解时间 12345#include &lt;time.h&gt;// 返回值：指向上次解析字符的下一个字符的指针；否则返回NULLchar* strptime(const char* restrict buf, const char* restrict format, struct tm* restrict tmptr); format参数给出了buf缓冲区内的字符串格式，其转换说明的取值如下：","categories":[{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"}]},{"title":"apue_5_标准IO库","slug":"apue-5-标准IO库","date":"2021-03-05T08:45:39.000Z","updated":"2021-03-05T08:48:35.862Z","comments":true,"path":"2021/03/05/apue-5-标准IO库/","link":"","permalink":"http://example.com/2021/03/05/apue-5-%E6%A0%87%E5%87%86IO%E5%BA%93/","excerpt":"","text":"1. 流和FILE对象标准IO的操作是围绕流进行的，当打开或创建一个文件时，使一个流与一个文件相关联。 标准IO文件流可用于单字节或多字节字符集。流的定向决定了读写的字符是单字节还是多字节。使用fwide可以设置流的定向 12345#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;// 返回值: 宽字符定向 返回正值 字节定向定向 返回负值 流是未定向 返回0int fwide(FILE* fp, int mode); 根据mode参数，fwide执行不同工作。 mode为负，fwide把fp设置为字节定向 mode为正，fwide把fp设置为宽定向 mode为0，fwide不设置fp的定向，但是返回标识该流定向的值 fwide不改变已定向的流的定向，且无出错返回。在流无效时，我们只能在调用fwide前清除errno，在调用结束后检查errno的值。 FILE对象通常是一个结构，包含了标准IO库管理该流的信息，包括文件描述符，该流缓冲区指针，缓冲区长度，缓冲区中字符数等。 2. 标准输入、标准输出、标准错误一个进程预定义了三个流，即标准输入、标准输出、标准错误。这三个标准IO流通过预定义文件指针stdin、stdout和stderr引用。 3. 缓冲标准IO提供了以下3种缓冲： 全缓冲 填满缓冲区后才进行实际IO操作。 术语冲洗(flush)说明缓冲区的写操作。缓冲区可以自动冲洗，也可调用fflush冲洗。冲洗将缓冲区的内容写到磁盘上。 行缓冲 输入和输出遇到换行符时，执行IO操作。 行缓冲有两个限制 缓冲区填满，即使没有遇到换行符，也进行IO操作 从不带缓冲的流或一个行缓冲的流（从内核请求数据）得到输入数据，冲洗所有行缓冲输出流 不带缓冲 标准错误流stderr通常不到缓冲 对于标准IO，通常有以下特征： 指向终端设备的流，是行缓冲；否则是全缓冲 标准错误是不带缓冲的 可以调用下列函数更改缓冲类型 123456#include &lt;stdio.h&gt;void setbuf(FILE* restrict fp, char* restrict buf);// 返回值: 成功返回0 出错返回非0int setvbuf(FILE* restruct fp, char* restrict buf, int mode, size_t size); setbuf函数可打开或关闭缓冲机制。如果带缓冲IO，buf必须指向一个长度为BUFSIZ的缓冲区，之后该流就是全缓冲的。关闭缓冲可以将buf设为NULL setvbuf可以精确控制缓冲类型，使用mode参数控制 _IOFBF 全缓冲，buf和size可指定一个缓冲区及其长度，如果buf为NULL，则自动分配一个缓冲区，长度通常为BUFSIZ _IOLBF 行缓冲，buf和size可指定一个缓冲区及其长度，如果buf为NULL，则自动分配一个缓冲区，长度通常为BUFSIZ _IONBF 不带缓冲，忽略buf和size参数 1234#include &lt;stdio.h&gt;// 返回值: 成功返回0 出错返回EOFint fflush(FILE* fp); 此函数使流地所有未写地数据传送到内核。如果fp是NULL，则所有输出流都被冲洗。 4. 打开流下列函数打开一个标准IO流 123456#include &lt;stdio.h&gt;// 返回值: 成功返回文件指针 出错返回NULLFILE* fopen(const char* restrict pathname, const char* restrict type);FILE* freopen(const char* restrict pathname, const char* restrict type, FILE* restrict fp);FILE* fdopen(int fd, const char* type); fopen打开pathname的指定文件 freopen在指定流上打开指定文件，如果流已经打开，则先关闭该流。若流已经定向，使用freopen清除定向。 此函数通常将一个指定文件打开为一个预定义的流，标准输入输出错误。 fdopen从已有的文件描述符打开流。常用于打开网络通信和管道的描述符，因为这写文件不能用fopen打开 type参数指定对该IO流的读写方式 以w或a创建文件时，无法指定其访问权限位，但是可以使用unmask函数限制这些权限。 字符b意味着可以区分二进制文件和文本文件，但unix系统不对这两种区分，所以对于unix环境来说，b无效 fdopen函数来说，type的含义有所不同。写打开不会阶段文件，因为该文件已经存在且打开。同理，追加方式也不能创建文件 多个进程以追加方式写同一文件时，可以正确的追加数据 以读写类型打开文件时（type中的+号），具有以下限制： 如果中间没有fflush、fseek、fsetpos或rewind，则在输出后面不能直接跟随输入 如果中间没有fseek、fsetpos或rewind，或者一个输入操作没有达到尾端，则在输入后不能直接跟随输出 调用fclose关闭一个打开的流 1234#include &lt;stdio.h&gt;// 返回值: 成功返回0 出错返回EOFint fclose(FILE* fp); 在文件被关闭前，冲洗缓冲中的输出数据，丢弃缓冲中的输入数据，如果该流被自动分配缓冲区，释放缓冲区。 进程正常终止时，所有未写的缓冲数据都会被冲洗，关闭打开的流 5. 读、写流有三种类型的IO方式，进行读写： 每次一个字符。一次读写一个字符 每次一行。调用fgets和fputs。每行以换行符终止 直接IO。fread和fwrite。这两个函数通常用于从二进制文件每次读写一个结构 5.1 输入函数以下三个函数可以一次读一个字符 123456#include &lt;stdio.h&gt;// 返回值: 成功 返回下一个字符 若达到文件尾或出错 返回EOFint getc(FILE* fp);int fgetc(FILE* fp);int getchar(void); getchar相当于getc(stdin) getc与fgetc区别在于，getc可以被实现为宏，但是fgetc不行 getc参数不能是有副作用的表达式，避免重复计算 fgetc一定是函数，可以作为参数传递 fgetc调用时间可能比getc长 这三个函数在返回下一个字符时，会从unsigned char类型转换为int，这么做是因为： 即使字符最高位为1，返回值不可能是负数 整形返回值可以确定是否到达文件尾，因为EOF的值通常为负数，-1 因为这三个函数在出错或到达文件尾的返回值都是EOF，为了区分，有以下两个函数 1234567#include &lt;stdio.h&gt;// 返回值: 条件为真 返回非0 条件为假 返回0int ferror(FILE* fp);int feof(FILE* fp);void clearerr(FILE* fp); 在大多数实现中，流在FILE对象内部维护两个标志： 出错标志 文件结束标志 调用clearerr可以清除这两个标志 从流中读取数据后，可以调用ungetc将字符压回流中 1234#include &lt;stdio.h&gt;// 返回值: 成功返回c 出错返回EOFint ungetc(int c, FILE* fp); 压回的数据可以重新读取，但是读取的顺序与压回的顺序是相反的 压回的字符无需是上一次读到的字符，但不能是EOF。已经读到文件尾时，可以在压回一个字符，此时读取不会读到EOF，因为ungetc清除了文件结束标志 压回字符时，没有将他们写到底层文件中，只写回到缓冲区 5.2 输出函数123456#include &lt;stdio.h&gt;// 返回值: 成功返回c 出错返回EOFint putc(int c, FILE* fp);int fputc(int c, FILE* fp);int putchar(int c); 与输入函数相似，putchar等于putc(c, stdout)，putc可被实现为宏，fputc不可被实现为宏 6. 每次一行IO以下两个函数每次输入一行 12345#include &lt;stdio.h&gt;// 返回值: 成功返回buf 达到文件尾或出错返回NULLchar* fgets(char* restrict buf, int n, FILE* restrict fp);char* gets(char* buf); 这两个函数都有buf缓冲区，将读到的数据送入其中。gets从标准输入读，fgets从流读 fgets必须指定缓冲区长度。此函数读到下一个换行符，但不超过n-1个字符。缓冲区以NULL结尾。 如果该行的换行符恰好是最后一个字符或超出n-1，fgets返回一个不完整的行，下一次调用继续读取该行。 gets不推荐使用，因为没有指定缓冲区大小，可能导致缓冲区溢出，不要使用。 fputs和puts每次输出一行 12345#include &lt;stdio.h&gt;// 返回值: 成功返回非负值 出错返回EOFint fputs(const char* restrict str, FILE* restrict fp);int puts(const char* str); fputs将以NULL终止的字符串写到指定流中。通常在NULL字节之前是一个换行符，但不总是如此。 puts函数将以NULL终止的字符串写到标准输出，终止符不写。随后puts写一个换行符。 在使用fgets和fputs时，需要自己处理换行符 7. 二进制IO12345#include &lt;stdio.h&gt;// 返回值: 读、写的对象数size_t fread(void* restrict ptr, size_t size, size_t nobj, FILE* restrict fp);size_t fwrite(const void* restrict ptr, size_t size, size_t nobj, FILE* restrict fp); size是每个元素的长度，nobj是读取或写入的元素的个数 对于读，如果出错或到达文件尾，此数字可以少于nobj，此时需要使用ferror或feof判断情况 对于写，如果返回值少于nobj，一定出错 8. 定位流有3种方式定位标准IO流 ftell或fseek函数 ftello或fseeko函数 fgetpos和fsetpos函数，这是ISO C定义的，在移植到非UNIX系统程序应当使用该方式 123456789#include &lt;stdio.h&gt;// 返回值: 成功 返回当前文件位置指示 出错返回-1Llong ftell(FILE* fp);// 返回值: 成功 返回0 出错返回-1int fseek(FILE* fp, long offset, int whence);void rewind(FILE* fp); 对于二进制文件，文件位置指示器是从文件起始位置开始算起，以字节为度量单位。 ftell用于二进制文件，返回字节位置 fseek需要指定一个偏移量，whence用于如何解释该偏移量 whence是SEEK_SET，则文件偏移量为距文件开始处的offset个字节 whence是SEEK_CUR，则文件偏移量是当前值加上offset，offset可正可负 whence是SEEK_END，则文件偏移量是文件尾端加上offset，offset可正可负 对于文本文件，文件当前位置可能不以简单的字节来表示，因为在不同系统中，存放的格式不同。 fseek在定位时，whence只能是SEEK_SET，且offset只能是0，文件起始位置，或者ftell返回的值 rewind函数也可将流设置到文件的起始位置 除了偏移量的类型是off_t而非long以外，ftello与ftell，fseeko与fseek相同 1234567#include &lt;stdio.h&gt;// 返回值: 成功 返回当前文件位置指示 出错返回 (off_t)-1off_t ftell(FILE* fp);// 返回值: 成功 返回0 出错返回-1int fseek(FILE* fp, off_t offset, int whence); fgetpos和fsetpos函数，这是ISO C标准引入的 12345#include &lt;stdio.h&gt;// 返回值: 成功返回0 出错返回非0int fgetpos(FILE* restrict fp, fpos_t* restrict pos);int fsetpos(FILE*fp, const fpos_t* pos); fgetpos将文件位置指示器的当前值传入pos所指结构中。fsetpos将流设置为该结构所指的位置。 9. 格式化IO9.1 格式化输出格式化输出有5个printf函数处理 123456789101112#include &lt;stdio.h&gt;// 返回值: 成功返回输出字符数 出错返回负值int printf(const char* restrict format, ...);int fprintf(FILE* restrict fp, const char* restrict format, ...);int dprintf(int fd, const char* restrict format, ...);// 返回值: 成功返回存入数组的字符数 若编码出错 返回负值int sprintf(char* restrict buf, const char* restrict format, ...);// 返回值: 若缓冲区足够大，返回将要存入数组的字符数 若编码出错 返回负值int snprintf(char* restrict buf, size_t n, const char* restrict format, ...); printf将格式化数据写到标准输出 fprintf将格式化数据写到流 dprintf将格式化数据写到文件描述符 sprintf将格式化数据送到buf中，并在数组尾端加上NULL字符，该字符不被算入返回值。可能导致缓冲区溢出。 snprintf与sprintf相同，但如果长度超过了缓冲区长度n，会被截断。如果返回值小于n，没有截断。 转化说明控制的格式如下 1%[flags][fldwith][precision][lenmodifier]convtype flags参数如下： fldwith说明最小字段宽度。转换后的字符数如果小于宽度，多于位置用空格填充。字段宽度是非负十进制数，或是星号 precision说明整型最少输出数字位数、浮点数小数点最少位数、字符串最大字节数。精度以一个点.，紧跟可选的非负十进制数，或是星号 lenmodifier说明参数长度 convtype必选。他控制如何解释参数。 下面5个printf函数类似于上面5个，但是可变参数列表(...)，变成了arg 12345678910111213#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;// 返回值: 成功返回输出字符数 出错返回负值int vprintf(const char* restrict format, va_list arg);int vfprintf(FILE* restrict fp, const char* restrict format, va_list arg);int vdprintf(int fd, const char* restrict format, va_list arg);// 返回值: 成功返回存入数组的字符数 若编码出错 返回负值int vsprintf(char* restrict buf, const char* restrict format, va_list arg);// 返回值: 若缓冲区足够大，返回将要存入数组的字符数 若编码出错 返回负值int vsnprintf(char* restrict buf, size_t n, const char* restrict format, va_list arg); 9.2 格式化输入格式化输入是3个scanf函数 123456#include &lt;stdio.h&gt;// 返回值: 赋值的输入项数；若出错或在任一转换之前已经到达文件尾，返回EOFint scanf(const char* restrict format, ...);int fscanf(FILE* restrict fp, const char* restrict format, ...);int sscanf(const char* restrict buf, const char* restrict format, ...); scanf类函数分析输入字符串，并将其转换为指定类型的变量。之后的参数即变量的地址，用转换结果对这些变量赋值。 格式控制说明如果转换参数，以便赋值。具体格式如下： 1%[*][fldwith][m][lenmodifier]convtype *星号用于抑制转换。按照转换说明的其余部分对输入进行控制，但结果不存放在参数中。 fldwith说明最大宽度，即最大字符数。 lenmodifier说明转换结果赋值的参数大小。具体值同上。 convtype类似printf族的。但是有所区别 m是复制分配符，用于%s %c %[转换符，迫使内存缓冲区分配空间，接纳转换的字符串。在该情况下，相关参数必须是指针地址，该缓冲区需要手动释放 下面3个scanf函数类似于上面3个，但是可变参数列表(...)，变成了arg 1234567#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;// 返回值: 赋值的输入项数；若出错或在任一转换之前已经到达文件尾，返回EOFint vscanf(const char* restrict format, va_list arg);int vfscanf(FILE* restrict fp, const char* restrict format, va_list arg);int vsscanf(const char* restrict buf, const char* restrict format, va_list arg); 10. 实现细节标准IO库都需要最终调用系统IO函数。在UNIX中，每个流都有一个与其关联的文件描述符，可调用fileno获取 1234#include &lt;stdio.h&gt;// 返回值: 与该流相关的文件描述符int fileno(FILE* fp); 11. 临时文件1234567#include &lt;stdio.h&gt;// 返回值: 指向唯一路径名的指针char* tmpnam(char* ptr);// 返回值: 成功返回文件指针 出错返回NULLFILE* tmpfile(void); tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用都会产生一个不同的路径名，最多调用TMP_MAX次。 若ptr是NULL，产生的路径名存放在静态区中，指向该静态区的指针作为返回值。后续调用，会重写静态区。 若ptr不是NULL，则他应该是长度至少为L_tmpnam的字符数组。新路径名存放在数组中，ptr作为返回值。 tmpfile创建一个临时二进制文件，类型wb+，在关闭该文件或程序结束时将自动删除该文件。 Single UNIX Specification为临时文件定义了mkdtemp和mkstemp函数。 1234567#include &lt;stdlib.h&gt;// 返回值: 成功返回指向目录名的指针 出错返回NULLchar* mkdtemp(char* template);// 返回值: 成功返回文件描述符 出错返回-1int mkstemp(char* template); mkdtemp创建一个目录，该目录具有唯一的名字。 创建的目录权限为S_IRUSR|S_IWUSR|S_IXUSR。 mkstemp创建一个文件，该文件具有唯一的名字。 创建一个文件并以读写方式打开，权限位S_IRUSR|S_IWUSR。该文件不会自动删除，需要手动解除链接。 唯一的名字通过template参数选择。该字符串后六位设置为XXXXXX的路径，这些占位符被替换为不同的字符，构建唯一的路径名 tmpnam存在缺点，如果在创建过程中，有另外的进程创建了同名的文件。所以应该使用tmpfile和mkstemp。 12. 内存流内存流可以在没有底层文件的情况下，在缓冲区与主存之间创建IO流。 fmemopen函数用于创建内存流。 1234#include &lt;stdio.h&gt;// 返回值: 成功返回流指针 出错返回NULLFILE* fmemopen(void* restrict buf, size_t size, const char* restrict type); buf参数指定缓冲区开始位置，size指定缓冲区长度。如果buf为空，函数会自动创建一个长度为size的缓冲，并在流关闭时释放 type参数用于如何控制流 以追加写打开内存流时，当前文件位置设置为缓冲区的第一个null字节。如果没有null字节，就设置为缓冲区结尾的后一个字节。不以追加方式打开时，当前位置为缓冲区开始位置。因此内存流不适合二进制文件，因为二进制文件可能在尾端之前有null 若buf是null指针，读或者写流没有意义。因为缓冲区是自动分配的，无法确定地址。只写就不能读，只读就不能写。 增加流缓冲区的数据量以及调用fflush、fclose、fseek、fseeko、fsetpos时，都会在当前位置写入一个null字节 另外创建内存流的函数是open_memstream和open_wmemstream`。 123456#include &lt;stdio.h&gt;// 返回值: 成功返回流指针 出错返回NULLFILE* open_memstream(char** bufp, size_t* sizep);#include &lt;wchar.h&gt;FILE* open_wmenstream(wchar_t** bufp, size_t sizep); open_memstream创建面向字节的流，open_wmenstream创建面向宽字节的流。与fmemopen区别在于： 创建的流只能写打开 不能指定自己的缓冲区，但是可以通过bufp和sizep获取缓冲区地址和大小 关闭流后需要手动释放缓冲区 对流天界字节会增加缓冲区大小 缓冲区地址和大小的使用需要遵循规则： 缓冲区地址和长度，只有调用fclose和fflush后才有效 这些值在下一次流写入或调用fclose前才有效。因为缓冲区可增长，所以会重新分配内存。 因为避免了缓冲区溢出，所以内存流适合创建字符串，同时对于将标准IO流作为参数用于临时文件的函数，内存流可以改善性能。","categories":[{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"}]},{"title":"apue_4_文件和目录","slug":"apue-4-文件和目录","date":"2021-03-05T08:37:52.000Z","updated":"2021-03-05T08:45:19.071Z","comments":true,"path":"2021/03/05/apue-4-文件和目录/","link":"","permalink":"http://example.com/2021/03/05/apue-4-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/","excerpt":"","text":"1. stat、fstat、fstatat 和 lstat 函数1234567#include &lt;sys/stat.h&gt;// 4个函数返回值: 成功返回0 出错返回-1int stat(const char *restrict pathname, struct stat *restrict buf);int fstat(int fd, struct stat *buf);int lstat(const char *restrict pathname, struct stat *restrict buf);int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag); stat函数，返回与pathname对应文件的信息 fstat函数，返回文件描述符fd上打开文件的信息 lstat函数，功能类似stat函数，但是当文件是符号链接时，函数返回该符号链接的信息，而不是符号链接引用的文件的信息 fstatat函数，相对于当前打开目录（有fd指定）的路径名，返回对应文件的信息。 flag参数控制着是否跟随一个符号链接。AT_SYMLINK_NOFOLLOW被设置时，fstatat函数返回符号链接的信息，而不是跟随符号链接 fd参数值是AT_FDCWD时，pathname是一个相对路径时，fstatat会计算相对于当前目录的pathname参数。如果pathname是一个绝对路径，fd参数会被忽略。 buf参数有函数来填充该结构体的信息，该结构体的基本形式如下： 123456789101112131415struct stat &#123; mode_t st_mode; // 文件类型 权限 ino_t st ino; // i-node数字 序列数字 dev_t st_dev; // 设备号 相对于文件系统 dev_t st_rdev; // 特殊文件的设备号 nlink_t st_nlink; // 链接数 uid_t st_uid; // 所有者的用户id gid_t st_gid; // 所有者的组id off_t st_size; // 常规文件大小字节数 struct timespec st_atime; // 上次访问的时间 struct timespec st_mtime; // 上次修改的时间 struct timespec st_ctime; // 上次文件状态修改的时间 blksize_t st_blksize; // 最佳的io块大小 blkcnt_t st_blocks; // 分配的磁盘块数目&#125;; timespec按照秒和纳秒定义了时间，至少包含以下两个时间段： 1234struct timespec &#123; time_t tv_sec; long tv_nsec;&#125;; 2. 文件类型文件类型包括以下几种： 普通文件。最常用的文件类型，包含了某种数据，这种数据是文本的还是二进制的对于Unix内核来说没有区别。 例外是二进制可执行文件，为了执行程序，内核必须理解其格式。所有二进制可执行文件都遵循一种格式，使得内核可以确定程序文本和数据的加载位置 目录文件。包含了其他文件的名字和指向这些文件信息的指针。对一个目录具有读权限的任一进程都可以读该目录内容，但是只有内核可以直接写目录文件。 块特殊文件。提供对设备（如磁带）带缓冲的访问，每次访问以固定长度为单位进行。 字符特殊文件。提供对设备不带缓冲的访问，每次访问长度可变。系统中的设备要么是块特殊文件，要么是字符特殊文件。 FIFO。用于进程间网络通信，有时也叫命名管道。 套接字。用于网络通信 符号链接。指向另外一个文件 文件类型的信息包含在stat结构中的st_mode中，可以使用下表中的宏确定文件类型，这些宏的参数是st_mode。 POSIX.1允许将进程间通信（IPC）的对象（消息队列和信号量）说明为文件。下图中的宏可用于将stat结构中确定IPC对象类型，这些宏的参数是指向stat结构的指针 3. 设置用户ID和组ID与一个进程相关的ID有6个或更多，如图： 实际用户ID和实际组ID，标识出我们是谁，这两个字段从登陆时的口令文件中登录项获得。通常，一个会话期中这些值不变。但是超级用户进程有办法改变他们。 有效用户ID、有效组ID和附属组ID，决定了文件的访问权限。 保存的设置用户ID和保存的设置组ID，在执行程序时，保存了有效用户ID和有效组ID的副本。 每个文件都有一个所有者和组所有者，分别由stat结构中的st_uid和st_gid指定。 通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID。但是可以通过st_mode中设置特殊位，使得在执行此文件时，将进程的有效用户ID和有效组ID分别设置为文件的所有者的用户ID和组ID。这两个位称为设置用户ID位和设置组ID位。这两位可以通过常量S_ISUID和S_ISGID测试。 4. 文件访问权限每个文件类型都有9个访问权限位，可以将它们分为三类，如下： chmod命令用于修改这9个权限位。其中u表示用户（所有者），g表示组，o表示其他。 图4-6的三类访问权限由不同的方式、不同的函数使用。规则如下： 打开任一类型的文件时，对该文件路径中的每一个目录，包括他可能隐含的目录，都需要具有执行权限 目录的读权限和执行权限是不同的。读权限允许我们读取目录，获得目录中所有文件名。执行权限允许我们通过该目录，即搜索该目录，寻找一个特定的文件名 一个文件的读权限决定了我们能否打开文件进行读操作。这与open函数的O_RDONLY和O_RDWD标志有关 一个文件的写权限决定了我们能否打开文件进行写操作。这与write函数的O_WRONLY和O_RDWD标志有关 open函数对文件指定O_TRUNC标志，必须对该文件具有写权限 在目录中新建文件，必须对该目录具有写权限和执行权限 在目录中删除文件，必须对该目录具有写权限和执行权限，对文件本身不需要读、写权限 若使用exec函数执行文件，必须对该文件具有执行权限，且该文件必须是普通文件 进程每次打开、创建、删除文件时，内核进行文件权限测试。这种测试可能涉及到文件所有者（st_uid和st_gid）、进程的有效ID（有效用户ID和有效组ID）以及进程的附属组ID（如果支持）。 两个所有者ID是文件的性质，两个有效ID和附属组ID是进程的性质，内核进行的测试如下： 如果进程的有效用户ID是0（超级用户），允许访问 如果进程的有效ID等于文件的所有者ID，如果所有者适当的访问权限被设置，则允许访问，否则拒绝访问 适当的访问权限为，如果进程读文件，则用户读位为1，写文件和执行文件同理 如果进程的有效组ID或附属组ID等于文件的组ID，如果组适当的访问权限被设置，则允许访问，否则拒绝访问 如果其他用户适当的访问权限被设置，则允许访问，否则拒绝访问 内核按照顺序方式进行如上四个步骤 5. 新文件和目录的所有权在创建一个文件和目录时，调用open create mkdir。新文件的用户ID设置为进程的用户ID。组ID的设置有以下两个选择： 新文件的组ID是进程的有效组ID 新文件的组ID是他所在目录的组ID 6. access 和 faccessat 函数如果进程以实际用户ID和实际组ID测试对文件的访问权限时，需要调用access和faccessat函数，该函数同样分成四个步骤测试文件的访问权限，与内核的测试步骤相同。 12345#include &lt;unistd.h&gt;// 返回值: 成功返回0 出错返回-1int access(const char *pathname, int mode);int faccessat(int fd, const char *pathname, int mode, int flag); 如果测试文件是否存在，mode需要设置为F_OK，否则mode的值如下： faccessat函数与access函数在以下情况是相同的： pathname是绝对路径 fd参数是AT_FDCWD，pathname是相对路径 除此之外，faccessat函数计算相对于打开目录，（由fd指定）的pathname。 flag参数用于改变faccessat函数的行为。如果flag设置为AT_EACCESS，使用调用进程的有效用户ID和有效组ID进行访问检查，而不是实际用户ID和实际组ID 7. umask函数umask函数为进程设置文件模式创建屏蔽字，并返回之前的值，且没有出错返回 1234#include &lt;sys/stat.h&gt;// 返回值: 之前的文件模式创建屏蔽字mode_t umask(mode_t cmask); cmask参数是由9个不同的文件访问权限常量，按位或构成的 文件模式创建屏蔽字中为1的位，在文件模式中相应的位一定被关闭 更改进程的屏蔽字不会影响父进程的屏蔽字 常见的umask值有： 002，阻止其他用户写入文件 022，阻止同组成员和其他用户写入文件 027，阻止同组成员写入文件以及其他用户读、写或执行你的文件 8. chmod、fchmod 和 fchmodat 函数这三个函数可以更改现有文件的访问权限 123456#include &lt;sys/stat.h&gt;// 返回值: 成功返回0 出错返回-1int chmod(const char *pathname, mode_t mode);int fchmod(int fd, mode_t mode);int fchmodat(int fd, const char *pathname, mode_t mode, int flag); chmod函数在指定的文件上操作 fchmod函数对已打开的文件操作 fchmodat函数与chmod在以下情况是相同的： pathname是绝对路径 fd参数值为AF_FDCWD，pathname位相对路径 否则，fchmodname计算相对于打开目录，（由fd指定）的pathname。 flag参数可以用于更改fchmodat函数的行为，当flag为AT_SYMLINK_NOFOLLOW标志时，fchmodat函数不会跟随符号链接 mode参数是如下常量的按位或: 为了改变一个文件的权限，进程的有效ID必须等于用户的所有者ID，或者进程拥有超级用户权限 chmod函数在下列条件下自动清除两个权限位： Solaris等系统的普通文件，如果我们设置他们的粘着位，且没有超级用户权限，那么mode中的粘着位会被自动关闭 新创建的文件组ID可能不是调用进程所属的组。文件组ID可能是父目录的组ID，如果新文件的组ID不等于进程的有效组ID或附属组ID，且进程没有超级用户权限，那么文件的设置组ID为会被自动关闭 9. 粘着位粘着位即S_ISVTX位。如果一个可执行文件设置了粘着位，在程序第一次执行终止后，程序正文部分的副本被放入交换区，使得下次执行该程序时可以快速将其放入内存中。 因为早期Unix文件系统可能是随机放的，所以对于常用的应用，交换区的存在可以帮助他们快速载入内存。所以称为保存正文位(saved-text bit)，而现在的Unix大多是虚拟存储系统和快速文件系统，所以不需要这种技术了。 如今的系统也扩展了粘着位的适用范围，可以对目录使用粘着位。 如果对目录使用了粘着位，只有对该目录具有写权限的用户且满足下列条件之一，才能删除或重命名该目录下的文件： 拥有此文件 拥有此目录 是超级用户 10. chown、fchown、fchownat 和 lchown 函数这些函数用于更改文件的用户ID和组ID。 1234567#include &lt;unistd.h&gt;// 返回值: 成功返回0 出错返回-1int chown(const char *pathname, uid_t owner, gid_t group);int fchown(int fd, uid_t owner, gid_t group);int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);int lchown(const char *pathname, uid_t owner, gid_t group); 如果owner或group的值为-1，则对应的用户ID或组ID不变 lchown和在设置了``AT_SYMLINK_NOFOLLOW标志fchownat函数后，更改符号链接自身的用户ID或组ID fchown更改由fd参数指出的已打开文件的所有者，所以他不能更改符号链接自身的所有者，因为已经打开了文件 fchownat与chown或lchown在以下两种情况是相同的： fchownat函数的pathname参数是绝对路径 fd参数值为AT_FDCWD且pathname是相对路径 除此之外，如果flag设置了AT_SYMLINK_NOFOLLOW标志，fchownat与chown行为相同；反之，与lchown行为相同 如果fchownat的fd参数为打开目录的文件描述符，且pathname是相对路径，那么fchownat计算相对于打开目录的pathname POSIX.1中规定了常量_POSIX_CHOWN_RESTRICTED，可以使用pathconf或fpathconf查询。此选项还与所引用的文件有关。 若_POSIX_CHOWN_RESTRICTED对指定的文件生效， 只有超级用户进程可以修改该文件的用户ID 如果进程拥有此文件，即文件的用户ID等于进程的有效用户ID，参数owner等于-1或文件用户ID，且参数group等于进程的有效组ID或附属组ID，那么该进程可以修改该文加你的组ID 11. 文件长度stat结构成员st_size表示以字节为单位的文件长度，但此字段只对普通文件、目录文件和符号链接有意义。 普通文件，长度可以为0，在读这种文件时，会直接读到一个EOF 目录文件的长度通常是一个数的整数倍 符号链接的长度是所指的文件名的实际字节数，不包括结尾的NULL 文件空洞 文件空洞是因为设置的偏移量超过了文件长度，并写入数据造成的。 我们可以看到，file.hole文件大概有1.6M，通过du命令，我们发现实际使用的磁盘空间是8个块。 du命令是在Linux上的块数单位取决于环境变量POSIXLY_CORRECT。设置该环境变量时，单位为1024字节，否则时512字节 正常的文件IO读取的是整个文件的长度 复制文件时，这些空洞都会被填满，所有实际数据字节会被填充为0 同时，实际计算出的字节数（20*单位）可能略大于ls命令的长度。因为文件系统使用了一些指向实际数据块的指针 12. 文件截断12345#include &lt;unistd.h&gt;// 返回值: 成功返回0 出错返回-1int truncate(const char *pathname, off_t length);int ftruncate(int fd, off_t length); 这两个函数将文件长度截断为length，如果length小于实际文件长度，那么超过length的数据无法访问。如果length大于实际文件长度，文件长度将增加 ，之间的数据会被读作0，即创建了一个空洞。 13. 文件系统我们可以把一个磁盘分成多个分区，每个分区域可以包含一个文件系统。其中，i节点是固定长度的记录项，包含了文件的大部分信息。 两个目录快指向了一个i节点。每个i节点内有一个链接计数，值为指向该i节点的目录项的个数。只有在链接为0时，才可删除该文件，释放数据块。在stat结构中，st_nlink是链接计数，这种链接称为硬链接。 另一种链接是符号链接。符号链接文件的实际内容，即数据块中的数据，包含了指向的文件名字。 i节点包含文件有关的所有信息。stat结构的大多数信息取自i节点。只有文件名和i节点编号存放在目录项中。i节点编号类型为ino_t 目录项中的i节点编号指向同一文件系统中对应的i节点，不能指向另外一个文件系统的i节点 在不更换文件系统的情况下，对文件重命名时，只需构造一个指向现有i节点的目录项，删除老的目录项。 目录文件的链接计数 假设我们创建一个空目录testdir，文件系统如下所示： 第一个目录块是testdir的，第二个是当前目录的。 我们可以看出，2549的i节点链接计数是2，分别是testdir的.项和当前工作目录的testdir项 1267的i节点链接计数是3，分别是testdir的..项，当前工作目录的.项和其父目录中的目录项 所有叶目录，即没有子目录的目录，其链接计数都是2 14. link、linkat、unlink、unlinkat 和 remove 函数任何文件可以有多个目录项指向其i节点，创建一个指向现有文件的链接的函数为link和linkat。 12345#include &lt;unistd.h&gt;// 返回值: 成功返回0 出错返回-1int link(const char *existingpath, const char *newpath);int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag); 这两个函数创建一个新目录项newpath，引用现有文件existingpath。如果newpath存在，函数出错。之创建newpath中最后一个分量，路径的其他部分应该已经存在。 linkat函数，现有文件通过efd和existingpath确定，新文件通过nfd和newpath确定。 如果两个路径名中存在相对路径，那么需要通过文件描述符计算 如果两个文件描述符有一个是AT_FDCWD，路径会通过当前目录激素那 如果两个路径有一个是绝对路径，文件描述符会被忽略 如果现有文件是符号链接，flag参数指出了是否跟随符号链接。如果设置了AT_SYMLINK_FOLLOW，创建指向符号链接目标的链接。否则创建指向符号链接本身的链接。 创建新目录和增加链接计数应该是一个原子操作。 删除一个现有目录项，使用unlink函数。 12345#include &lt;unistd.h&gt;// 返回值: 成功返回0 出错返回-1int unlink(const char *pathname);int unlinkat(int fd, const char *pathname, int flag); 这两个函数删除目录项，并将pathname引用的文件的链接计数减1。如果出错，不进行任何更改。必须对包含该目录项的目录具有写和执行权限。 在链接计数为0时，内核会检查是否有进程打开了该文件，如果打开该文件进程数为0，且链接计数也为0，才会删除该文件。 unlinkat函数的参数规则和linkat相同。 flag参数可以改变unlinkat函数的行为。设置AT_REMOVEDIR后，unlinkat函数类似于rmdir，可以删除目录。如果该标志清除，那么unlinkat行为与unlink一致。 如果pathname是符号链接，unlink删除符号链接自身。没有函数能够删除符号链接引用的文件。 也可以使用remove函数解除对文件和目录的链接。对于文件，remove和unlink相同，对于目录，remove和rmdir相同。 1234#include &lt;stdio.h&gt;// 返回值: 成功返回0 出错返回-1int remove(const char *pathname); 15. rename 和 renameat 函数文件或目录可以通过rename和renameat函数重命名。 1234#include &lt;stdio.h&gt;int rename(const char *oldname, const char *newname);int renameat(int oldfd, const char *oldname, int newfd, const char *newname); 根据oldname的类型，有以下几种情况： oldname指向文件，为该文件重命名。如果newname存在，则它不能是一个目录，之后删除newname目录项，将oldname重命名为newname。 oldname指向目录，为该目录重命名。如果newname存在，则它不许是一个目录，且为空，之后删除newname目录项，将oldname重命名为newname。 newname不能包含oldname前缀。因为oldname是newname的前缀，不能被删除。 oldname或newname是符号链接，则处理符号链接自身，不处理其引用的文件。 不能重命名.和.. oldname和newname指向同一文件，函数不做任何事情，直接成功返回。 进程需要删除oldname目录项，创建newname目录项，如果newname存在，则需要先删除该目录项。所以对包含oldname的目录和包含newname的目录都应具有写权限。 16. 符号链接符号链接是对文件的间接指针，为了避开硬链接的限制。 硬链接通常要求链接和文件在同一文件系统下 只有超级用户才能创建指向目录的硬链接 而符号链接的对象和文件系统都没有限制，任何用户都可以创建。符号链接通常用于将目录或文件结构移到系统的另一个位置。 参数为文件名的函数，需要注意是否处理符号链接。 上图中的一个例外是，使用O_CREATE和O_EXCL调用open函数，如果路径是符号链接，则会出做，errno设置为EEXIST。目的是防止特权进程被诱导写错误的文件。 使用符号链接可能会导致循环引用，大多数查找路径名函数都会在此时出错，errno置为ELOOP。 17. 创建和读取符号链接使用symlink和symlinkat函数创建符号链接 12345#include &lt;unistd.h&gt; // 返回值: 成功返回0 出错返回-1int symlink(const char *actualpath, const char *sympath);int symlinkat(const char *actualpath, int fd, const char *sympath); 函数创建一个指向actualpath的新目录项sympath。不要求actualpath已经存在，且不需要在同一文件系统之下。 打开符号链接，并读取链接的内容，使用readlink和readlinkat函数 12345#include &lt;unistd.h&gt;// 返回值: 成功返回读取的字节数 出错返回-1ssize_t readlink(const char* restrict pathname, char* restrict buf, size_t bufsize);ssize_t readlinkat(int fd, const char* restrict pathname, char* restrict buf, size_t bufsize); 这两个函数组合了open、read和close。如果函数成功执行，返回读入buf的字节数，且buf的内容不以null结束。 18. 文件时间每个文件维护三个时间字段，意义如下： 修改一个文件或目录时，包含该文件或目录的父目录也会被修改。因为不仅仅修改其i节点，但是读/写一个文件只影响他的i节点。 19. futimens、utimenstat 和 utimes函数一个文件的访问和修改时间可以通过这三个函数修改。其中，futimens和utimenstat 可以指定纳秒级别的精度。 12345#include &lt;sys/stat.h&gt;// 返回值: 成功返回0 出错返回-1int futimens(int fd, const struct timespec times[2]);int utimenstat(int fd, const char* pathname, const struct timespec times[2], int flag); 这两个函数的times数组中的第一个元素为访问时间，第二个元素为修改时间。这两个时间值是日历时间。 times参数有以下四种形式： times是空指针，访问时间和修改时间被设置为当前时间 times是指向两个timespec结构的指针，如果任一元素的tv_nsec值为UTIME_NOW，忽略tv_sec字段，对应的时间设置为当前时间 times是指向两个timespec结构的指针，如果任一元素的tv_nsec值为UTIME_OMIT，对应的时间保持不变 times是指向两个timespec结构的指针，且任一元素的tv_nsec值不是UTIME_NOW或UTIME_OMIT，对应时间设置为tv_sec和tv_nsec的值 执行这些函数需要的权限取决于times参数的值 times是空指针，或如果任一元素的tv_nsec值为UTIME_NOW，则进程的有效ID必须等于该文件所有者ID，进程对该文件具有写权限；或进程是一个超级用户进程 times是非空指针，且任一元素的tv_nsec值不是UTIME_NOW也不是UTIME_OMIT，则进程的有效ID必须等于该文件所有者ID，或进程是一个超级用户进程，进程对该文件只具有写权限是不够的 times是非空指针，且tv_nsec的两个字段都是UTIME_OMIT，不执行权限检查 futimens需要打开文件来更改时间。utimenstat行为类似通常的at结尾函数。 utimenstat函数的flag参数用于符号链接跟随，如果设置AT_SYMLINK_NOFOLLOW，符号链接自身时间被修改。否则会跟随符号链接，将文件的时间修改为符号链接的时间。 123456789#include &lt;sys/times.h&gt;// 返回值: 成功返回0 出错返回-1int utimes(const char* pathname, const struct timeval times[2]);struct timeval &#123; time_t tv_sec; // 秒 long tv_usec; // 微妙&#125; utimes函数对路径名操作。 我们不能修改状态时间，因为调用这些函数时，状态时间字段会被自动更新。 20. mkdir、mkdirat 和 rmdirmkdir和mkdirat用于创建目录，rmdir用于删除目录 12345#include &lt;sys/stat.h&gt;// 返回值: 成功返回0 出错返回-1int mkdir(const char* pathname, mode_t mode);int mkdirat(int cd, const char* pathname, mode_t mode); 这两个函数创建一个空目录，其中.和..时是自动创建。mode指定文件访问权限，由进程的文件模式创建屏蔽字修改。 常见的错误是指定与文件相同的mode，即读写，但是目录还需要执行权限，一边访问目录内的文件名 rmdir用于删除空目录，空目录只包含.和.. 1234#include &lt;unistd.h&gt;// 返回值: 成功返回0 出错返回-1int rmdir(const char* pathname); 如果调用rmdir后，目录的链接计数为0，且没有其他进程打开该目录，则释放该目录占据的空间。 如果目录的链接计数为0，有其他进程打开该目录，则在rmdir返回前，删除最后一个链接及.和..项。且在此目录中不能创建文件，但是在最后一个进程关闭之前不释放此目录。 21. 读目录对目录具有访问权限，就可以读目录。但是只有内核才能写目录。 读取目录的函数有很多，如下： 123456789101112131415161718#include &lt;dirent.h&gt;// 返回值: 成功返回指针 出错返回NULLDIR* opendir(const char* pathname);DIR* fdopendir(int fd);// 返回值: 成功返回指针 若在目录尾或出错返回NULLstruct dirent* readdir(DIR* dp);void rewinddir(DIR* dp);// 返回值: 成功返回0 出错返回-1int closedir(DIR* dp);// 返回值: 与dp关联的目录中的当前位置long telldir(DIR* dp);void seekdir(DIR* dp, long loc); fopendir将打开的文件描述符转换为目录处理函数需要的DIR结构 telldir和seekdir，在符合UNIX系统的实现都会提供这两个函数 dirent结构与实现有关，此结构的定义至少包含下列两个成员 1234ino_t d_ino; // i节点编号char d_name[]; // 不包含NULL终止字节的文件名// d_name的大小没有指定，至少要包含NAME_MAX个字节 opendir和fdopendir返回的指向DIR结构的指针由其他五个函数调用。opendir执行初始化操作，使第一个readdir返回目录中的第一个目录项。fdopendir执行初始化操作，第一个readdir返回的目录项取决于fd的文件偏移量。 目录中的各项顺序与实现有关，通常不按照字母顺序排列 22. chdir、fchdir 和 getcwd函数每个进程都有一个当前工作目录，作为搜索所有相对路径名的起点。 进程调用chdir和fchdir函数更改当前工作目录。 12345#include &lt;unistd.h&gt;// 返回值: 成功返回0 出错返回-1int chdir(const char* pathname);int fchdir(int fd); 内核只保存指向该目录v节点的指针等目录本身信息，不保存该目录的完整路径名。 Linux内核可以确定完整路径名，完整路径名的组成部分保存在mount表和dcache表中，然后重新组装。 需要一个函数，从当前工作目录，.开始，用..找到其上级目录，然后读取目录项，直到目录项中i节点编号与工作目录i节点编号相同，就找到了对应的文件名。以此类推，直到根目录，就得到了当前工作目录的完整路径名。getcwd就是这样。 1234#include &lt;unistd.h&gt;// 返回值: 成功返回buf 出错返回NULLchar* getcwd(char* buf, size_t size); buf为缓冲区地址，size为缓冲区长度，必须足够容纳路径名以及终止null字节。否则返回出错。 23. 设备特殊文件st_dev和st_rdev这两个字段容易引起混淆。其规则如下： 每个文件系统所在设备都由其主、次设备号组成。设备号的数据类型为st_dev。主设备号标识设备驱动程序，有时编码为与其通信的外设板；次设备号标识特定的子设备。 通常使用宏，major和minor来访问主、次设备号 stat结构的st_dev是该文件所在文件系统的设备号，该文件系统包含了这一文件名与其对应的i节点 只有字符特殊文件和块特殊文件才有st_rdev值。包含实际设备的设备号 24. 文件访问权限小结 最后9个常量可以分成三组 123S_IRWXU = S_IRUSR | S_IWUSR | S_IXUSRS_IRWXG = S_IRGRP | S_IWGRP | S_IXGRPS_IRWXO = S_IROTH | S_IWOTH | S_IXOTH","categories":[{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"}]},{"title":"apue-3.文件IO","slug":"apue-3-文件IO","date":"2021-02-04T14:00:25.000Z","updated":"2021-02-04T14:03:50.450Z","comments":true,"path":"2021/02/04/apue-3-文件IO/","link":"","permalink":"http://example.com/2021/02/04/apue-3-%E6%96%87%E4%BB%B6IO/","excerpt":"","text":"1.文件描述符对于内核而言，所有打开的文件都通过文件描述符来使用。文件描述符是非负整数，当打开或创建一个文件时，内核返回一个文件描述符。 早期unix使用幻数0、1、2来分别标识标准输入、标准输出和标准错误。如今这些幻数在POSIX.1中被STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO代替。 文件描述符的范围为[0,OPEN_MAX-1]，其中OPEN_MAX可以调用sysconf动态获取。 2. open和openat函数调用这两个函数可以打开或创建一个文件。 123456#include &lt;fcntl.h&gt;// 返回值: 成功返回文件描述符 失败返回-1int open(const char *path, int oflag, ../* mode_t mode */);int openat(int fd, const char *path, int oflag, ../* mode_t mode */); 参数说明： path参数是要打开或创建的文件的名字 oflag参数说明此函数的选项，参数列表如下： O_RDONLY，只读打开 O_WRONLY，只写打开 O_RDWR，读、写打开 O_EXEC，只执行打开 O_SEARCH，只搜索打开，应用于目录 以上五个常量中，必须且只能选择一项，下列常量是可以选择的 O_APPEND，每次写时，追加到文件尾 O_CLOEXEC，把FD_CLOEXEC常量设置为文件描述符标志 O_CREAT，若文件不存在，就创建文件。使用该选项时，需要指定mode参数，代表文件的访问权限 O_DIRECTROY，如果path不是目录，就出错 O_EXCL，如果同时指定了O_CREAT，而文件已经存在，就出错。可以测试文件是否存在，如果不存在就创建一个文件 O_NOCTTY，如果path引用的是终端设备，则不讲该设备分配作为此进程的控制终端 O_NOFOLLOW，如果path引用的是一个符号链接，则出错 O_NONBLOCK，如果path引用的是FIFO、块特殊文件或字符特殊文件，则将文件的本次打开操作和后续的IO操作设置为非阻塞方式 O_SYNC，使得每次write操作等待物理IO操作完成，包括由该write操作引起的文件更新的IO操作 O_TRUNC，如果文件存在，而且是以只读或读写打开，则将其长度截断为0 O_TTY_INIT，如果打开一个还未打开的终端设备，设置非标准termios参数，使之符合Single Unix Specification O_DSYNC，每次write操作要等待物理IO操作完成，但如果该写操作不影响读取刚才写入的数据，则不需要等待文件属性更新 O_RSYNC，使每一个文件描述符作为参数的read操作等待，直至所有对文件同一部分挂起的写操作完成 open和openat函数返回的文件描述符一定是最小的未用文件描述符 fd参数可以区分open和openat函数，有以下三种情况 path参数是绝对路径，fd参数被忽略，openat函数就是open函数 path参数是相对路径，fd参数为相对路径在文件系统中的开始地址。fd参数通过打开相对路径所在的目录获取 path参数是相对路径，fd参数是特殊值AT_FDCWD。路径名在当前工作目录中获取，openat函数在操作上于open函数相同 openat函数希望解决两个问题 让线程以相对路径名打开文件 避免time of check to time of use(TOCTTOU)错误。该错误的基本思想是：两个基于文件的操作，第二个操作依赖第一个操作的结果，程序就可能是脆弱的 文件名和路径名阶段 如果文件名长度有限制，即NAME_MAX为14，而创建一个15个字符的文件，此时有两种情况： 早期系统中，将文件名截断为14个字符，不给出任何提示 返回出错信息，errno设置为ENAMETOOLONG 在POSIX.1中，_POSIX_NO_TRUNC决定是截断文件还是出错。可以通过pathconf或fpathconf来获取。如果该常量有效，则会出错返回。 3. creat函数该函数用于创建一个文件 1234#include &lt;fcntl.h&gt;int creat(const char *path, mode_t mode);// 相当于 open(path, O_WRONLY | O_CREAT | O_TRUNC, mode); 4. close函数关闭一个打开的文件 123#include &lt;unistd.h&gt;int close(int fd); 关闭文件时，还会释放进程在该文件上的所有记录锁。一个进程终止时，内核自动关闭他的所有文件。 5. lseek函数除非指定O_APPEND时，每次打开一个文件，默认的文件偏移量都为0。 可以调用lseek设置一个文件偏移量。 1234#include &lt;unistd.h&gt;// 返回值: 成功返回新的文件偏移量 失败返回-1off_t lseek(int fd, off_t offset, int whence); offset的解释于whence有关 whence是SEEK_SET，则文件偏移量为距文件开始处的offset个字节 whence是SEEK_CUR，则文件偏移量是当前值加上offset，offset可正可负 whence是SEEK_END，则文件偏移量是文件长度加上offset，offset可正可负 如果文件描述符执行的是管道、FIFO或网络套接字，lseek返回-1 文件偏移量在某些设备上是可以为负的，所以在比较返回值时，不能小于0，必须测试是否等于-1。 lseek仅将当前的文件偏移量记录在内核当中，不引起任何IO操作，该偏移量用于下一个IO操作。 文件偏移量如果大于文件长度，下一次写操作将会加长文件长度，并且留下一个空洞，空洞内的字节全为0。文件空洞不需要在磁盘上占用存储区，具体的存储方式与系统有关。新写的数据需要存储空间，但是空洞区域时不需要的。 6. read函数从文件中读取数据 1234#include &lt;unistd.h&gt;// 返回值: 成功返回读取到的字节数 若已经到了文件尾，返回0 出错返回-1ssize_t read(int fd, void *buf, ssize_t nbytes); 有很多情况会使得实际读到的字节数少于要求读到的字节数 读普通文件时，读到要求字节数之前已经达到了文件尾 从终端设备读取时，通常一次最多读取一行 从网络读时，网络的缓冲机制可能导致 从管道或FIFO读时，若管道包含的字节数少于所需，也会返回实际读取的字节 从某些面向记录的设备（磁带）读取时，一次最多返回一个记录 当信号造成中断，却已经读取了部分的数据 7. write函数向打开的文件写数据 1234#include &lt;unistd.h&gt;// 返回值: 成功返回已写的字节数 出错返回-1ssize_t write(int fd, const void *buf, ssize_t nbytes); 返回值通常与nbytes一致，否则表示出错。write出错的可能原因为磁盘满，或超过了一个给定进程的文件长度限制 如果在打开文件时指定了O_APPEND，每次write函数都会在将文件偏移量设置在文件尾，成功写入之后，将文件偏移量加上实际写的字节数。 8. IO效率在使用不同bufsize进行读取时，大多数文件系统采用预读技术，在检测到正顺序读取时，系统就试图读入比应用要求更多的数据，并假设应用可以很快的读完这些数据。 9. 文件共享Unix系统支持在进程之间共享打开文件，内核用于IO的数据结构有三种，他们的关系决定了在文件共享中，进程之间的影响。 每个进程在进程表中都有一个记录项，记录项包含一张打开文件描述符表，每个描述符占用一项，与每个文件描述符相关的是 文件描述符标志 指向一个文件表项的指针 内核为所有打开文件维护一张文件表，每个文件表项包含 文件状态标志 当前文件偏移量 指向该文件v节点表项的指针 每个打开的文件都有一个v节点结构，v节点包含了文件类型和对此文件进行各种操作函数的指针。 对于大多数文件，还有一个i节点，(i-node 索引节点)。这些信息都是在打开文件，从磁盘读入内存中时就获取的。 Linux没有v节点，而是使用了通用i节点结构，但是两者从根本上是一样的。 如果一个进程打开了两个文件，三种表之间的关系如下： 如果两个独立进程打开了同一个文件，三种表关系如下: 每个进程都有自己的文件表项，使得每个进程都有自己对应该文件的文件偏移量。 对于之前的IO函数，他们在这三张表中的相互作用如下： 完成write函数后，文件表项的当前文件偏移量增加写入的字节数 如果结果超出了当前文件长度，就将i节点中的当前文件长度设置为当前文件偏移量 用O_APPEND打开文件，文件表项中的文件状态标志被设置。每次写操作时，都会将当前文件偏移量设置为i节点中的当前文件长度 使用lseek定位到文件尾，文件表项中的当前文件偏移量设置为i节点中的当前文件长度 lseek函数只修改文件表项中的当前文件偏移量，不做其他任何IO操作 10. 原子操作原子操作指由多步组成的一个操作，该操作要么全部执行，要么一个都不执行。为了解决可能存在的多进程冲突问题。 为此，有两个原子的函数，pread和pwrite 12345#include &lt;unistd.h&gt;ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset); pread相当于先调用lseek，在进行read，但是也有些不同 调用pread时，无法中断其定位和读操作 不更新当前文件偏移量 pwrite同理，但是也有上述的区别 11. dup和dup2函数下面两个函数用于复制一个现有的文件描述符 123456#include &lt;unistd.h&gt;// 两个函数返回值相同，成功返回新的文件描述符，失败返回-1int dup(int fd);int dup2(int fd, int fd2); dup返回的文件描述符一定是最小的可用文件描述符。 dup2可以由fd2参数指定新描述符的值。 如果fd2已经打开了，先将其关闭 如果fd参数等于fd2参数，dup2返回fd2，且不关闭它 如果不这么做，fd2的FD_CLOEXEC文件描述符标志就被清除，fd2在进程调用exec时总是打开状态 这两个函数返回的文件描述符与fd共用一个文件表项 12. sync、fsync和fdatasync函数Unix系统在内核中设置有缓冲区高速缓存或页高速缓存，大多数磁盘IO都通过缓冲区进行。在写入文件时，内核将数据复制到缓冲区，排入队列，晚些在写入磁盘，这种方式称为延迟写。 当内核需要重用缓冲区存放数据时，就会将所有延迟写数据写入磁盘。为了保证磁盘中数据与缓冲区中数据一致性，可以通过函数实现 1234567#include &lt;unistd.h&gt;// 返回值: 成功返回0 出错返回-1int fsync(int fd);int fdatasync(int fd);void sync(void); sync将所有修改过的块缓冲区排入写队列，返回。不等待实际磁盘IO结束。 通常，称为update的系统守护进程周期性的调用sync函数，保证定期刷新内核的缓冲区。 fsync只对文件描述符指定的文件起作用，并且等待实际磁盘IO结束，并更新文件属性，适合数据库应用。 fdatasync类似fsync，但是只对文件数据部分起作用，不修改文件属性。 13. fcntl函数该函数可以改变已打开文件的属性 1234#include &lt;fcntl.h&gt;// 返回值: 成功，返回值依赖cmd 出错返回-1int fcntl(int fd, int cmd, .../* int arg */); fcntl有以下五种功能： 复制一个已有描述符，cmd = F_DUPFD 或 F_DUPFD_CLOEXEC 获取、设置文件描述符标志，cmd = F_GETFD 或 F_SETFD 获取、设置文件状态标志，cmd = F_GETFL 或 F_SETFL 获取、设置异步IO所有权，cmd = F_GETOWN 或 F_SETOWN 获取、设置记录锁，cmd = F_GETLK、F_SETLK 或 F_SETLKW 下面详细介绍这些cmd F_DUPFD，复制文件描述符fd。新文件描述符作为返回值，是尚未打开的大于等于第三个参数值中各值的最小值。 新文件描述符与fd共享同一文件表项，与fd的文件描述符标志独立，其FD_CLOEXEC被清除 可以使用该cmd实现dup和dup2函数 12345// dup函数dup(fd) == fcntl(fd, F_DUPFD, 0);// dup2函数close(fd2);dup2(fd, fd2) == fcntl(fd, F_DUPFD, fd2); F_DUPFD_CLOEXEC，复制文件描述符fd，设置新文件描述符的FD_CLOEXEC，返回新文件描述符 F_GETFD，返回fd对应的文件描述符标志。当前只有一个文件描述符标志FD_CLOEXEC F_SETFD，设置fd对应的文件描述符标志，新标志值按第三个参数设置 F_GETTL，返回fd对应的文件状态标志，文件状态标志就是open函数中的oflag参数，具体如下： 但是，5个文件访问方式标志（O_RDONLY OWRONLY O_RDWR O_EXEC O_SEARCH）不占1位，他们之间是互斥的。所以必须先用屏蔽字O_ACCMODE获取访问方式位，然后将结果与这五个值一一比较。 F_SETTL，设置fd对应的文件状态标志，新标志值是第三个参数。可以更改的几个标志是：O_APPEND O_NONBLOCK O_SYNC O_DSYNC O_RSYNC O_FSYNC O_ASYNC O_GETTOWN，获取当前接收SIGIO和SIGURG信号的进程ID或进程组ID。返回正数进程ID或负数进程组ID O_SETTOWN，设置接收SIGIO和SIGURG信号的进程ID或进程组ID。正数arg表示进程ID，负数arg表示arg绝对值的进程组ID 14. ioctl函数ioctl函数是IO操作的杂物箱，不能用其他函数表示的IO操作通常都可以用ioctl表示。终端IO也是ioctl的常用场景 12345#include &lt;unistd.h&gt;#include &lt;sys/ioctl.h&gt;// 返回值: 成功返回其他值 出错返回-1int ioctl(int fd, int request, ...); 每个设备驱动程序都可以定义他自己的一组ioctl命令，系统为不同的设备提供通用的ioctl命令。 磁带操作可以在磁带上写一个文件结束标志、倒带、越过指定个数的文件或记录。这些操作使用本章其他函数难以表示，所以需要使用ioctl函数，方便操作。 15. /dev/fd/dev/fd目录中包含了名为0、1、2等的文件。打开文件/dev/fd/n相当于复制文件描述符n。即： 1234fd = open(&quot;/dev/fd/0&quot;, mode);// mode参数可以忽略，在一些系统上，mode要求为原始文件的打开模式的子集// 等价于fd = dup(0); 在Linux中，情况有所不同 Linux中的/dev/fd文件，将文件描述符映射成指向底层物理文件的符号链接。 当打开/dev/fd/0文件时，事实上正在打开与标准输入相关联的文件，返回的新文件描述符的打开模式与/dev/fd中的打开模式并不相同 我们也可以以/dev/fd作为路径名参数调用creat函数。但在Linux上要小心，因为这会导致底层文件被截断","categories":[{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"}]},{"title":"unp_4.基本套接字编程","slug":"unp-4-基本套接字编程","date":"2021-01-31T14:03:51.000Z","updated":"2021-02-04T13:59:44.600Z","comments":true,"path":"2021/01/31/unp-4-基本套接字编程/","link":"","permalink":"http://example.com/2021/01/31/unp-4-%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/","excerpt":"","text":"1.概述TCP版本的网络通信如下： 2.socket函数网络通信的第一步就是调用socket函数 123#include &lt;sys/socket.h&gt;int socket(int family, int type, int protocol); family参数指明协议族，具体常值如下： type参数指明套接字类型，具体常值如下： protocol参数为0或者如下： family和type参数的组合反映了对应的协议，如下： “是”代表有效组合，但没有合适的缩略词，空白则是无效组合。 socket函数成功后，返回一个小的非负整数，称为套接字描述符（socket descriptor），简称sockfd。 3.connect函数TCP客户端使用connect函数建立于TCP服务器的连接。 1234#include &lt;sys/socket.h&gt;// 返回值: 成功返回0，出错返回-1int connect(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen); sockfd是socket函数创建的套接字描述符，第二、第三个参数分别是套接字地址结构指针和该结构的大小。 客户端在调用connect函数时，不必先调用bind，内核会确定源IP地址和选择一个临时端口。 TCP的connect函数会触发三路握手，在成功或出错后返回，出错有以下几种情况： TCP客户没有收到SYN分节响应，返回ETIMEDOUT错误。 客户的SYN响应是RST（表示复位），代表服务器在端口上没有进程与之连接，客户接收到RST，返回ECONNREFUSED错误。 RST是TCP在发生错误时发送的一种TCP分节，产生RST的条件有： 服务器端口上的SYN到达，但是没有对应的进程监听 TCP想取消一个已有连接 TCP接收到一个根本不存在的连接上的分节 客户发出的SYN在某个路由器上出现了目的地不可达的ICMP错误。在一定时间重发后，把消息作为EHOSTUNREACH或ENETUNREACH错误返回给进程。 或者是以下两种情形： 本地系统转发表没有到目的地的路径 connect调用不等待就直接返回 4.bind函数bind函数把一个本地协议地址赋给一个套接字。 1234#include &lt;sys/socket.h&gt;// 返回值: 成功返回0， 出错返回-1int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen); 第二个参数是指向特定协议的地址结构的指针，第三个参数时该地址结构的长度。在使用时，可以仅指定其中一个，也可以都不指定 如果未指定，内核会为套接字选择一个临时端口和自身对应的ip地址 客户端未指定地址是可以理解的，除非需要使用一个预留端口 服务端未指定地址，内核会把客户发送的SYN的目的IP地址作为服务器的源IP地址 第二、第三参数的搭配结果如图： 如果端口为0，内核在bind被调用时选择一个临时端口 如果ip地址为通配地址，内核将等到套接字已连接(TCP)，或套接字上发出数据报报(UDP)时，选择一个本地IP地址 对于IPv4，通配地址一般是INADDR_ANY，IPv6则不同 12345struct sockaddr_in servaddr;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);struct sockaddr_in6 serv;serv.sin6_addr = in6addr_any; in6addr_any会被系统定义并初始化，头文件&lt;netinet/in.h&gt;中有该声明 5.listen函数listen函数有服务器调用时，会做两件事情。 在socket函数创建一个套接字时，套接字被假设为主动套接字，即主动发起连接。listen函数把一个未连接的套接字转换为被动套接字，内核接受指向该套接字的连接请求。 套接字从CLOSED状态切换到LISTEN状态。 listen函数的第二个参数指定内核为套接字连接请求排队的最大连接个数 1234#include &lt;sys/socket.h&gt;// 返回值: 成功返回0，出错返回-1int listen(int sockfd, int backlog); 内核为给定的监听套接字维护两个队列： 未完成连接队列。每个SYN分解对应一项，是客户与服务器之间的TCP三次握手过程。 已完成连接队列。已完成TCP三次握手的客户 这两个队列之和不超过backlog TCP的连接建立是完全自动的，无需服务器进程插手，下图是两个队列建立连接 客户的SYN到达服务器时，TCP在未完成队列中创建一项，接着返回给客户端，等待第三个分节到达或者该项超时。三路握手正常结束后，该项从未完成队列移动到已完成队列队尾。 进程调用accept函数时，从已完成队列队头返回给进程，如果该队列为空，进程会被睡眠，直到TCP在已完成队列中新增一项后，唤醒该进程。 对于backlog参数，有以下几项需要注意 backlog参数曾被规定为两个队列总和 Berkeley的实现给backlog增加了一个模糊因子：将backlog乘1.5，得到未处理队列的最大长度 backlog不要设为0，如果不希望客户连接该套接字，关闭该套接字 backlog的大小设置，一般通过环境变量或命令行来设置。如果该值比内核支持的最大值还要大，内核会将该值截断为自身能够支持的最大值。 当一个客户的SYN到达时，若队列满了， 就会忽略该分节。客户端就会通过TCP重传机制来处理 三路握手完成后，在服务器调用accept之前，到达的数据有服务器TCP排队，保存在相应已连接套接字的接受缓冲区中 6.accept函数accept函数由TCP服务器调用，从已完成队列队头返回一个已完成连接。如果已完成队列为空，进程进入睡眠。 1234#include &lt;sys/socket.h&gt;// 返回值: 成功返回非负描述符，出错返回-1int accept(int sockfd, struct sockaddr* cliaddr, socklen_t* addrlen); 参数cliaddr和addrlen用来返回已连接的客户端的协议地址。**addrlen是值-结果参数**，调用时，该参数为cliaddr所指的套接字地址结构的长度；返回时，为内核放在套接字地址结构中的具体字节数。 如果accept成功，返回一个由内核生成的全新套接字描述符，代表与客户的TCP连接。 第一个参数称为监听套接字描述符（由socket函数创建，用于bind和listen函数的参数）。 accept函数的返回值称为已连接套接字描述符。 一个服务器通常只有一个监听套接字，在服务器运行时一直存在。 内核为每个已连接TCP客户端创建一个已连接套接字，在服务器服务结束后，关闭这个已连接套接字。 7. fork和exec函数7.1 fork函数Unix中派生新进程的唯一方法，用于并发服务器。 1234#include &lt;unistd.h&gt;// 返回值: 在子进程中返回0，在父进程中返回子进程ID，出错返回-1pid_t fork(void); fork调用一次，返回两次。 在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID 在子进程中返回一次，返回值为0 返回值是告诉当前进程是父进程还是子进程 这样设置返回值的原因在于，子进程只有唯一的父进程，可以通过getppid获得父进程ID。而父进程无法获得各个子进程的进程ID，所以每次需要记录fork返回值 父进程中，在调用fork打开的所有套接字描述符，在子进程中共享。通常情况下，网络服务器中父进程调用accept后，调用fork，接着子进程读写这个已连接套接字，父进程关闭这个已连接套接字。 fork的典型用法如下： 一个进程创建一个自身的副本，每个副本在另一个副本执行其他任务的同时处理各自的某个操作。网络服务器的典型用法 一个进程想执行另一个程序。该进程调用fork创建一个自身副本，其中一个副本调用exec将自身替换成新的程序。shell之类的程序的典型用法 7.2 exec函数可执行程序被Unix执行的唯一方法是：有一个现有进程调用六个exec函数中的某一个。 exec函数将当前进程映像替换为新的程序文件，新程序通常从main函数开始执行，进程ID不变化。我们称调用exec的进程为调用进程 六个exec函数的区别在于： 待执行的程序文件由文件名指定还是由路径指定 新程序的参数一一列出还是由指针数组引用 调用进程的环境传递给新程序，还是新程序指定新环境 12345678910#include &lt;unistd.h&gt;int execl(const char* pathname, const char* arg0, .../* (char*) */);int execv(const char* pathname, const char* argv[]);int execle(const char* pathname, const char* arg0, .../* (char*) 0, char* const envp[]*/);int execve(const char* pathname, const char* argv[], char* const envp[]);int execlp(const char* pathname, const char* arg0, .../* (char*) 0*/);int execvp(const char* pathname, const char* argv[]); 这些函数之间的关系如下： 一般来说，execve是内核中的系统调用，其他exec函数都是调用execve的库函数 上面的三个函数，把新程序的每个参数作为独立参数，以空指针结束这些参数。 下面的三个函数，有一个指针数组，指向各个参数字符串，并以空指针结尾 左列两个函数指定filename参数，函数使用当前的PATH环境变量将其转化为路径。但是如果filename含有左斜杠/，就不使用PATH环境变量。右两列四个函数以路径名作为参数 左两列4个函数使用外部变量environ的当前值，构造一个环境列表。右列2个函数指定环境列表，envp指针数组以空指针结束 8. 并发服务器并发服务器的框架如下： 12345678910111213141516171819int main(void) &#123; pid_t pid; int listenfd, connfd; listenfd = Socket(..); Bind(listedfd, ..); Listen(listenfd, LISTENQ); for (; ;) &#123; connfd = Accept(listenfd, ..); if ( (pid == Fork()) == 0) &#123; Close(listenfd); do_it(connfd); // 处理请求，传递数据 Close(connfd); exit(0); &#125; Close(connfd); &#125;&#125; 为什么子进程要关闭listenfd? 父进程关闭connfd **每个文件和套接字都有一个引用计数，在文件表项中维护 (APUE P58-59)**。 在fork之后，套接字在子进程中共享，引用计数增加1。所以，父进程关闭connfd和子进程关闭listenfd只是将引用计数从2变为1 具体情况如图： accept之前 accept之后，fork之前 调用fork 父进程关闭connfd，子进程关闭listenfd 9. close函数close函数用于关闭套接字，终止TCP连接 1234#include &lt;unistd.h&gt;// 返回值: 成功返回0 出错返回-1int close(int sockfd); close一个TCP套接字的默认行为是把该套接字标记成已关闭，然后立即返回调用进程，之后该套接字不能被使用。 然后TCP会尝试发送所有排队等待发送的数据，之后发送TCP终止序列 描述符引用计数 如果我们的确想在某个TCP套接字上发送FIN，可以调用shutdown函数代替close 10. getsockname和getpeername函数getsockname返回与某个套接字关联的本地协议地址，getpeername返回与某个套接字关联的外地协议地址 12345#include &lt;sys/socket.h&gt;// 返回值: 成功返回0 出错返回-1int getsockname(int sockfd, struct sockaddr* localaddr, socklen_t* addrlen);int getpeername(int sockfd, struct sockaddr* peeraddr, socklen_t* addrlen); 这两个函数的后两个参数都是值-结果参数 这两个函数某个连接的两端的协议地址，对于IPv4和IPv6说，即IP和端口 这两个函数的用处 使用getsockname获得对应的ip地址和由内核分配的端口号 获得accept函数得到的已连接套接字的ip和端口 当进程调用exec调用服务器时，getpeername是唯一获得客户ip和端口的方式 因为exec会使进程的内存映像替换为新的服务器的程序文件，原先保存对端地址的内存丢失了。但是已连接套接字是跨exec开放的，新服务器获取已连接套接字的方式有两种： 先将套接字转换为字符串，通过命令行参数传递给新程序 约定将某些描述符置为已连接套接字的描述符","categories":[{"name":"unp","slug":"unp","permalink":"http://example.com/categories/unp/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"unp_3.套接字编程简介","slug":"unp-3-套接字编程简介","date":"2021-01-31T14:00:49.000Z","updated":"2021-01-31T14:22:33.547Z","comments":true,"path":"2021/01/31/unp-3-套接字编程简介/","link":"","permalink":"http://example.com/2021/01/31/unp-3-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1. 套接字地址结构大多数套接字函数都需要一个只想套接字地质结构的指针作为参数，每个协议族也定义了自身的套接字地址，这些结构以sockaddr_开头，并以对应每个协议族的唯一后缀结尾。 1.1 IPv4套接字地址结构IPv4套接字地址结构以sockaddr_in命名，定义在&lt;netinet/in.h&gt;头文件中，POSIX定义如下： 1234567891011struct in_addr &#123; in_addr_t s_addr; // 32bit ipv4 address 网络字节序&#125;;struct sockaddr_in &#123; uint8_t sin_len; // 结构体长度 sa_family_t sin_family; // AF_INET in_port_t sin_port; // 16bit TCP/UDP port 网络字节序 struct in_addr sin_addr; // 32bit ipv4 address 网络字节序 char sin_zero[8]; // unused&#125;; sin_len字段不是所有厂家都支持的，且POSIX也不要求有这个成员。我们无需使用它，除非是路由套接字。 由处理来自不同协议族的套接字地址结构的例程，在内核中使用该字段。 POSIX规范只要求结构中的三个字段，sin_family、sin_addr和sin_port。 in_addr_t至少是32位无符号整数，in_port_t至少是16位无符号整数，sa_family_t通常是8位无符号整数，在不支持长度的字段的实现中，他是16位无符号整数。 32位IPv4地址存在两种不同的访问方法，假设serv是一个sockaddr_in数据 通过serv.in_addr，直接访问结构体 通过serv.in_addr.s_addr，直接访问in_addr_t 而IPv4地址是一个结构是因为早期版本将in_addr定义为多种结构的联合体，方便访问每一个字节，以便A、B、C类地址的处理。而现在不需要了。 sin_zero不适用，但是我们总是在使用sockaddr_in前，将整个结构置为0 1.2 通用套接字地址结构通用套接字地址结构定义在&lt;sys/socket.h&gt;头文件中，具体如下： 12345struct sockaddr &#123; uint8_t sa_len; sa_family_t sa_family; // 地址组:内容为AF_XXX char sa_data[14]; // 协议特定的地址 protocol-specific address&#125;; 所有套接字函数都需要将用于特定协议的套接字地址结构强制转换为通用套接字地址结构。 1.3 IPv6套接字地址结构IPv6套接字地址结构在&lt;netinet/in.h&gt;头文件中定义，如下： 1234567891011121314struct in6_addr &#123; uint8_t s6_addr[16]; // 128bit IPv6 address 网络字节序&#125;;#define SIN6_LEN // 编译时的测试需要struct sockaddr_in6 &#123; uint8_t sin6_len; sa_family_t sin6_family; // AF_INET6 in_port_t sin6_port; // 传输层端口 网络字节序 uint32_t sin6_flowinfo; // flow information 未定义 struct in6_addr sin6_addr; // IPv6 address 网络字节序 uint32_t sin6_scopr_id; // set of interface for a scope&#125;; IPv6的地址族是AF_INET6，IPv4是AF_INET 结构中字段的顺序，使得如果sockaddr_in6本身是64位对齐的，那么128位的sin6_addr字段也是64位对齐的。 sin6_flowinfo字段分成两个字段 低序20位是流标(flow label) 高序12位保留 如果地址由范围，sin6_scope_id标识出来。 1.4 新的通用套接字地址结构为了支持IPv6套接字API而定义的新的通用套接字结构地址，克服了原先的通用套接字结构地址的不足，且可以容纳几乎所有套接字，sockaddr_storage定义在&lt;netinet/in.h&gt;中，如： 1234struct sockaddr_storage &#123; uint8_t ss_len; sa_family_t ss_family;&#125;; sockaddr_storage可以满足最苛刻的对齐要求 sockaddr_storage足够大，可以容纳任何套接字地址结构 sockaddr_storage的其他字段对用户是透明的 1.5 套接字地址对比 2. 值-结果参数套接字API以指针形式接受一个套接字地址结构，并且接受该套接字地址的长度。不过地址长度的传递方式取决于套接字的传递方向，从进程到内核，还是从内核到进程。 从进程到内核传递的套接字API有三个：bind、connect和sendto。这些函数的一个参数是套接字指针，另一个是该套接字长度。于是内核知道了需要从进程中复制多少数据进来。 从内核到进程的套接字API是：accept、recvfrom、getsockname和getpeername。这四个函数中的两个参数是套接字指针和该套接字长度的指针。如： 12345struct sockaddr_un cli;socklen_t len;len = sizeof(cli);getpeername(unixfs, (SA*)&amp;cli, &amp;len); 这样是因为，函数调用时，内核写套接字时，可以读取该套接字长度；函数返回试，结构大小是一个结果，告诉对应进程，内核写了多少信息。这种类型阐述称为值-结果(value-result)参数。 3. 字节序转换函数 大端：低序的字节放在高地址 小端：低序的字节放在低地址 判断大小端函数： 123456789101112131415161718192021222324252627#include &lt;unpv13e/unp.h&gt;int main(int argc, char** argv) &#123; union &#123; short s; char c[sizeof(short)]; &#125; un; un.s = 0x0102; printf(&quot;%s: &quot;, CPU_VENDOR_OS); if (sizeof(short) == 2) &#123; if (un.c[0] == 1 &amp;&amp; un.c[1] == 2) &#123; printf(&quot;big endian\\n&quot;); &#125; else if (un.c[0] == 2 &amp;&amp; un.c[1] == 1) &#123; printf(&quot;little endian\\n&quot;); &#125; else &#123; printf(&quot;unknow\\n&quot;); &#125; &#125; else &#123; printf(&quot;sizeof(short) = %d\\n&quot;, sizeof(short)); &#125; exit(0);&#125; 网际协议使用大端来传递多字节整数。 主机字节序和网络字节序的转换由以下函数完成： 12345678#include &lt;netinet/in.h&gt;uint16_t htons(uint16_t host16bitvalue);uint32_t htonl(uint32_t host32bitvalue);uint16_t ntohs(uint16_t net16bitvalue);uint32_t ntoh1(uint32_t net32bitvalue);/* h 代表 host, n 代表 net, s 代表 short, l 代表 long */ 4. 字节操作函数操作字节的函数有两组，一组以b开头，源于4.2BSD，一组以mem开头，源于ANSI C 4.2BSD 1234#include &lt;string.h&gt;void bzero(void* dest, size_t nbytes);void bcopy(const void* src, void* dest, size_t nbytes);void bcmp(const void* ptr1, const void* ptr2, size_t nbytes); ANSI C 1234#include &lt;string.h&gt;void* memset(void* dest, int c, size_t nbytes);void* memcpy(const void* dest, void* stc, size_t nbytes); // 顺序和BSD相反void memcmp(const void* ptr1, const void* ptr2, size_t nbytes); 5. 地址转换函数地址转换函数，使得ASCII字符串与网络字节序的二进制值（套接字地址结构）之间转换。 两组函数的区别在于，第一组只适用于IPv4，第二组IPv4与IPv6都适用。 5.1 inet_aton、inet_addr和inet_ntoa该组函数在点分十进制数串与32位网络字节序二进制值之间转换IPv4地址。 12345678910#include &lt;arpa/inet.h&gt;// 返回值: 如果字符串有效返回1，否则返回0int inet_aton(const char* strptr, struct in_addr* addrptr);// 返回值: 若字符串有效，返回32位二进制网络字节序的IPv4地址，否则为INADDR_NONEin_addr_t inet_addr(const char* strptr);// 返回值: 点分十进制字符串char* inet_ntoa(struct in_addr inaddr) inet_aton，将strptr的字符串转换为32位网络字节序二进制值，成功返回1，否则返回0 inet_addr，将strptr的字符串转换为32位网络字节序二进制值。有一种情况，出错时返回INADDR_NONE，该常量通常是32位均为1的值，所以该函数不能处理255.255.255.255。 该函数已被废弃，应该使用inet_aton取代。 inet_ntoa，将32位网络字节序二进制值转换为对应的点分十进制字符串。该函数返回的字符串驻留在栈内存中。最后，该函数的参数是一个结构体，不是一个指针。 5.2 inet_pton和inet_ntop升级版函数，可以处理IPv4和IPv6，函数名p代表表达(presentation)，n代表数值(numeric)。 地址的表达格式是C字符串，数值格式是套接字地址结构的二进制值 1234567#include &lt;arpa/inet.h&gt;// 返回值: 成功返回1，若输入格式不是有效的，返回0，出错返回-1int inet_pton(int family, const char* strptr, void* addrptr);// 返回值: 成功返回只想结果的指针，出错则为NULLconst char* inet_ntop(int family, const void* addrptr, size_t len); family参数可以是AF_INET和AF_INET6。如果地址族参数不是这两个，两个函数都返回错误，将error置为EAFNOSUPPORT inet_pton，转换strptr指针所指字符串，结果存储到addrptr中。成功返回1，对于指定的family而言，如果字符串格式不对，返回0 inet_ntop，从数值格式转换到表达格式。len参数是目标存储区域的大小，以免缓冲区溢出。 这个len的大小，在&lt;netinet/in.h&gt;中有定义： 1234#include &lt;netinet/in.h&gt;#define INET_ADDRSTRLEN 16; // IPv4 点分十进制#define INET6_ADDRSTRLEN 46; // IPv6 16进制字符串 如果len太小，同拿不了表达格式结果，返回一个空指针，置errno为ENOSPC 5.3 地址转换函数小结 6.sock_ntop与相关函数inet_ntop的问题是：他要求调用者传递一个指向二进制地址的指针，而该地址通常包含在一个套接字地址结构中，所以需要弄清楚该结构的格式和地址族。如: 1234567// IPv4struct sockaddr_in addr;inet_ntop(AF_INET, &amp;addr.sin_addr, str, sizeof(str));// IPv6struct sockaddr_in6 addr6;inet_ntop(AF_INET6, &amp;addr6.sin6_addr, str, sizeof(str)); 此时，代码与协议相关。 为此，我们自己编写一个sock_ntop函数。 1234#include &quot;unp.h&quot;// 返回值: 成功则返回非空指针，出错返回NULLchar* sock_ntop(const struct sockaddr* sockaddr, socklen_t addrlen); 7. readn、writen和readline函数引入readn函数的目的在于： 字节流套接字的read和write函数会引出缓冲区问题。 套接字引入了两个缓冲区，分别为接收缓冲区和发送缓冲区，当我们调用read时，实际上是从接收缓冲区读到内存中。 然而，如果缓冲区快满了，剩余的大小不足n个字节，而我们read了n个字节。只能读取不满n个字节，read函数将返回一个正整数x，代表读取了x个字节。 下次调用read时，会阻塞在此处，直到缓冲区清空，且缓冲区内有数据可读时，被唤醒，进行read操作。 将read封装为readn，确保一定读取了n个字节。具体代码如下： 12345678910111213141516171819202122232425#include &quot;unp.h&quot;ssize_t readn(int fd, void* vptr, size_t n)&#123; size_t nleft; ssize_t nread; charr* ptr; ptr = vptr; nleft = n; while (nleft &gt; 0) &#123; if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123; if (errno = EINTR) &#123; // 后面会详细讨论 nread = 0; &#125; else &#123; return -1; &#125; &#125; else if (nread == 0) &#123; break; // 读取到EOF &#125; nleft -= nread; ptr += nread; &#125; return (n - nleft);&#125; writen引入的目的同readn。 readline函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;unp.h&quot;static int read_cnt;static char *read_ptr;static char read_buf[MAXLINE]; // 调用一次read，将数据读取到自己的缓冲区中// 每次只返回一个字符static ssize_t my_read(int fd, char *ptr)&#123; if(read_cnt &lt;= 0) &#123; again: if( (read_cnt = read(fd, read_buf, sizeof(read_buf)) &lt; 0) &#123; if (errno == EINTR) goto again; return(-1); &#125; else if (read_cnt == 0) &#123; return(0); &#125; read_ptr = read_buf; &#125; read_cnt--; *ptr = *read_ptr++; return (1);&#125; ssize_t readline(int fd, void *vptr, size_t maxlen)&#123; ssize_t n, rc; char c, *ptr; ptr = vptr; for (n = 1; n &lt; maxlen; n++) &#123; if ( (rc = my_read(fd, &amp;c)) == 1) &#123; *ptr++ = c; if (c == &#x27;\\n&#x27;) break; &#125; else if (rc == 0) &#123; *ptr = 0; return(n-1); &#125; else return(-1); &#125; *ptr = 0; return(n);&#125; ssize_t readlinebuf(void** vptrptr)&#123; if (read_cnt) &#123; *vptrptr = read_ptr; &#125; return read_cnt;&#125; my_read每次最多都MAXLINE个字符，但是每次返回一个字符 readlinebuf展示内部缓冲区的状态。 使用静态变量维护信息，结果是这些函数非线程安全","categories":[{"name":"unp","slug":"unp","permalink":"http://example.com/categories/unp/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"apue_2.unix标准及实现","slug":"apue-2-unix标准及实现","date":"2021-01-31T13:54:50.000Z","updated":"2021-01-31T14:29:54.790Z","comments":true,"path":"2021/01/31/apue-2-unix标准及实现/","link":"","permalink":"http://example.com/2021/01/31/apue-2-unix%E6%A0%87%E5%87%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"1. Unix标准与实现Unix标准是不同组织对C程序的库函数设计而提出的规范，主要有以下几种： ISO C IEEE POSIX Single UNIX Specification FIPS Unix实现是对上述标准的提出的接口规范的具体实现，主要有： SVR4 4.4BSD FreeBSD Linux Mac OS X Solaris 2. 限制Unix系统已经定义了很多幻数和常数。为了改善Unix程序的可移植性，有许多方法用于限制这些幻数和常数的定义，以下两种类型的限制是必须的： 编译时限制，如：整型的最大值 运行时限制，如：文件名有多少个字符 编译时限制通常包含在头文件里，程序编译时，包括这些头文件即可。 运行时限制则需要进程调用其他函数来确定。 而限制在某些实现中是固定的，可以从头文件中静态确定。在另外的实现中是动态的，需要运行函数来确定。为了解决这类问题，有三种方法： 编译时限制（头文件） 与文件或目录无关的运行时限制（sysconf函数） 与文件或目录有关的运行时限制（pathconf函数和fpathconf函数） 2.1 ISO C 限制ISO C定义的所有编译时限制全部放在&lt;limits.h&gt;中。定义了一些类型的范围。 &lt;stdio.h&gt;定义了一些 ISO C常量： FOPEN_MAX，可同时打开的标准IO流的最小个数 TMP_MAX，有tmpname函数产生的唯一文件名的最大个数 FILENAME_MAX，避免使用，因为POSIX提供了更好的 2.2 POSIX 限制POSIX的限制和常量主要分为7类： 数值限制：LONG_BIT、SSIZE_MAX和WORD_BIT 最小值： 这些最小值不会随着系统而变化。POSIX.1的实现都需要提供至少这么大的值。 最大值：_POSIX_CLOCKRES_MIN 运行时可以增加的值：CHARCLASS_NAME_MAX COLL_WEIGHTS_MAX LINE_MAX NGROUPS_MAX RE_DUP_MAX 运行时不变值（可能不确定）： 其他不变值：NL_ARGMAX NL_MSGMAX NL_SETMAX NL_TEXTMAX 路径可变值：FILESIZEBITS LINK_MAX MAX_CANON MAX_INPUT NAME_MAX PATH_MAX PIPE_BUF SYMLINK_MAX 2.3 XSI 限制 最小值： 运行时不变值（可能不确定）：IOV_MAX PAGE_SIZE 2.4 函数 sysconf、pathconf和fpathconf1234567#include &lt;unistd.h&gt;long sysconf(int name);long pathconf(const char *pathname, int name);long fpathconf(int fd, int name); 三个函数的name参数都用来标识系统限制，但是种类有所不同 sysconf的name参数以_SC_开头 pathconf和fpathconf的name参数以_PC_开头 三个函数的返回值情况如下 如果name参数不是一个合适的常量，三个函数都返回-1，并将errno置为EINVAL 部分name参数会返回一个变量值(&gt;= 0)，或提示该值是不确定的。不确定通过返回-1标识，但是不改变errno _SC_CLK_TCK的返回值是每秒的时钟滴答数，用于times函数的返回值 对于pathconf的参数pathname和fpathconf的参数fd来说，有很多限制。其中一条不满足，产生未定义的结果 _PC_MAX_CANON和_PC_MAX_INPUT引用的文件必须是终端文件 _PC_LINK_MAX和_PC_TIMESTAMP_RESOLUTION引用的文件可以是文件或目录。如果是目录，返回值仅仅用于目录，不涉及目录内的文件 _PC_FILESIZEBITS和_PC_NAME_MAX引用的文件必须是目录，返回值用于该目录内的文件名 _PC_PATH_MAX引用的文件必须是目录。当引用的是工作目录时，返回为相对路径的最大字节名 _PC_PIPE_BUF引用的文件必须是管道、FIFO或目录。 管道或FIFO，返回值是引用的管道或FIFO的限制 目录，返回值是在该目录中创建任一FIFO的限制值 _PC_SYNLINK_MAX引用的文件必须是目录。返回值用于该目录中符号链接可包含的字符串最大值 2.5 不确定的运行时限制运行时限制一般是不确定的，在使用时需要动态获取这些信息，通常使用上述三个函数之一来获取。 3. 功能测试宏头文件定义了很多符号，大多数实现也添加了自己的符号。但是如果只希望使用POSIX的符号，且不与任何实现的定义起冲突，需要定义常量_POSIX_C_SOURCE。 该常量称为功能测试宏，所有的功能测试宏都以下划线开头。使用时，格式如下： 123cc -D_POSIX_C_SOURCE&#x3D;200809L file.c&#x2F;&#x2F; 也可在头文件第一行加上#define _POSIX_C_SOURCE 200809L 4. 基本系统数据类型&lt;sys/types.h&gt;中定义了一些基本系统数据类型，绝大多数以_t结尾。","categories":[{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"}]},{"title":"apue_1.unix基础知识","slug":"apue-1-unix基础知识","date":"2021-01-31T13:51:04.000Z","updated":"2021-01-31T14:09:28.221Z","comments":true,"path":"2021/01/31/apue-1-unix基础知识/","link":"","permalink":"http://example.com/2021/01/31/apue-1-unix%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"1. Unix体系结构内核：控制硬件，提供程序运行环境。 系统调用：内核的接口，公用函数库建立在系统调用之上 shell：特殊的应用程序，为其他应用程序提供接口 2. 登录2.1 登录名登录名信息在口令文件中（通常在/etc/passwd文件）查看。 登录项又冒号隔开的7个字段组成，分别为： 登录名 加密口令 数字用户ID 数字组ID 注释字段 起始目录 shell程序，系统启动后运行的shell的路径 2.2 shellshell即命令行解释器，读取输入，执行命令，可以从终端或者文件中获取输入。 根据用户项中的信息，启动对应的shell。 3. 文件和目录3.1 文件名文件名中不能出现左斜杠/和空格。左斜杠是路径名中的一部分，空格是用来终止路径名。 推荐使用字母、数字、句点、短横线和下划线。 在创建新目录时，同时创建了两个文件名：点.和点点.. .点：指向当前目录 ..点点：指向父目录 3.2 路径名以斜线开头的为绝对路径，否则为相对路径。 3.3 工作目录每个进程都有个工作目录，所有相对路径前都会加上工作目录，进程可以使用chdir函数更改工作目录 3.4 起始目录登陆后，工作目录设置为起始目录，起始目录在登录项中可以取地 4. 输入和输出4.1 文件描述符文件描述符通常是一个小的非负整数，内核用以标识特定进程访问的文件。 4.2 标准输入、标准输出、标准错误运行一个程序时，shell为其打开三个文件描述符，即标准输入、标准输出和标准错误。一般，这三个描述符都链接到终端。 可以通过重定向来使得三个描述符定向到某个文件 4.3 不带缓冲的IO函数open、read、write、lseek和close提供了不到缓冲的IO 4.4 标准IO标准IO为不带缓冲的IO提供了一个带缓冲的接口。简化了对输入行的处理 5. 程序和进程5.1 程序程序是存储在磁盘某个目录上的可执行文件，内核使用exec函数，将程序读入内存，执行程序。 5.2 进程程序的执行实例被称为进程，每个进程都有唯一的标识符，称为进程ID，总是一个非负整数。 5.3 进程控制主要有三个函数进行进程控制：fork、exec和waitpid 5.4 线程和线程ID 通常，一个进程只有一个线程——某一时刻执行的一组机器指令。但是可以通过额外设置线程来解决问题。 一个进程内的所有线程可以共享同一地址空间、文件描述符、栈以及进程属性。 线程也有线程ID，但是仅仅是对于该进程，对于另外的进程，该进程的线程ID没有意义。 6. 出错处理Unix系统函数出错时，通常返回一个负值，且整型变量errno设置为具有特定信息的值。 &lt;errno.h&gt;中定义了errno及其常值。这些常值都以E开头。 POSIX和ISO C都将errno设置为一个可修改的整型左值。在多线程中，每个线程都有自己的局部errno，避免干扰， 在linux中，errno定义如下： 12extern int *__errno_location(void);#define errno (*__errno_location()); errno的使用注意以下两点 如果没有出错，errno的值不会被清除。因此只在出错时检测errno的值 任何函数都不会将errno的值设为0，且所有errno的常值也不为0 C标准定义了两个函数用于打印出错信息 #include &lt;string.h&gt; char *strerror(int errnum); 1234567 &#96;strerror&#96;将&#96;errno&#96;值映射为一个字符串，并返回字符串指针- &#96;&#96;&#96;c #include &lt;stdio.h&gt; void perror(const char *msg); `perror`函数基于`errno`的当前值，在标准错误输出一条出错信息，然后返回。 首先输出`msg`指向的信息，一个冒号一个空格，接着是`errno`对应的出错信息，最后是换行符。 6.1 出错恢复错误有两类：致命性的和非致命性的。 致命性错误无法恢复，输出一条出错信息后就退出 资源短缺相关的错误通常是非致命性的，常见的恢复方法有，隔段时间后重新访问 7. 用户表示7.1 用户ID用户ID是一个数值，唯一的标识每一个用户，且用户不可更改其用户ID。 7.2 组ID组ID是由系统管理员在用户登陆时分配的，多个用户可以有相同的组ID。组ID可以将用户划分为各个部门、项目中，可以设置权限，使得这一组的用户有权限访问文件。 组文件将组名映射到数值，文件路径通常为/etc/group。 7.3 附属组ID除了组ID为，用户还可以属于另外一些组。 8. 信号信号用于通知进程发生的情况，进程的信号处理的方式有三种： 忽略。但是有些异常，如地址错误等，结果不确定，所以不推荐忽略信号 按照默认方法处理。如除0，系统默认终止进程 提供函数，信号发生时调用。 键盘产生信号的方法有两种： 中断键，中断当前运行进程，ctrl+c 退出键，终端当前运行进程，ctrl+/ 9. 时间值有两种不同的时间值 日历时间，从1970年1月1日00:00:00到现在经过的秒数。 time_t保存这种时间值 进程时间，度量进程使用CPU资源的时间。clock_t保存这种时间值 在度量一个进程的执行时间时，系统为进程维护了3个时间 时钟时间，又称为墙上时钟时间，是进程运行的时间总量，值与系统中同时运行的进程数有关。 用户CPU时间，执行用户指令的时间。 系统CPU时间，进程执行内核程序所经过的时间。 10. 系统调用和库函数Unix中的每个系统调用在标准C库中设置了一个具有相同名字的函数。用户使用标准C库中的函数，函数使用系统要求的技术调用相应的内核服务。 系统调用和库函数的异同： 系统调用和库函数都是以C函数的形式给出 系统调用通常不可以被替换，库函数是可以替换的 如，可以使用malloc实现内存分配，但并不是唯一的方式，Unix系统中实现内存分配的系统调用为sbrk，用户也可以自定义malloc函数，不去调用库函数。","categories":[{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"}]},{"title":"创建型模式-原型模式","slug":"创建型模式-原型模式","date":"2020-11-30T14:19:34.000Z","updated":"2021-01-30T02:02:43.590Z","comments":true,"path":"2020/11/30/创建型模式-原型模式/","link":"","permalink":"http://example.com/2020/11/30/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"5、原型模式5.1 原型模式概述**原型模式(Prototype Pattern)**：使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。原型模式是一种对象创建型模式。 工作原理：将一个原型对象传给那个要创建的对象，这个要创建的对象通过请求原型对象克隆自己来实现创建过程 原型模式结构图中包含3个角色： **Prototype(抽象原型类)**：它是声明克隆方法的接口，是所有具体原型类的父类，可以抽象类、接口，还可以是具体实现类。 **ConcretePrototype(具体原型类)**：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 **Client(客户类)**：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。 下面将介绍两种在Java语言中常用的克隆实现方法： 通用实现法 通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传人新创建的对象中，保证它们的成员变量相同。示意代码如下： 12345678910111213141516171819202122232425262728293031#ifndef PROTOTYPE_H#define PROTOTYPE_Hclass Prototype &#123;public: virtual ~Prototype() &#123;&#125; virtual Prototype* Clone() = 0;&#125;;#endif // PROTOTYPE_H#ifndef CONCRETE_PROTOTYPE_H#define CONCRETE_PROTOTYPE_H#include &quot;prototype.h&quot;class ConcretePrototype : public Prototype &#123;public: ConcretePrototype() &#123;&#125; ConcretePrototype(const ConcretePrototype* other) &#123;&#125; virtual ~ConcretePrototype() &#123;&#125; virtual Prototype* Clone() override &#123; return new ConcretePrototype(*this); &#125;&#125;;#endif // CONCRETE_PROTOTYPE_H 在客户类中，只需要创建一个ConcretePrototype对象作为原型对象，然后调用其clone()方法即可得到对应的克隆对象，代码如下： 12345678910#include &lt;cassert&gt;#include &quot;concrete_prototype.h&quot;int main() &#123; Prototype* objl = new ConcretePrototype(); Prototype* obj2 = objl-&gt;Clone(); assert(objl != obj2);&#125; 这种方法可作为原型模式的通用实现，它与编程语言特性无关，任何面向对象语言都可以使用这种形式来实现对原型的克隆。 在原型模式复制时，需要注意浅复制和深复制。 5.2 原型管理器的引入和实现**原型管理器(Prototype Manager)**是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以便扩展。 具体实例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//抽象公文接口，也可定义为抽象类，提供clone()方法的实现,将业务方法声明为抽象方法#ifndef OFFICIAL_DOCUMENT_H#define OFFICIAL_DOCUMENT_Hclass OfficialDocument &#123;public: virtual ~OfficialDocument() &#123;&#125; virtual OfficialDocument* Clone() = 0; virtual void Display() = 0;&#125;;#endif // OFFICIAL_DOCUMENT_H//可行性分析报告(Feasibility Analysis Report)类#ifndef FAR_H#define FAR_H#include &lt;iostream&gt;#include &quot;official_document.h&quot;class Far : public OfficialDocument &#123;public: Far() &#123;&#125; Far(const Far&amp;) &#123;&#125; virtual ~Far() &#123;&#125; virtual OfficialDocument* Clone() override &#123; return new Far(*this); &#125; virtual void Display() override &#123; std::cout &lt;&lt; &quot;&lt;可行性分析报吿&gt;&quot; &lt;&lt; std::endl; &#125;&#125;;#endif // FAR_H//软件需求规格说明书(Software Requirements Specification)类#ifndef SAS_H#define SAS_H#include &lt;iostream&gt;#include &quot;official_document.h&quot;class Sas : public OfficialDocument &#123;public: Sas() &#123;&#125; Sas(const Sas&amp;) &#123;&#125; virtual ~Sas() &#123;&#125; virtual OfficialDocument* Clone() override &#123; return new Sas(*this); &#125; virtual void Display() override &#123; std::cout &lt;&lt; &quot;&lt;软件需求规格说明书&gt;&quot; &lt;&lt; std::endl; &#125;&#125;;#endif // SAS_H//原型管理器(使用饿汉式单例实现)#ifndef PROTOTYPE_MANAGER_H#define PROTOTYPE_MANAGER_H#include &lt;string&gt;#include &lt;map&gt;#include &quot;far.h&quot;#include &quot;sas.h&quot;class PrototypeManager &#123;public: PrototypeManager() &#123; m_ht[&quot;far&quot;] = new Far(); m_ht[&quot;sas&quot;] = new Sas(); &#125; PrototypeManager(const PrototypeManager&amp;) = delete; PrototypeManager&amp; operator=(const PrototypeManager&amp;) = delete; ~PrototypeManager() &#123;&#125; //增加新的公文对象 void AddOfficialDocument(std::string key, const OfficialDocument* doc) &#123; m_ht[key] = const_cast&lt;OfficialDocument*&gt;(doc)-&gt;Clone(); &#125; //通过浅克隆获取新的公文对象 OfficialDocument* GetOfficialDocument(std::string key) &#123; return m_ht[key]-&gt;Clone(); &#125; static PrototypeManager* GetPrototypeManager() &#123; return &amp;ms_pm; &#125;private: std::map&lt;std::string, OfficialDocument*&gt; m_ht; static PrototypeManager ms_pm;&#125;;PrototypeManager PrototypeManager::ms_pm;#endif // PROTOTYPE_MANAGER_H// 客户端代码如下#include &lt;cassert&gt;#include &quot;prototype_manager.h&quot;int main() &#123; PrototypeManager* pm = PrototypeManager::GetPrototypeManager(); OfficialDocument* doc1, *doc2, *doc3, *doc4; doc1 = pm-&gt;GetOfficialDocument(&quot;far&quot;); doc1-&gt;Display(); doc2 = pm-&gt;GetOfficialDocument(&quot;far&quot;); doc2-&gt;Display(); assert(doc1 != doc2); doc3 = pm-&gt;GetOfficialDocument(&quot;sas&quot;); doc3-&gt;Display(); doc4 = pm-&gt;GetOfficialDocument(&quot;sas&quot;); doc4-&gt;Display(); assert(doc3 != doc4);&#125; 5.3 总结原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中应用较为广泛，很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的典型应用。 5.3.1 优点 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 扩展性较好。由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少具体原型类对原有系统都没有任何影响。 原型模式提供了简化的创建结构。工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。 可以使用深克隆的方式保存对象的状态。使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，例如恢复到某一历史状态，可辅助实现撤销操作。 5.3.2 缺点 需要为每个类配备一个克隆方法，而且该克隆方法位于类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则。 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 5.3.3 适用场景 创建新对象成本较大（例如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式（来实现。 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式-抽象工厂模式","slug":"创建型模式-抽象工厂模式","date":"2020-11-21T09:28:52.000Z","updated":"2021-01-30T02:02:22.210Z","comments":true,"path":"2020/11/21/创建型模式-抽象工厂模式/","link":"","permalink":"http://example.com/2020/11/21/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"4、抽象工厂模式4.1 产品等级结构与产品族产品等级结构 产品等级结构即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 示意图如下 同一形状的物品构成了一个产品等级结构，而同一种颜色的物品因为其厂家相同，由同一个工厂生成，所以是一个产品族。 4.2 抽象工厂模式概述抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比， 抽象工厂模式中的具体工厂不只是创建一种产品， 它负责创建一族产品。抽象工厂模式定义如下： **抽象工厂模式(Abstract Factory Pattern)**：提供一个创建一系列相关或相互依赖的对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。 抽象工厂模式结构图中包含以下4个角色： **AbstractFactory(抽象工厂)**：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 **ConcreteFactory(具体工厂)**：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 **AbstractProduct(抽象产品)**：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 **ConcreteProduct(具体产品)**：它定义具体工厂生产的具体产品对象，实现在抽象产品接口中声明的业务方法。 抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下： 123456789class Truck;class Car;class AbstractFactory &#123;public: virtual Truck* GetTruck() = 0; virtual Car* GetCar() = 0;&#125;; 具体工厂实现了抽象工厂， 每一个具体的工厂方法可以返回一个特定的产品对象，一个具体工厂所创建的产品对象构成了一个产品族。 1234567891011121314151617181920212223242526272829303132333435class BmwFactory : public AbstractFactory &#123;public: virtual Truck* GetTruck() override &#123; return new BmwTruck; &#125; virtual Car* GetCar() override &#123; return new BmwCar; &#125;&#125;;class BenzFactory : public AbstractFactory &#123;public: virtual Truck* GetTruck() override &#123; return new BenzTruck; &#125; virtual Car* GetCar() override &#123; return new BenzCar; &#125;&#125;;class BenzTruck : public Truck &#123;public: virtual void SameMethod() override &#123; std::cout &lt;&lt; &quot;I am benz truck\\n&quot;; &#125;&#125;;class BenzCar : public Car &#123;public: virtual void SameMethod() override &#123; std::cout &lt;&lt; &quot;I am benz car\\n&quot;; &#125;&#125;; 4.3 开闭原则的倾斜性抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为开闭原则的倾斜性。 如，需要在按钮中增加一个radioButton，则需要在抽象工厂和具体工厂中逐一修改代码，违反开闭原则。 增加产品族。对于增加新的产品族，抽象工厂模式很好地支持了开闭原则，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。 增加产品等级结构。对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了开闭原则。 正因为抽象工厂模式存在开闭原则的倾斜性，因此要求设计人员在设计之初就能够全面考虑，产品等级结构不会再日后的维护总发生变化。 4.4 总结4.4.1 优点 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了在抽象工厂中声明的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。因为只用了一个工厂创建。 增加新的产品族很方便，无须修改已有系统，符合开闭原则。 4.4.2 缺点增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则。 4.4.3 适用场景 系统中有多于一个的产品族，而每次只使用其中某一产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束。例如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式-工厂模式","slug":"创建型模式-工厂模式","date":"2020-11-21T09:06:21.000Z","updated":"2021-01-30T02:02:34.151Z","comments":true,"path":"2020/11/21/创建型模式-工厂模式/","link":"","permalink":"http://example.com/2020/11/21/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"3、工厂模式3.1 工厂模式概述工厂方法模式(Factory Method Pattern)**：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual ConstructorPattern)或多态工厂模式(Polymorphic Factory Pattern)**。工厂方法模式是一种类创建型模式。 工厂模式包含四个角色 **Product(抽象产品)**：定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的父类。 **ConcreteProduct(具体产品)**：它实现了抽象产品接口，具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 Factory(抽象工厂)**：在抽象工厂类中，声明了工厂方法(Factory Method)**，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 **ConcreteFactory(具体工厂)**：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 具体实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//日志记录器接口：抽象产品class Logger &#123;public: virtual void Log() = 0;&#125;;//数据库日志记录器：具体产品class DatabaseLogger : public Logger &#123;public: virtual void Log() override &#123; std::cout &lt;&lt; &quot;database log\\n&quot;; &#125;&#125;;//文件日志记录器：具体产品class FileLogger : public Logger &#123;public: virtual void Log() override &#123; std::cout &lt;&lt; &quot;file log\\n&quot;; &#125;&#125;;//日志记录器工厂接口：抽象工厂// 使用前置声明减少头文件依赖class Logger;class Factory &#123;public: virtual Logger* GetLogger() = 0;&#125;;//数据库日志记录器工厂类：具体工厂class DatabaseLoggerFactory : public Factory &#123;public: virtual Logger* GetLogger() override &#123; return new DatabaseLogger; &#125;&#125;;//文件日志记录器工厂类：具体工厂class FileLoggerFactory : public Factory &#123;public: virtual Logger* GetLogger() override &#123; return new FileLogger; &#125;&#125;;// 客户端代码使用如下：int main(int argc, char* argv[]) &#123; Factory* factory; Logger* log; factory = new DatabaseLoggerFactory; log = factory-&gt;GetLogger(); log-&gt;Log();&#125; 3.2 工厂方法的隐藏可在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。 12345678910111213141516class Factory &#123;public: virtual Logger* GetLogger() = 0; virtual void Log() &#123; Logger* logger = this-&gt;GetLogger(); logger-&gt;Log(); delete logger; &#125;&#125;;int main(int argc, char* argv[]) &#123; Factory* factory; factory = new FileLoggerFactory; factory-&gt;Log();&#125; 将业务方法移入工厂类，可以直接使用工厂对象来调用产品对象的业务方法，客户端无须直接使用工厂方法。 3.3 总结3.3.1 优点 在工厂模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加人新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。可扩展性好，完全符合开闭原则。 3.3.2 缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，类的个数将成对增加，增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。 3.3.3 适用场景 客户端不知道其所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式-简单工厂模式","slug":"创建型模式-简单工厂模式","date":"2020-11-19T10:53:52.000Z","updated":"2021-01-30T02:02:38.602Z","comments":true,"path":"2020/11/19/创建型模式-简单工厂模式/","link":"","permalink":"http://example.com/2020/11/19/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"2、简单工厂模式2.1 简单工厂模式概述简单工厂模式并不属于23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下： 首先将需要创建的各种不同对象的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传人相应的参数即可得到一个产品对象。 简单工厂模式(Simple Factory Pattern)**：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法， 因此简单工厂模式又被称为静态工厂方法(StaticFactory Method)**模式，它属于类创建型模式。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 在简单工厂模式结构图中包含以下3个角色。 Factory(工厂角色)：即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。 Product(抽象产品角色)：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引人将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。 ConcreteProduct(具体产品角色)：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#ifndef PRODUCT_H#define PRODUCT_Hclass Product &#123;public: // 所有类公共的方法 void SameMethod() &#123;&#125; // 所有子类的抽象方法 virtual void DiffMethod() = 0;&#125;;#endif // PRODUCT_H#ifndef CONCRETE_PRODUCT_H#define CONCRETE_PRODUCT_H#include &lt;iostream&gt;#include &quot;product.h&quot;class ConcreteProduct : public Product &#123;public: ConcreteProduct() &#123;&#125; ~ConcreteProduct() &#123;&#125; virtual void DiffMethod() override &#123; std::cout &lt;&lt; &quot;I am working!\\n&quot;; &#125;&#125;;#endif // CONCRETE_PRODUCT_H#ifndef FACTORY_H#define FACTORY_H#include &quot;product.h&quot;#include &quot;concerate_product.h&quot;class Factory &#123;public: // 产品用enum声明 static Product* GetProduct(int product_type) &#123; switch (product_type) &#123; case 0: return new ConcreteProduct; break; default: return nullptr; break; &#125; &#125;&#125;;#endif // FACTORY_H#include &quot;product.h&quot;#include &quot;concerate_product.h&quot;#include &quot;factory.h&quot;int main(int argc, char* argv[]) &#123; Product* product = Factory::GetProduct(0); product-&gt;DiffMethod(); delete product;&#125; 2.2 简单工厂模式的简化可以将抽象产品类和工厂类合并，将静态工厂方法放到抽象产品类中，如图： 2.3 总结2.3.1 优点 工厂类可包含判断逻辑，决定创建哪个产品类；使用者直接使用对象，无需创建。简单工厂模式实现了对象创建和使用的分离。 使用者无须知道产品类的类名，简单工厂模式可以在一定程度减少使用者的记忆量。 配置文件(java)，可以在不修改代码的情况下更换和增加新的产品类，提高了系统的灵活性。 2.3.2 缺点 工厂类集中了所有产品的创建逻辑，职责重，一旦不能正常工作，整个系统都要受到影响。 简单工厂模式会增加系统中类的个数(引入新的工厂类)，增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品需要修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 2.3.3 适用场景 工厂类负责创建的对象比较少，由于创建的对象较少，工厂方法中的业务逻辑不会复杂。 使用者只知道传入工厂类的参数，对于如何创建对象并不关心。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式--单例模式","slug":"创建型模式-单例模式","date":"2020-11-17T07:16:46.000Z","updated":"2021-01-30T02:02:28.824Z","comments":true,"path":"2020/11/17/创建型模式-单例模式/","link":"","permalink":"http://example.com/2020/11/17/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"1、单例模式1.1 单例模式概述**单例模式(Singleton Pattern)**：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。 单例模式有3个要点： 某个类只能有一个实例 它必须自行创建这个实例 它必须自行向整个系统提供这个实例 单例模式UML图如下： 在单例类的内部只生成一个实例， 同时它提供一个静态的GetInstance()方法，让客户可以访问它的唯一实例；为了防止在外部对单例类实例化，它的构造函数可见性为private；在单例类内部定义了一个Singleton类型的静态对象，作为供外部共享访问的唯一实例。 1.2 可能存在的问题当第一次调用getInstance()方法创建对象，instance对象为null值，因此系统将执行代码instance = newInstance()，在此过程中，如果对象的创建需要做很大量初始化工作，则需要一段时间创建对象。而在此时，如果在此调用getInstance()(多线程)，则会多次创建对象，引发错误。 1.3 饿汉式单例和懒汉式单例1.3.1 饿汉式单例","text":"1、单例模式1.1 单例模式概述**单例模式(Singleton Pattern)**：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。 单例模式有3个要点： 某个类只能有一个实例 它必须自行创建这个实例 它必须自行向整个系统提供这个实例 单例模式UML图如下： 在单例类的内部只生成一个实例， 同时它提供一个静态的GetInstance()方法，让客户可以访问它的唯一实例；为了防止在外部对单例类实例化，它的构造函数可见性为private；在单例类内部定义了一个Singleton类型的静态对象，作为供外部共享访问的唯一实例。 1.2 可能存在的问题当第一次调用getInstance()方法创建对象，instance对象为null值，因此系统将执行代码instance = newInstance()，在此过程中，如果对象的创建需要做很大量初始化工作，则需要一段时间创建对象。而在此时，如果在此调用getInstance()(多线程)，则会多次创建对象，引发错误。 1.3 饿汉式单例和懒汉式单例1.3.1 饿汉式单例 1234567891011121314151617181920212223242526272829303132333435363738394041424344// EagerSingleten.h/******************************************************* * author : Cytify * date : 20201117 22:33 * version : 1.0 * desc : 饿汉单例*******************************************************/#ifndef eager_singleton_h_#define eager_singletn_h_class EagerSingleton &#123;public: static EagerSingleton* GetInstance() &#123; return ms_instance; &#125; void Delete(); private: EagerSingleton(); ~EagerSingleton(); EagerSingleton(const EagerSingleton&amp; signal); const EagerSingleton&amp; operator=(const EagerSingleton&amp; signal); static EagerSingleton* ms_instance;&#125;;#endif// EagerSingleten.cpp#include &quot;EagerSingleton.h&quot;// 初始化ms_instanceEagerSingleton* EagerSingleton::ms_instance = new EagerSingleton();void EagerSingleton::Delete() &#123; if (ms_instance) &#123; delete ms_instance; ms_instance = nullptr; &#125;&#125; 当类被加载时，静态变量ms_instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。 1.3.2 懒汉式单例 懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为**延迟加载(Lazy Load)**技术，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/******************************************************* * author : Cytify * date : 20201119 18:38 * version : 1.0 * file : lazy_singleton * desc : 加锁的懒汉单例*******************************************************/#ifndef LAZY_SINGLETON_H#define LAZY_SINGLETON_H#include &lt;mutex&gt;class LazySingleton &#123;public: static LazySingleton* GetInstance(); static void DeleteInstance();private: LazySingleton(); ~LazySingleton(); LazySingleton(const LazySingleton&amp;); const LazySingleton&amp; operator=(const LazySingleton&amp;); static LazySingleton* ms_instance; static std::mutex ms_mutex;&#125;;#endif // LAZY_SINGLETON_H/******************************************************* * author : Cytify * date : 20201119 18:39 * version : 1.0 * file : lazy_singleton.cpp * desc : 实现lazy_singleton.h*******************************************************/#include &quot;lazy_singleton.h&quot;LazySingleton* LazySingleton::ms_instance = nullptr;std::mutex LazySingleton::ms_mutex;LazySingleton* LazySingleton::GetInstance() &#123; // 使用双重检查锁的机制，只在判断指针为空的情况下才加锁 // 在多线程的情况下，这样可以减少开销 if (ms_instance = nullptr) &#123; // 使用unique_lock，类似于使用智能指针 std::unique_lock&lt;std::mutex&gt; lock(ms_mutex); if (ms_instance == nullptr) &#123; ms_instance = new (std::nothrow)LazySingleton(); &#125; &#125; return ms_instance;&#125;void LazySingleton::DeleteInstance() &#123; std::unique_lock&lt;std::mutex&gt; lock(ms_mutex); // 加锁 if (ms_instance) &#123; delete ms_instance; ms_instance = nullptr; &#125;&#125; 另一种实现方式 12345678910111213141516171819class LazySingleton &#123; private volatile static LazySingleton instance = null; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; //第一重判断 if (instance == null) &#123; //锁定代码块 synchronized (LazySingleton.class) &#123; //第二重判断 if (instance == null) &#123; instance = new LazySingleton(); //创建单例实例 &#125; &#125; &#125; return instance; &#125;&#125; 1.3.3 饿汉式单例类与懒汉式单例类比较饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。 但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。 懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理多线程，特别是当单例类实例化时涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的几率变得较大， 需要通过双重检查锁定等机制进行控制， 这将导致系统性能受到一定影响。 1.4 较好的单例实现方法123456789101112131415161718192021222324252627282930313233343536373839/******************************************************* * author : Cytify * date : 20201119 18:38 * version : 1.0 * file : lazy_singleton * desc : 局部静态变量的懒汉单例*******************************************************/#ifndef LAZY_SINGLETON_H#define LAZY_SINGLETON_Hclass LazySingleton &#123;public: static LazySingleton* GetInstance();private: LazySingleton(); ~LazySingleton(); LazySingleton(const LazySingleton&amp;); const LazySingleton&amp; operator=(const LazySingleton&amp;);&#125;;#endif // LAZY_SINGLETON_H/******************************************************* * author : Cytify * date : 20201119 18:39 * version : 1.0 * file : lazy_singleton.cpp * desc : 实现lazy_singleton.h*******************************************************/#include &quot;lazy_singleton.h&quot;LazySingleton* LazySingleton::GetInstance() &#123; static LazySingleton lazy_singleton; return &amp;lazy_singleton;&#125; 这种方法代码少，无加锁，且能保证线程安全。 1.5 总结1.5.1 优点 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。 由于在只存在一个对象，可节约系统资源，对于一些需要频繁创建和销毁的对象，可以提高系统的性能。 可以获得多个对象。进行扩展，获得指定个数的实例对象，既节省系统资源，又解决了由于单例对象共享过多有损性能的问题。 1.5.2 缺点 单例模式没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了单一职责原则。因为单例类既提供了业务方法， 又提供了创建对象的方法(工厂方法) ， 将对象的创建和对象本身的功能耦合在一起。 自动垃圾回收技术可能会自动销毁并回收资源，这将导致共享的单例对象状态的丢失。 1.5.3 适用场景 系统只需要一个实例对象。如，系统要求提供一个唯一的序列号生成器或资源管理器，或资源消耗太大而只允许创建一个对象。 类的单个实例只在某一个地方被使用，除此之外，不会再其他地方调用。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"对象模型-4.函数","slug":"cpp-对象模型-第四章-函数","date":"2020-11-17T06:42:00.000Z","updated":"2021-01-30T02:01:15.309Z","comments":true,"path":"2020/11/17/cpp-对象模型-第四章-函数/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%87%BD%E6%95%B0/","excerpt":"1. 成员函数的调用1.1 非静态成员函数(Nonstaic Member Function)成员函数会经过编译器转换为非成员函数： 改变函数的声明，新增一个额外参数，用于访问类内的数据和函数。 123456class Point3d;// non-constPoint3d Point3d::Magnitude(); -&gt; Point3d Point3d::Magnitude(Point3d *const this);// constPoint3d Point3d::Magnitude() const; -&gt; Point3d Point3d::Magnitude(const Point3d *const this); 对成员的访问操作变为this指针的访问 转换函数名称——mangling方法(第三章数据部分提到，用于转换static变量名) 转换后，函数的调用也需要被转换 1234567class Point3d;Point3d obj;Point3d *ptr = new Point3d;// 假设Magnitude名称转换为Magnitude_7Point3dFvobj.Magnitude(); -&gt; Magnitude_7Point3dFv(&amp;obj);ptr-&gt;Magnitude(); -&gt; Magnitude_7Point3dFv(ptr); 假设有如下代码： 1234567891011Point3d Point3d::Normalize() const &#123; register float msg = Magnitude(); return Point3d( x_/msg, y_/msg, z_/msg);&#125;// 经过转换，以及NRV优化void Normalize_7Point3dFv(register const Point3d* const this, Point3d&amp; _result) &#123; register float msg = this-&gt;Magnitude(); _result.Point3d::Point3d(this-&gt;x_/msg, this-&gt;y_/msg, this-&gt;z_/msg); return;&#125;","text":"1. 成员函数的调用1.1 非静态成员函数(Nonstaic Member Function)成员函数会经过编译器转换为非成员函数： 改变函数的声明，新增一个额外参数，用于访问类内的数据和函数。 123456class Point3d;// non-constPoint3d Point3d::Magnitude(); -&gt; Point3d Point3d::Magnitude(Point3d *const this);// constPoint3d Point3d::Magnitude() const; -&gt; Point3d Point3d::Magnitude(const Point3d *const this); 对成员的访问操作变为this指针的访问 转换函数名称——mangling方法(第三章数据部分提到，用于转换static变量名) 转换后，函数的调用也需要被转换 1234567class Point3d;Point3d obj;Point3d *ptr = new Point3d;// 假设Magnitude名称转换为Magnitude_7Point3dFvobj.Magnitude(); -&gt; Magnitude_7Point3dFv(&amp;obj);ptr-&gt;Magnitude(); -&gt; Magnitude_7Point3dFv(ptr); 假设有如下代码： 1234567891011Point3d Point3d::Normalize() const &#123; register float msg = Magnitude(); return Point3d( x_/msg, y_/msg, z_/msg);&#125;// 经过转换，以及NRV优化void Normalize_7Point3dFv(register const Point3d* const this, Point3d&amp; _result) &#123; register float msg = this-&gt;Magnitude(); _result.Point3d::Point3d(this-&gt;x_/msg, this-&gt;y_/msg, this-&gt;z_/msg); return;&#125; 1.2 函数名称转换(Name Mangling)不同编译器的做法不同。以下仅介绍cfront的做法。 类的数据成员通常会加上类名，会变成独特的名称。可以有效防止子类和父类拥有相同变量名。 123456789class Bar &#123; public: int val_; -&gt; val_3Bar&#125;;class Foo : public Bar &#123;public: int val_; -&gt; val_3Foo&#125; 函数由于可以重载。会在函数名后加上类名，再加上参数列表中的类型。 12345class Point &#123;public: void x(float x); -&gt; void x_5PointFf(float x); void x(float x, float y); -&gt; void x_5PointFff(float x, float y);&#125; 名称转换的目的是为了使不正确的调用操作在链接期就被检测出来。比如重载函数调用不正确等。 1.3 虚成员函数(Virtual Member Function)虚函数通过虚函数指针指向的虚函数表调用。 虚函数表，第一格是RTTI有关数据，之后的是虚函数地址。有些编译器将虚函数表-1位置设置为虚基类地址/偏移。 虚函数的转换 1ptr-&gt;Normalize(); -&gt; (*ptr-&gt;vptr[1])(ptr); vptr为虚函数指针，在单继承体系中只有一个，但是在多继承体系中会有多个，因此有可能需要名称转换。 vptr[1]是函数的地址，即Noemalize()函数地址。 第二个ptr为this指针。 12345Point3d Point3d::Normalize() const &#123; register float msg = Magnitude(); return Point3d( x_/msg, y_/msg, z_/msg);&#125;// 假设Magnitude和Noemalize都是虚函数 优化tips 因为Magnitude()**是确定的，所以直接显式调用**会比虚指针转换调用更好。 即，register float msg = Point3d::Magnitude(); 显式调用虚函数，调用过程与非静态成员函数相同 Magnitude()编写为内联函数，更有效率 1.4 静态成员函数(Static Member Function)静态函数的调用与非静态成员函数类似，但有区别，**不会增加额外参数(this指针)**。 12obj.Noemalize(); -&gt; Normalize_7Point3dSFv();ptr-&gt;Normalize(); -&gt; Normalize_7Point3dSFv(); 静态成员函数也需要被转化，其中SFv表示是静态成员函数 静态成员函数不需要通过类的实例调用 1234foo.Obj() &gt; 1;// 转换为(void) foo(); // NRVPoint3d::Obj() &gt; 1; 这样会有额外成本 静态成员函数的地址是非成员函数的地址 &amp;Point3d::Obj(); == unsigned int (*)(); != unsigned int (Point3d::*)(); 静态成员函数可以便于成为回调函数(callback)**，可用于线程函数(pthread)** 2. 虚函数(Virtual Member Function)2.1 单一继承为了支持多态，需要对类提供额外的执行期信息。 每个对象设置一个虚指针，指向虚函数表 虚函数表中设置类的类型信息（支持RTTI），以及虚函数地址 对于虚函数的继承来说，会有以下操作： 父类的虚函数会被子类继承 子类的虚函数会重载父类的虚函数，即在虚函数表中覆盖父类虚函数 子类的新虚函数会加入到虚函数表中，新的虚函数会被放到虚函数表末尾 存在一个pure_virtual_called()函数，它可以是纯虚函数，也可以当作执行器异常处理函数 如： 123456789101112131415161718192021222324252627class Point &#123;public: virtual ~Point(); virtual POint&amp; Mult(float) = 0; virtual float y() const &#123; return 0; &#125; virtual float z() const &#123; return 0; &#125;private: float x_;&#125;class Point2d : public Point &#123;public: virtual ~Point2d(); virtual POint2d&amp; Mult(float); virtual float y() const &#123; return y_; &#125;private: float y_;&#125;class Point3d : public Point2d &#123;public: virtual ~Point3d(); virtual POint3d&amp; Mult(float) = 0; virtual float z() const &#123; return z_; &#125;private: float z_;&#125; 因此，ptr-&gt;z();会被转换为(ptr-&gt;_vptr[4])(ptr) 这一转换在编译器即可完成，但在执行期才能知道调用的是哪一个类的z() 2.2 多继承复杂度主要是：第二个之后的父类，以及调用时this指针的转换问题 12345678910111213141516171819202122232425262728class Base1 &#123;public: Base1(); virtual ~Base1(); virtual void SpeakClearly(); virtual Base1* Clone() const;private: float data_base1_;&#125;;class Base2 &#123;public: Base2(); virtual ~Base2(); virtual void Mumble(); virtual Base2* Clone() const;private: float data_base2_;&#125;;class Derived : public Base1, public Base2 &#123;public: Derived(); virtual ~Derived(); virtual Derived* Clone() const;private: float data_derived_;&#125;; 如果以父类指针指向子类，则对于Base1则没问题，因为Base1地址与子类地址相同，而Base2则需要加减偏移this指针来对齐地址。在调用析构函数时也需要调整this指针。 假设有 Base2 *pbase2 = new Derived，Derived对象的地址需要被调整到Base2子对象的地址。 Derived *temp = new Derived; Base2 *pbase2 = tmep ? temp + sizeof(Base1) : 0; 在删除时，也需要调整指针到整个Derived对象地址。 多重继承之下的含有虚函数的对象模型： 含有多个虚函数表，虚函数表数目与父类数目有关 每一个虚函数表，子类都有一个虚指针对应 对于本例，则有两个虚函数表创建 一个主要实例，子类的虚函数表，与最左端的Base1类共享，涵盖整个对象的虚函数 一个次要实例，与Base2类相关，不包含Base1，即左边的父类的相关虚函数 例如：Base *pb1 = new Derived; Base2 *pb2 = pb1-&gt;Clone(); pb1首先加上offset，调整到Derived类地址，调用Derived::Clone()，返回值需要减去offset，调整到Base2的地址。 Sun编译器 Sun编译器为了解决多虚函数表问题，将虚函数表连在一起，加上指针指向下一个虚函数表，提升了项目的速度。 在虚函数足够小时，使用split function，将函数调整为两个函数，第二个在返回之前，为指针加减offset。 因此，Base1指针和Derived指针不需要调整this指针，而Base2指针调用的是新的函数。 Microsoft使用address points的方法。 2.3 虚拟继承1234567891011121314151617181920class Point2d &#123;public: Point2d(float = 0.0, float =0.0); virtual ~Point2d(); virtual void Mumble(); virtual float Z():private: float x_, y_;&#125;;class Point3d : public virtual Point2d &#123;public: Point3d(float = 0.0, float = 0.0, float = 0.0); virtual ~Point3d(); virtual float Z();private: float z_;&#125; 不同编译器对于虚继承下的虚函数有着眼花缭乱的支持，这里不做详述，太怪异了。 但是谨记，不要在虚基类中声明非静态数据成员。 3. 函数的效率 友元函数、静态成员函数、非静态成员函数的效率差不多，这是易于理解的，因为三者最终的调用方式相同，都被转换为非成员函数。 单继承虚函数需要通过构造函数设定vptr，所以效率降低了。 多继承虚函数有多方面因素，因为多继承，所以构造函数需要多调用一次，其次，可能需要调整this指针而导致效率进一步降低。 虚拟继承虚函数与多继承类似 4. 指向成员函数的指针4.1 非静态、非虚成员函数指针 取非静态、非虚成员函数的地址，得到的是真正地址，但是调用的话需要绑定一个函数对象。 123456double Point::M();// 声明如下double (Point:: *ptr_f) ();// 调用origin.*ptr_f(); -&gt; (ptr_f)(&amp;origin);ptr-&gt;*ptr_f(); -&gt; (ptr_f)(ptr); 4.2 虚成员函数指针 取虚函数的地址，得到的是其在虚函数表中的下标。（在vs2019上测试，结果并不是这样，得到的是一个内存地址） 1234float (Point:: *ptr_f) ();Point *ptr = new Point3d;(ptr-&gt;*ptr_f)(); -&gt; *(ptr-&gt;vptr[(int)ptr_f])(ptr); 为了区分函数指针指向的是非虚函数还是虚函数，编译器必须使ptr_f能够持有两种值，且可以被区分是内存地址还是虚函数表的下标 在cfron中，如此判断 1(((int) ptr_f) &amp; ~127) ? (*ptr_f)(ptr) : *(ptr-&gt;vptr[(int)ptr_f])(ptr); 这样只能限制最多只有128个虚函数。 4.3 多重继承下，成员函数指针为了使成员函数指针支持多重继承和虚拟继承，有以下结构体 12345678struct _mptr &#123; int delta; int index; union &#123; ptrtofunc faddr; int v_offset; &#125;;&#125;; delta指this指针的offset，index指虚函数表的下标，faddr指非虚成员函数地址（当index不指向虚函数表时，设为-1），v_offset指虚基类或多重继承的第二父类的vptr位置。 但是这样每次通过成员函数指针调用都会判断一次。被人诟病。 Microsoft引入vcall thunk，因此，faddr要么指向函数地址、要么指向vcall thunk地址，vcall thunk会自动选定虚函数表中的下标，调用。 该结构体的一个副作用是，当传递一个固定值给成员函数时，可能会产生临时对象。 4.4 效率 5. 内联函数(Inline Function)inline只是个请求，是否被接受，还得看编译器的是否认可inline的做法。 在cfront中，有一套测试法，两个阶段： 分析函数定义，决定函数的**”intrinsic inline ability”**(编译器相关的inline能力) 如果函数因复杂度、建构等问题，不可成为inline，则会转化为static函数 真正的inline函数扩展操作，实在调用函数的那一点上。这会带来参数的求值以及临时对象。 1new_pt.x(lhs.x() + rhs.x()); -&gt; new_pt.x = lhs.x_ + x_5PointFV(&amp;rhs); 这样扩张没有效率提升，所以不会被inline请求不会被处理。 5.1 形式参数 inline函数的形式参数都会被实际参数取代 如果实际参数会导致副作用，会引入临时对象 如果实际参数是常量表达式，直接求值 1234567891011121314151617181920inline int Min(int i, int k) &#123; reutrn i &lt; j ? i : j;&#125;inline int bar &#123; int minval; int val1 = 1024; int val2 = 2048; // 实参代替形参 minval = Min(val1, val2); -&gt; minval = val1 &lt; val2 ? val1 : val2; // 常量表达式，计算结果作为返回值 minval = Min(1024, 2048); -&gt; minval = 1024; // 副作用，引入临时对象 minval = Min(foo(), bar() + 1); -&gt; int t1, t2; -&gt; minval = (t1 = foo()), (t2 = Bar() + 1), r1 &lt; t2? t1 : t2; return minval;&#125; 5.2 局部变量inline函数中的局部变量会在inline函数被调用时被维护。因为这一点，如果参数有副作用，可能会导致扩展码变大。 因此inline函数作为宏的安全处理，为此可能需要扩大扩展码，需要谨慎处理。","categories":[{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"对象模型-3.数据","slug":"cpp-对象模型-第三章-数据","date":"2020-11-17T06:38:32.000Z","updated":"2021-01-30T01:58:33.192Z","comments":true,"path":"2020/11/17/cpp-对象模型-第三章-数据/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE/","excerpt":"","text":"1. 类的大小1234class X &#123;&#125;;class Y : public virtual X &#123;&#125;;class Z : public virtual X &#123;&#125;;class A ; public Y, public Z &#123;&#125;: 以上的继承体系中，类的大小会根据编译器的处理而变化。 X为1bytes，Y，Z为8bytes，A为12bytes X为1bytes 编译器为了确保类的不同对象具有不同地址，会为空类内部安插一个char。 Y，Z为8bytes 首先，我们需要知道，Y，Z的大小收到三部分影响： 语言本身的负担 虚基类、虚函数都会是类内部扩张，具体显示在某种形式的指针(或offset)上。 虚基类的指针会指向虚基类或相关表格或具体偏移量。 虚函数的指针则是指向虚函数表。 编译器对特殊情况的优化 Y，Z是空类，因此需要一个char，被放在类的固定部分的尾部。 某些编译器会对空虚基类进行特殊支持。 内存地址对齐 为了使的读取更有效率，会将内存扩大到4的倍数。 A的12bytes 一个虚基类只会在子类中存在一份实例 因此，A的大小如下： 唯一一份X的实例，1bytes 父类Y的大小，减去虚基类的就开销，结果使4bytes，X同理 A自己的大小，0 对齐，前三项为9bytes，因此最终是12bytes X为1bytes，Y，Z为4bytes，A为8bytes Y，Z为4bytes 有些编译器对空虚基类优化，将其放到子类的最初部分，这样子类就有了member，也就不会有第二点1个char的填充，也不需要对齐，因此只需4bytes。 A为8bytes 有些编译器对空虚基类优化，X实例的1bytes可以省略，因此也没有对齐，所以使8bytes 注意：编译器的的优化仅仅针对空虚基类 2. 数据成员的绑定1234567891011extern float x;class Point3d &#123;public: Point3d(float, float, float); float X() const &#123; reuturn x; &#125; void X(float new_x) const &#123; x = new_x; &#125;private: float x, y, z;&#125; 如今，我们都知道Point3d::X()传回的使类内部的x，然而在早期的编译器上，传回的是全局的x。 为此，为了防止这种情况发生，c++早期有两种防御性程序设计风格 将所有的成员变量放在类声明开始处，确保正确的绑定 将所有的内联函数，无论大小都放到类声明之外 这个古老的语言规则称为”member rewriting rule“，意为一个内联函数在整个类声明结束之前，是不会被解析的。 c++标准以”member scope resolution rules“来精练”rewriting rule“。 然而，这对成员函数的参数列表并不为真，参数列表中的参数在第一次遇见时还是会被解析。因此extern和嵌套typedef还是会出错。如： 1234567891011typedef int length;class Point3d &#123;public: // 此时length被解析为int，val_被解析为Point3d::val_ void Mumble(length val) &#123; val_ = val; &#125; length Mumble() &#123; return val_; &#125;private: typedef float length; length val_;&#125; 因此，需要把类中的嵌套typedef放到类的起始处。 3. 数据成员的布局12345678class Point3d &#123;private: float x_; static List&lt;Point3d*&gt; *free_list_; float y_; static const int chunk_size = 250; float z_;&#125; nonstatic数据成员在类中排列顺序和其声明顺序相同，中间如果存在static变量也不会被放到类之中。 c++标准指出，同一个存取段(access section)中，即public，private，protected，成员变量的排列需要符合较晚声明的变量出现在类中的较高的地址。因此数据成员的地址不需要连续，方便编译器实现内存对齐。 而vptr的位置在传统上是放在所有显式声明的成员变量的末尾，但是也有编译器将其放在开头。 同时，c++标准允许编译器将多个存取段(access section)中的数据成员自由排列。 skill 下面这个模板函数，接受两个成员变量，判断谁先出现在类中。如果两个成员都是不同的存取段中的第一个数据，那么就可以判断哪一个存取段先出现。 12345template &lt;class class_type, class data_type1, class data_type2&gt;char* AccessOrder(data_type1 class_type::*mem1, data_type2 class_type::*mem2) &#123; assert (mem1 != mem2); return mem1 &lt; mem2 ? &quot;member 1 occurs first&quot; : &quot;member 2 occurs first&quot;;&#125; 4. 数据成员的存取12Point3d origin;origin.x = 0.0; x的存取成本是什么？ 视x和Point3d的声明而定，x可能是static/nonstaic，Point3d可能是独立类/继承的类/多重继承/虚拟继承的类。 4.1 静态数据成员(static data members)内部static数据成员 静态数据成员是存放在类之外的全局存储区，因此其存取与类的关联，不会造成任何额外成本。 每次程序调用静态成员时，就会被内部转换为对该extern实例的直接调用。 通过指针和对象，存区静态成员的指令是完全相同的。因为静态成员并不在类对象中，所以不需要通过对象存取静态成员。 复杂继承关系的static数据成员 因为同样静态成员不在类对象中，且实例只有一份，所以存取仍然和上述行为相同。 函数得来的对象 1FooBar().chunk_size_ = 250; 调用FooBar()的行为，在c++预标准(pre-standard)中并没有定义。但在c++标准中明确要求FooBar()被求值，即使其结果没有用处。 123456// 原先的FooBar().chunk_size_ = 250;// 可能的一种转换(void)FooBar();Point3d::chunk_size_ = 250; 静态成员地址 如果取静态成员的地址，得到的是一个静态成员数据类型的指针，因为静态成员不在类中。即： 123&amp;Point3d::chunk_size_;// 结果为const int*; 名称冲突 如果两个类的静态成员名称相同，编译器会对名称转换，转换为一个新编码，此过程称为name-mangling。 每个编译器的做法不同，但是至少要保证以下两点： 推导出独一无二的编码 这些编码需要被轻易的推到回原来的名称 4.2 非静态数据成员(nonstatic data members)非静态数据成员存放在类对象内部。除非经过类对象（显式或隐式），否则无法直接存取他们。 因此，只要程序中的一个成员函数直接处理一个非静态数据成员，就会有隐式对象产生。 123456789101112Point3d Point3d::Translate(const Point3d&amp; pt) &#123; x_ += pt.x_; y_ += pt.y_; z_ += pt.z_;&#125;// 实际代码Point3d Point3d::Translate(Point3d *const this, const Point3d&amp; pt) &#123; this-&gt;x_ += pt.x_; this-&gt;y_ += pt.y_; this-&gt;z_ += pt.z_;&#125; 对一个非静态数据成员的存取操作，编译器需要把类对象初始地址加上数据成员的偏移地址。 123original.x_ = 0.0;// 其地址为&amp;original + (&amp;point3d::x_ - 1); -1的操作，是因为指向成员数据的指针，其偏移量总是被+1，这样编译器可以区分”一个指向成员数据的指针，他指出类的第一个成员“和”一个指向成员数据的指针，他没有指出任何成员“这两种情况。 每一个成员数据的偏移量在编译期即可确定，即使成员变量是属于父类的继承体系（单一继承或多重继承）中。 因此，存取一个非静态数据成员和存取一个结构体成员或一个非子类的成员的效率相同。 虚拟继承 12Point3d *pt;pt-&gt;x_ = 0.0; 当x_是虚基类的成员是，存取效率会慢一些。 12original.x_ = 0.0;pt-&gt;x_ = 0.0; 以上两种存取方式的区别在于：如果x_是虚基类成员变量，那么pt具体指向的类是不明确的，所以指针存取操作会延迟到执行期，经过一个额外的间接引导，才可以完成。 而original因为类型已经确定，所以成员变量的偏移量在编译期就已经确定。 5. 继承与数据成员在c++继承模型中，一个子类的内存是自己的成员数据加上父类的成员数据，至于数据的排列顺序，c++标准没有强制规定。大多数编译器都是父类成员数据先出现。虚基类除外。 5.1 不带多态的继承（没有虚函数）123456789101112131415161718192021222324252627282930313233class Point2d &#123;public: Point2d(float x = 0.0, float y = 0.0) : x_(x), y_(y) &#123;&#125; float x() &#123; return x_; &#125; float y() &#123; return y_; &#125; void x(float x) &#123; x_ = x; &#125; void y(float y) &#123; y_ = y; &#125; void operator+(const Point2d&amp; rhs) &#123; x_ += rhs.x(); y_ += rhs.y(); &#125;private: float x_, y_:&#125;class Point3d &#123;public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point2d(x, y), z_(z) &#123;&#125; float z() &#123; return z_; &#125; void z(float Z) &#123; z_ = z; &#125; void operator+(const Point3d&amp; rhs) &#123; Point2d::operator+(rhs); z_ += rhs.z(); &#125;private: float z_:&#125; 这样设计时，x，y的相关代码都局部化了，且抽象体系更易于理解。 然而，将原本独立的类，组合成继承关系，会造成两个易犯的错误。 重复设计相同功能的函数 point3d和point2d的构造函数和operator+并没有做成内联函数，因为他们需要调用Point2d的函数。 类的继承体系所带来的空间膨胀 1234567class Concrete &#123;private: int val_; char c1_; char c2_; char c3_;&#125; 上述类需要占用8bytes，4 + 1 + 1 + 1 + 1(对齐) 123456789101112131415class Concrete1 &#123;private: int val_; char c1_&#125;class Concrete2 : public Concrete1 &#123;private: char c2_;&#125;class Concrete3 : public Concrete2 &#123;private: char c3_;&#125; 这种情况下，Concrete3需要16bytes，8 + 4 + 4 为什么c++会这么做？而不是将padding填补呢？ 考虑如下： 1234Concrete2 *pc2;Concrete1 *pc1_1. *pc1_2;*pc1_2 = *pc1_1; 上述赋值操作，将会使被指对象的Concrete1部分复制给pc1_2。 如果考虑将padding填补 1234pc1_1 = pc2;// 那么，c2_就会被覆盖了*pc1_2 = *pc1_1 5.2 加上多态12345678910111213141516171819202122232425262728293031323334353637class Point2d &#123;public: Point2d(float x = 0.0, float y = 0.0) : x_(x), y_(y) &#123;&#125; float x() &#123; return x_; &#125; float y() &#123; return y_; &#125; void x(float x) &#123; x_ = x; &#125; void y(float y) &#123; y_ = y; &#125; virtual float z() &#123; return 0.0; &#125; virtual void z(float) &#123;&#125; virtual void operator+(const Point2d&amp; rhs) &#123; x_ += rhs.x(); y_ += rhs.y(); &#125;private: float x_, y_:&#125;class Point3d &#123;public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point2d(x, y), z_(z) &#123;&#125; float z() &#123; return z_; &#125; void z(float Z) &#123; z_ = z; &#125; // 注意，类型是point2d void operator+(const Point2d&amp; rhs) &#123; Point2d::operator+(rhs); z_ += rhs.z(); &#125;private: float z_:&#125; 只有当我们使用多态来处理使，设置一个virtual接口才合适。 为了支持多态，Point2d类会造成一些额外负担： 虚函数表，存放每一个虚函数的地址，表的个数还需要加上一个或两个位置，用来支持RTTI vptr，提供指向虚函数表的执行期链接 强化构造函数，为了使vptr初始化 强化析构函数，删除vptr。析构函数的调用是反向的，从子类到父类 在这种情况下，Point3d中含有一个额外的vptr，继承得来， 多了一个point3d的vtbl。 vptr的位置 目前，c++编译器的一个主要讨论题目是，将vptr放在哪里合适？ 一种做法是放在最后 这样可以保证类继承于结构体，确保了c++和c的兼容性。 另一种做法是放在开头 这种做法，会对多重继承下，通过类成员指针调用虚函数变得方便些。代价是成员变量的偏移拖延到执行期准备。且丧失了对c的兼容。但是有多少程序会从结构体继承下来的呢？ 5.3 多重继承单继承提供了一种自然多态的形式。即子类和父类从同一地址开始，只是大小有区别。 12Point3d p3d;Point2d *p = &amp;p3d; 这样的执行会很自然的发生，不需要额外操作。 如果把vptr放在类起始处，假设父类没有虚函数，而子类有虚函数，那么上述的赋值操作就无法自然发生，就需要编译器调整地址。 123456789101112131415161718192021222324252627class Point2d &#123;public: // 虚函数private: float _x, _y;&#125;;class Point3d &#123;public: // 虚函数private: float _z;&#125;;class Vertex &#123;public: // 虚函数private: Vertex *next;&#125;;class Vertex3d : public Point3d, public Vertex &#123;public: // 虚函数private: float mumble;&#125; 继承体系如下图所示： 多重继承的问题主要是子类和第二个继承的父类的转换问题。 在上述例子中，即将Vertex3d转换为Vertex，这需要编译器额外工作。 多重继承中，子类对象赋值给第一个继承的父类和单一继承相同，起始地址一样。如果是其后的父类，则需要对地址加/减中间的父类对象的大小。 如： 12345678910111213141516171819202122Vertex3d v3d;Vertex *pv;Point2d *p2d;Point3d *p3d;// 该操作会被转换pv = &amp;v3d;pv = (Vertex*)(((char*)&amp;v3d) + sizeof(Point3d));// 下面的操作直接进行p2d = &amp;v3d;p3d = &amp;v3d;Vertex3d *pv3d;Vertex *pv;pv = pv3d;// 被转换成pv = ((Vertex*)pv3d) + sizeof(Point3d);// 如果pv3d是空指针，那么pv的地址 = sizeof(Point3d)，造成错误// 实际的指针转换为pv = pv3d ? ((Vertex*)pv3d) + sizeof(Point3d) : 0; 引用则不需要对空值戒备，因为引用的初始化，不会使用到空对象。 c++标准没有要求父类的排列顺序，因此有些编译器(Meta Ware)设计了一种优化技术，只要第二个父类有虚函数，第一个父类没有，就将他们的顺序调换，这样子类的vptr就可以少产生一个，然而并没有得到广泛认可。 存取每一个父类的数据成员也无需额外操作，因为在编译时就已经处理好了偏移。 5.4 虚继承多重继承的副作用就是，他必须支持某种形式的共享对象继承，典型的例子是iostream库。 1234567891011// 早期的iostreamclass ios &#123;&#125;;class istream : public ios &#123;&#125;;class ostream : public ios &#123;&#125;;class iostream : public istream, public ostream &#123;&#125;;// 如今的iostream，只需要使用一份ios对象即可class ios &#123;&#125;;class istream : public virtual ios &#123;&#125;;class ostream : public virtual ios &#123;&#125;;class iostream : public istream, public ostream &#123;&#125;; 为了保证虚继承的多态，一般实现方法如下： 类如果有虚基类，虚基类会被分为两部分，共享区域和不变区域。 不变区域的部分无论子类怎样继承，都会有固定的偏移，该部分数据可以直接存取。 共享区域，即虚基类部分，每次都会因为继承而产生变化，他们只可以被间接存取。 不同编译器的差异就在于间接部分的不同，以下为三种主流策略。 1) 虚基类指针 12345678910111213141516171819class Point2d &#123;protected: float x_. y_;&#125;;class Vertex : public virtual Point2d &#123;protected: Vertex *next;&#125;;class Point3d : public virtual Poin2d &#123;protected: float z_;&#125;;class Vertex3d : public Vertex, public Point3d &#123;protected: float mumble_;&#125;; 为了获得共享部分，cfront编译器会在每一个子类中设置一些指针，每个指针指向虚基类，访问继承的虚基类成员是，通过指针间接完成 如： 123456789101112void Point3d::operator+=(const Point3d&amp; rhs) &#123; x_ += rhs.x_; y_ += rhs.y_; z_ += rhs.z_;&#125;;// 转换为void Point3d::operator+=(const Point3d&amp; rhs) &#123; _vbcPoint2d-&gt;x_ += rhs._vbcPoint2d-&gt;x_; _vbcPoint2d-&gt;y_ += rhs._vbcPoint2d-&gt;y_; z_ += rhs.z_;&#125;; 子类和父类的转换 123Point2d *p2d = pv3d;// 转换为Point2d *p2d = pv3d ? pv3d-&gt;_vbcPoint2d : 0; 该模型有两个主要的缺点： 每一个对象要对其每一个虚基类设置一个指针，然而我们希望每个对象有固定的指针个数，而不需要根据虚基类的个数而变动。 虚继承结构增加的话，就会导致间接存取层次增加。如果有三次虚继承，就会有三次间接存取。然而我们希望每个虚基类的访问时间是固定的，而不需要根据虚继承体系的深度而变动。 MeraWare等编译器使用第一种方法，他们复制所有虚基类的指针，将其放到子类中，解决固定访问时间的问题。但是付出了空间的代价。 第一个问题主要有两个解决方法。 第一种解决方法——2) 虚基类表 Microsoft编译器使用了虚基类表，每个对象如果有虚基类，则会通过一个虚基类表指针，指向虚基类表。真正的虚基类指针放在虚基类表中。 第二种解决方法——3) 虚函数表偏移策略[-1] 在虚函数表中存放虚基类的偏移量。 1234567891011121314151617void Point3d::operator+=(const Point3d&amp; rhs) &#123; x_ += rhs.x_; y_ += rhs.y_; z_ += rhs.z_;&#125;;// 转换为void Point3d::operator+=(const Point3d&amp; rhs) &#123; (this + _vptr_Point3d[-1])-&gt;x_ += (&amp;rhs + ths._vptr_Point3d[-1])-&gt;x_; (this + _vptr_Point3d[-1])-&gt;y_ += (&amp;rhs + ths._vptr_Point3d[-1])-&gt;y_; z_ += rhs.z_;&#125;;// 子类和虚基类之间的转换Point2d *p2d = pv3d;Point2d *p2d = pv3d ? pv3d + pv3d-&gt;_vptr_Point3d[-1] : 0; 上述方法在存取继承来的成员时代价较高，但是此代价被分散到对成员的使用上，属于局部性成本。 以上三种方法都是一种实现模型，而不是标准，每种模型都是来解决共享区域的数据存储问题。 如果通过非多态的存取操作，可以在编译时期被解析，效率较好。 12Point3d origin;origin.x_; 通常，最有效的使用虚基类的方法是，一个抽象虚基类，没有任何数据成员。 6. 对象成员的效率我们将对聚合、封装以及继承所引发的负担做测试。 局部变量 12345678float pa_x = 1.725, pa_y = 0.875, pa_z = 0.478;float pb_x = 0.315, pb_y = 0.317, pb_z = 0.838;for (int iter = 0; iter &lt; 10000000; ++iter) &#123; pb_x = pa_x - pb_z; pb_y = pa_y + pb_x; pb_z = pa_z + pb_y;&#125; 123class Point1d &#123;&#125;;class Point2d : public virtual Point1d &#123;&#125;;class Point2d : public virtual Point2d &#123;&#125;; 因此，程序的效率不可通过经验判断，需要实际检验。 7. 指向数据成员的指针指向数据成员的指针主要用途有两点。 类成员的底层布局，判断vptr在开头还是末尾 之前在数据成员的布局中提到的，判断类中的存取段(access section)的顺序 1234567class Point3d &#123;public: virtual ~Point3d();protected: static Point3d origin_; float x_, y_, z_;&#125; 去某个成员变量的地址（nonstatic），将达到成员变量在类中的偏移，但是因为vptr的位置没有限制，通常在类开头或结尾，所以可能会有差别。 我们期望分别对x_，y_，z取地址后得到0，4，8或4，8，12。然而实际结果却比期望结果多了1。 注意：在visual studio2019上测试得到的结果是0，4，8，这可能跟编译器的特殊处理有关。 为什么会多1呢？ 为了区分空指针和指向第一个数据成员的指针。 1234567Point3d origin;// 取nonstatic数据成员的地址，得到的是偏移量&amp;Point3d::x_;// 取一个对象的数据成员的地址，得到的是内存中的实际地址&amp;origin::x_;// 将&amp;origin::x_的结果减&amp;Point3d::x_的结果+1，就会得到origin的起始地址 多重继承下的指向数据成员的指针 123456789101112131415161718192021222324252627282930313233343536class Base1 &#123;public: int val1;&#125;;class Base1 &#123;public: int val2;&#125;;class Derived : public Base1, public Base2 &#123;&#125;;void Func1(int Derived::*dmp, Derived *pd) &#123; pd-&gt;*dmp;&#125;void Func2(Derived *pd) &#123; int Base2::*bmp = &amp;Base2::val2; // bmp值为1，但在Derived中，val2地址为5 Func1(bmp, pd);&#125;// 经过转换void Func2(Derived *pd) &#123; int Base2::*bmp = &amp;Base2::val2; // bmp值为1，但在Derived中，val2地址为5 Func1(bmp + sizeof(Base1), pd); // 但是无法确保bmp是否为0&#125;// 经过转换，防止bmp=0void Func2(Derived *pd) &#123; int Base2::*bmp = &amp;Base2::val2; // bmp值为1，但在Derived中，val2地址为5 Func1(bmp ？ bmp+ sizeof(Base1) : 0, pd);&#125; 当bmp被作为Func1的第一个参数时，它的值需要根据Base1的大小而调整，否则会访问Base1的val1。 7.1 指向数据成员的指针的效率指针指向对象的成员： 123Point3d pa;float *ax = &amp;pa.x;*bx = *ax - *bz; 指针指向类的数据成员： 12float Point3d::*ax = &amp;Point3d::x;pa.*ax = pa.*ax - pb.*bz; 加上继承 因为继承的数据成员是直接放在类对象中的，因此继承的方式没有带来什么效率差异。 而虚拟继承的主要影响是对编译器的优化。 因为每次存取Point::x，都会被转换为&amp;pb-&gt;_vbcPoint + (bx - 1)，多了一次间接访问，降低了寄存器的优化能力。","categories":[{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"对象模型-2.构造函数","slug":"cpp-对象模型-第二章-构造函数","date":"2020-11-17T06:36:25.000Z","updated":"2021-01-30T01:54:33.056Z","comments":true,"path":"2020/11/17/cpp-对象模型-第二章-构造函数/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","excerpt":"1. 默认构造函数的生成并不是类没有构造函数时，编译器都会创建一个默认构造函数，只有当编译器需要的时候，才会创建一个默认构造函数。 而如果是程序的需要，那就是程序员的责任去创建构造函数。 c++95声明，当没有用户定义的构造函数时，会隐式创建一个默认构造函数，然而这个隐式构造函数是trivial的（无能的） 1.1 带有默认构造函数的成员类对象如果类没有构造函数，但是其成员类对象拥有默认构造函数，那么该类的隐式默认构造函数是nontrivial的（有用的），编译器就会在构造函数被调用时创建一个隐式构默认造函数。 为了解决不同文件中的同一个类多次创建问题，即在A文件中调用C类，在B文件中调用C类，会将创建的构造、析构、复制构造、赋值以inline方式完成，如果函数太复杂，就会创建explicit non-inline static函数。 12345678910class Foo &#123;public: Foo();&#125;class Bar &#123;public: Foo foo; char* str;&#125; 此时编译器为了满足自身要求，会创建要给构造函数，大体如下：","text":"1. 默认构造函数的生成并不是类没有构造函数时，编译器都会创建一个默认构造函数，只有当编译器需要的时候，才会创建一个默认构造函数。 而如果是程序的需要，那就是程序员的责任去创建构造函数。 c++95声明，当没有用户定义的构造函数时，会隐式创建一个默认构造函数，然而这个隐式构造函数是trivial的（无能的） 1.1 带有默认构造函数的成员类对象如果类没有构造函数，但是其成员类对象拥有默认构造函数，那么该类的隐式默认构造函数是nontrivial的（有用的），编译器就会在构造函数被调用时创建一个隐式构默认造函数。 为了解决不同文件中的同一个类多次创建问题，即在A文件中调用C类，在B文件中调用C类，会将创建的构造、析构、复制构造、赋值以inline方式完成，如果函数太复杂，就会创建explicit non-inline static函数。 12345678910class Foo &#123;public: Foo();&#125;class Bar &#123;public: Foo foo; char* str;&#125; 此时编译器为了满足自身要求，会创建要给构造函数，大体如下： 123inline Bar::Bar() &#123; foo.Foo::Foo();&#125; 但是该构造函数并没有初始化str，这将导致程序运行不正确，然而这一部分功能应该由程序员去实现 假设程序员编写了如下构造函数： 123Bar::Bar() &#123; str = nullptr;&#125; 然而该构造函数没有满足编译器的需求，因此，编译器会扩张该构造函数。 1234Bar::Bar() &#123; foo.Foo::Foo(); str = nullptr;&#125; 如果类由多个成员类对象，则会根据其声明顺序，来扩张构造函数的编写顺序。 1.2 带有默认构造函数的父类这种情况下与前一种情况类似。 如果本类由多个构造函数，但是没有默认构造函数，编译器会扩张每一个构造函数，而不会去创建一个新的默认构造函数。 如果本类中还有带着默认构造函数的成员类对象，这些成员类的默认构造函数也会在父类默认构造函数调用之后被调用。 1.3 带有虚函数的类1234567891011121314151617class Widget &#123;public: virtual void Flip() = 0;&#125;;void Flip(const Widget&amp; widget) &#123; widget.Flip();&#125;// Bell 和 Whistle 都继承Widget类void Foo() &#123; Bell b; Whistle w; Flip(b); Flip(w);&#125; 其中，虚函数的调用部分会被重写成类似形式： 1234// widget.Flip() 的虚函数调用动作(*widget.vptr[1])(&amp;widget)// &amp;widget 表示被调用的函数实例的this指针 为了实现如上调用，编译器会为每一个带有虚函数的类的vptr初始化。 1.4 带有虚基类的类虚基类在不同编译器上的实现方式不同，而每一种实现方式都需要确保虚基类在子类中的位置能在执行期确定 12345678910111213141516171819202122232425262728class X &#123; public: int i;&#125;;class A : public virtual X &#123;public: int j;&#125;;class B : public virtual X &#123;public: double d;&#125;class C : public A, public B &#123;public: int k;&#125;void Foo(const A* pa) &#123; pa-&gt;i = 1024;&#125;int main() &#123; Foo(new A); Foo(new B);&#125; 在上述代码中，编译器无法确定pa中的X::i的具体位置，因为A*的实际类型并不清楚。 因此编译器需要改变代码，在执行期确定X::i。 可能的改变如下： 123void Foo(const A* pa) &#123; pa-&gt;_vbcX-&gt;i = 1024;&#125; 同个一个_vbcX指向具体的虚基类X，编译器也为此在对象创建时初始化该指针。 2. 复制构造函数的操作2.1 复制构造函数的调用在三种情况中，复制构造函数会被调用： 显式地将对象作为另一个对象的初值 123class X &#123;&#125;;X a;X ax = a; 对象通过参数传递给函数 1234class X &#123;&#125;;void Foo(X x);Foo(x); 函数返回类对象 1234void Foo() &#123; X xx; return xx;&#125; 2.2 默认按成员初始化(default memeberwise initialization)如果类没有显式复制构造函数，编译器会以默认按成员初始化，即将类中声明的，或继承的数据成员逐一复制，如果遇到了成员类对象，将会递归地实行按成员初始化。如： 1234567891011121314class String &#123;public: // 缺少显式复制构造函数private: char* str; int len;&#125;;String noun(&quot;book&quot;);String verb = noun;// 类似于verb.str = noun.str;verb.len = noun.len; 此时该对象的默认按成员初始化会发生。 如果该类是另一个类的成员，如下： 1234567class Word &#123;public: // 缺少显式复制构造函数private: int occurs; String word;&#125; 那么word的复制构造函数会以默认按成员初始化的方式进行，先复制occurs，接着在递归调用word的按成员初始化操作。 这种默认按成员初始化的操作时怎么实现的？ 如同默认构造函数，默认复制构造函数的生成会区分为trivial和nontrivial，只有nontrivial的实例会被创建。 而复制构造函数的trivial的标转在于类是否展现出bitwise copy semantics。 ####bitwise copy semantics（按位逐个复制） 如下： 12345class Word &#123;private: int cnt; char* str;&#125;; 以上情况就展现出了bitwise copy semantics，也无需由一个默认复制构造函数来完成初始化操作，通过直接赋值即可完成，默认复制构造函数也不会创建。 然而： 12345678910class Word&#123;private: int cnt; String str;&#125;;class String &#123;public: String(const String&amp;);&#125;; 这种情况下，编译器需要创建默认复制构造函数，调用str的复制构造函数。 编译器合成的复制构造函数都是浅复制 2.3 没有展现出bitwise copy semantics以下四种情况，类不会展现出bitwise copy semantics 类中存在成员类对象，该成员类对象含有一个复制构造函数（不论是程序员显式声明的，还是编译器合成的） 类继承带有复制构造函数的父类（不论是程序员显式声明的，还是编译器合成的） 类具有虚函数 类的继承链中，存在虚继承 2.4 具有虚函数的复制构造函数有如下两类： 1234567891011121314151617class ZooAnimal &#123;public: ZooAnimal(); ~ZooAnimal(); virtual void Animate(); virtual void Draw();&#125;class Bear : public ZooAnimal &#123;public: Bear(); void Animate(); void Draw(); virtual void Dance();&#125; 当ZooAnimal的一个类对象以另一个ZooAnimal的对象作为初值，或Bear的一个类对象以另一个Bear的对象作为初值，都可以直接按位逐个复制完成，此时vptr也会同时复制过去。 当ZooAnimal的一个类对象以Bear的对象作为初值时，就不能将vptr复制过去，复制构造函数会设定vptr指向ZooAnimal的而不是Bear的。 2.5 虚基类的复制构造函数首先，同类对象的复制直接使用按位复制即可，然而，以子类的形式复制会存在问题，如下： 123class ZooAnimal &#123;&#125;;class Raccon : public virtual ZooAnimal &#123;&#125;;class RedPanda : public Raccon &#123;&#125;; 如果将RedPanda的对象复制给Raccon，编译器需要设置虚基类的指针或者偏移量。 3. 程序转换例： 123456class X &#123;&#125;;X Foo() &#123; X xx; return xx;&#125; 在上述函数中会发生以下情况： 每次Foo()被调用时，都会传回xx的值 如果X定义了复制构造函数，return时也会调用复制构造函数 第一种情况的真实性，需要明确X是如何定义的。 第二种情况的真实性，虽然也需要明确X是如何定义，但是主要的还是看编译器是如何优化的。 在不同的编译器上，优化的结果可能导致以上两种情况都不会发生。 3.1 显式的初始化12345678class X &#123;&#125;;X x0;void Foo() &#123; X x1(x0); X x2 = x0; X x3 = X(x0);&#125; 在程序优化过程中，会有两个阶段的动作： 重写每一个定义，初始化操作会被重写。注：严谨的说，定义是指占用内存的行为。 类的复制构造函数被调用 因此，上述转换后可能是这样： 1234567891011void Foo() &#123; // 定义被重写 X x1; X x2; X x3; // 调用复制构造函数 x1.X::X(x0); x2.X::X(x0); x3.X::X(x0);&#125; 3.2 参数传递的初始化c++标准指出，将类对象作为参数或返回值时，相当于如下初始化： 12X xx = arg;// xx表示形式参数或返回值，arg表示实参 如果有如下定义： 123456class X &#123;&#125;;void Foo(X x0);X x;Foo(X x0); 这种情况下，不同编译器的实现方式不同，大体有两种： 引入临时变量，调用复制构造函数将其初始化，但因此函数的声明也需要被改写。 123456X _temp;_temp.X::X(x);Foo(_temp);// Foo函数也需要被改写void Foo(X&amp; x0); 在函数执行完毕后，临时变量也会自动调用析构函数。 拷贝建构(copy construct) 将实参复制到合适的位置上，位置由函数调用的地址而决定，类似于==栈帧== 3.3 返回值的初始化123456class X &#123;&#125;;X Bar() &#123; X xx; reutrn xx;&#125; 返回值的处理也是一个双阶段转换 增加一个额外参数，该参数是类的引用，用来放复制构造产生的返回值 在return之前增加一个复制构造函数的调用操作，初始化这个额外参数 转换后的Bar()函数如下： 1234567void Bar(X&amp; _result)&#123; X xx; xx.X::X(); _result.X::X(xx); return;&#125; 在调用Bar函数时，调用也需要转换 12345678910111213141516X xx = Bar();//转换为X xx;Bar(xx);Bar().Fun();// 转换为X _temp;(Bar(_temp), _temp).Fun();// 函数指针X (*pf)();pf = Bar;// 转换为void (*pf)(X&amp;);pf = Bar; 3.4 在用户层上去优化返回值定义一个计算用的构造函数，即不需要写 12345678910111213class X &#123;&#125;;X Bar() &#123; X xx; // 处理xx reutrn xx;&#125;X Bar(const T&amp; y, const T&amp; z) &#123; X xx; // 以y和z来处理xx return xx;&#125; 这样会导致xx使用复制构造函数，复制到编译器产生_result 优化方法是定义一个X的构造函数，以y，z为初始化条件，因此Bar可以被改写为： 123X Bar(const T&amp; y, const T&amp; z) &#123; return X(y, z);&#125; 这样，被转换之后，效率可以会高一点 1234void Bar(X&amp; _result, const T&amp; y, const T&amp; z) &#123; _result.X::X(y, z); return;&#125; 这样做减少了复制构造函数的成本。但是会导致类中的用于这种方法计算的构造函数数量增加。 3.5 在编译器层上去优化返回值编译器的优化即为： 12345678910111213class X &#123;&#125;;X Bar() &#123; X xx; // 处理xx reutrn xx;&#125;void Bar(X&amp; _result)&#123; _result.X::X(xx); // 处理_result return;&#125; 这样的编译器优化操作，称为**Named Return Value(RNV)**优化。且NRV也是当今c++标准编译器的优化之一。 虽然NRV的优化很好，但是饱受批评。原因有： NRV由编译器完成，他是否真的被执行，并不清楚 如果函数复杂，NRV就难以实行。 在有些程序中，NRV可能会导致程序错误运行 12345void Foo() &#123; // 一个复制构造函数被调用 X xx = Bar(); // 调用析构函数&#125; 此时对称性因为优化被打乱，程序的运行也出错了。 4. 复制构造函数，需要吗？123456class Point3d &#123;public: Point(float x, float y, float z);private: float x, y, z;&#125;; 类设计者需要编写复制构造函数吗？ 答案是不需要！ 首先，类中只有数值类型，编译器提供的复制构造函数足够了，安全，快速。 然而，如果存在大量以按值返回对象的操作，为了保证NRV的施行，需要编写复制构造函数。 123456789101112131415Point3d operator+(const Point3d&amp;, const Point3d&amp;);Point3d operator-(const Point3d&amp;, const Point3d&amp;);Point3d operator*(const Point3d&amp;, int);// 构造函数的编写可以如下：Point3d::Point3d(const Point3d&amp; p) &#123; x = p_x; y = p_y; z = p_z;&#125;// 更好的实现是使用memcpyPoint3d::Point3d(const Point3d&amp; p) &#123; memcpy(this, &amp;p, sizeof(Point3d));&#125; 然而memcpy和memset都需要类仅仅含有内置数据类型。 如果含有虚函数或虚基类，vptr和虚基类指针/编译会被错误设置。 5. 成员初始化列表(Member Initialization List)在以下情况，必须使用成员初始化列表 初始化一个引用对象 初始化const对象 调用父类的构造函数，该构造函数有一组参数 调用成员类对象的构造函数，构造函数有一组参数。 如： 12345678910class Word &#123;public: Word() &#123; name_ = 0; cnt_ = 0; &#125;private: String name_; int cnt_;&#125; 该构造函数会产生一个临时对象，并调用临时对象的operator=操作，最后调用析构函数。 1234567891011121314151617181920// 编译器改写Word::Word() &#123; name_.String::String(); String temp = String(0); name_,String::operator=(temp); temp.String::~String(); cnt_ = 0;&#125;// 较好的方式Word::Word() : name_(0) &#123; cnt_ = 0;&#125;// 编译器改写Word::Word() &#123; name_.String::String(0); cnt_ = 0;&#125; 5.1 陷阱成员初始化列表的顺序 初始化列表中的排列方式并不会影响其初始化顺序，在类中的声明顺序才会决定其初始化顺序。 1234567class X &#123;private: int i; int j;public: X(int val) : j(val), i(j) &#123;&#125;&#125;; 上述代码的本意是先将val值给j，然后将j的值给i，然而真正的执行顺序是按照声明顺序，即将j的值给i，再将val的值给j。 为了达成以上目的，应该这么写： 123X::X(int val) : j(val) &#123; i = j;&#125; 成员初始化列表中的操作是位于函数体内语句之前，因此这样可以正常执行。 初始化列表与成员函数 考虑如下构造函数： 12X::X(int val) : i(Func(val)), j(val) &#123;&#125;// Func是X的成员函数 这样写是正确的，然而存在不确定性，因为你并不知道Func对于类X的依赖性是多少。 因此，将初始化过程放在函数体中执行。 子类的成员函数返回值作为父类构造函数的参数 12345678class FooBar : public X &#123;private: int fval_;public: int fval() &#123; return fval_; &#125;; FooBar(int val) : fval_(val), X(fval()) &#123;&#125;&#125;; 编译器改写： 12345FooBar::FooBar &#123; X::X(this, this-&gt;fval()); fval_ = val;&#125; 显然，很糟糕。 总结 编译器会按照变量声明顺序，对初始化列表的顺序重新排列。且会在构造函数中插入代码，这些代码都位于用户编写的代码之前。","categories":[{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"对象模型-1.关于对象","slug":"cpp-对象模型-第一章-关于对象","date":"2020-11-17T06:34:52.000Z","updated":"2021-01-30T01:47:49.408Z","comments":true,"path":"2020/11/17/cpp-对象模型-第一章-关于对象/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"1. c++对象模型类的非static成员变量在类之中，static成员变量和staic/非static成员函数在类之外。 虚函数会在对象存储一个虚函数表指针(vptr)，该指针指向相关的虚函数表(vtbl)，vptr的初始化、重置由类的构造、析构、赋值决定。每一个类的type_info由vtbl指出，存储在第一个表项中。 2. 类的内存大小 非static成员变量的大小总和 内存对齐，4bytes的整数倍 支持虚函数和虚继承的额外开销 3. 多态中的指针1234567891011121314151617class ZooAnimal &#123;public: virtual void dance();private: int ioc; String name;&#125;class Bear : public ZooAnimal &#123;public:private: enum Dances &#123;...&#125;; Dances dances; int cell_block;&#125; 如上的继承体系，Bear类的内存情况如下： 解析时，指针根据指针的类型，读取对应大小的内存","categories":[{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]}],"categories":[{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"},{"name":"unp","slug":"unp","permalink":"http://example.com/categories/unp/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]}