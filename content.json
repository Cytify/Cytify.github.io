{"meta":{"title":"Cytify","subtitle":"","description":"","author":"Cytify","url":"http://example.com","root":"/"},"pages":[{"title":"Category","date":"2021-01-27T15:19:38.000Z","updated":"2021-01-27T15:21:12.419Z","comments":true,"path":"category/index.html","permalink":"http://example.com/category/index.html","excerpt":"","text":""},{"title":"Tag","date":"2021-01-27T15:19:15.000Z","updated":"2021-01-27T15:21:27.868Z","comments":true,"path":"tag/index.html","permalink":"http://example.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"unp_4.基本套接字编程","slug":"unp-4-基本套接字编程","date":"2021-01-31T14:03:51.000Z","updated":"2021-01-31T14:08:26.753Z","comments":true,"path":"2021/01/31/unp-4-基本套接字编程/","link":"","permalink":"http://example.com/2021/01/31/unp-4-%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/","excerpt":"","text":"1.概述TCP版本的网络通信如下： 2.socket函数网络通信的第一步就是调用socket函数 123#include &lt;sys/socket.h&gt;int socket(int family, int type, int protocol); family参数指明协议族，具体常值如下： type参数指明套接字类型，具体常值如下： protocol参数为0或者如下： family和type参数的组合反映了对应的协议，如下： “是”代表有效组合，但没有合适的缩略词，空白则是无效组合。 socket函数成功后，返回一个小的非负整数，称为套接字描述符（socket descriptor），简称sockfd。 3.connect函数TCP客户端使用connect函数建立于TCP服务器的连接。 1234#include &lt;sys/socket.h&gt;// 返回值: 成功返回0，出错返回-1int connect(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen); sockfd是socket函数创建的套接字描述符，第二、第三个参数分别是套接字地址结构指针和该结构的大小。 客户端在调用connect函数时，不必先调用bind，内核会确定源IP地址和选择一个临时端口。 TCP的connect函数会触发三路握手，在成功或出错后返回，出错有以下几种情况： TCP客户没有收到SYN分节响应，返回ETIMEDOUT错误。 客户的SYN响应是RST（表示复位），代表服务器在端口上没有进程与之连接，客户接收到RST，返回ECONNREFUSED错误。 RST是TCP在发生错误时发送的一种TCP分节，产生RST的条件有： 服务器端口上的SYN到达，但是没有对应的进程监听 TCP想取消一个已有连接 TCP接收到一个根本不存在的连接上的分节 客户发出的SYN在某个路由器上出现了目的地不可达的ICMP错误。在一定时间重发后，把消息作为EHOSTUNREACH或ENETUNREACH错误返回给进程。 或者是以下两种情形： 本地系统转发表没有到目的地的路径 connect调用不等待就直接返回 4.bind函数bind函数把一个本地协议地址赋给一个套接字。 1234#include &lt;sys/socket.h&gt;// 返回值: 成功返回0， 出错返回-1int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen); 第二个参数是指向特定协议的地址结构的指针，第三个参数时该地址结构的长度。在使用时，可以仅指定其中一个，也可以都不指定 如果未指定，内核会为套接字选择一个临时端口和自身对应的ip地址 客户端未指定地址是可以理解的，除非需要使用一个预留端口 服务端未指定地址，内核会把客户发送的SYN的目的IP地址作为服务器的源IP地址 第二、第三参数的搭配结果如图： 如果端口为0，内核在bind被调用时选择一个临时端口 如果ip地址为通配地址，内核将等到套接字已连接(TCP)，或套接字上发出数据报报(UDP)时，选择一个本地IP地址 对于IPv4，通配地址一般是INADDR_ANY，IPv6则不同 12345struct sockaddr_in servaddr;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);struct sockaddr_in6 serv;serv.sin6_addr = in6addr_any; in6addr_any会被系统定义并初始化，头文件&lt;netinet/in.h&gt;中有该声明 5.listen函数listen函数有服务器调用时，会做两件事情。 在socket函数创建一个套接字时，套接字被假设为主动套接字，即主动发起连接。listen函数把一个未连接的套接字转换为被动套接字，内核接受指向该套接字的连接请求。 套接字从CLOSED状态切换到LISTEN状态。 listen函数的第二个参数指定内核为套接字连接请求排队的最大连接个数 1234#include &lt;sys/socket.h&gt;// 返回值: 成功返回0，出错返回-1int listen(int sockfd, int backlog); 内核为给定的监听套接字维护两个队列： 未完成连接队列。每个SYN分解对应一项，是客户与服务器之间的TCP三次握手过程。 已完成连接队列。已完成TCP三次握手的客户 这两个队列之和不超过backlog TCP的连接建立是完全自动的，无需服务器进程插手，下图是两个队列建立连接 客户的SYN到达服务器时，TCP在未完成队列中创建一项，接着返回给客户端，等待第三个分节到达或者该项超时。三路握手正常结束后，该项从未完成队列移动到已完成队列队尾。 进程调用accept函数时，从已完成队列队头返回给进程，如果该队列为空，进程会被睡眠，直到TCP在已完成队列中新增一项后，唤醒该进程。 对于backlog参数，有以下几项需要注意 backlog参数曾被规定为两个队列总和 Berkeley的实现给backlog增加了一个模糊因子：将backlog乘1.5，得到未处理队列的最大长度 backlog不要设为0，如果不希望客户连接该套接字，关闭该套接字 backlog的大小设置，一般通过环境变量或命令行来设置。如果该值比内核支持的最大值还要大，内核会将该值截断为自身能够支持的最大值。 当一个客户的SYN到达时，若队列满了， 就会忽略该分节。客户端就会通过TCP重传机制来处理 三路握手完成后，在服务器调用accept之前，到达的数据有服务器TCP排队，保存在相应已连接套接字的接受缓冲区中 6.accept函数accept函数由TCP服务器调用，从已完成队列队头返回一个已完成连接。如果已完成队列为空，进程进入睡眠。 1234#include &lt;sys/socket.h&gt;// 返回值: 成功返回非负描述符，出错返回-1int accept(int sockfd, struct sockaddr* cliaddr, socklen_t* addrlen); 参数cliaddr和addrlen用来返回已连接的客户端的协议地址。**addrlen是值-结果参数**，调用时，该参数为cliaddr所指的套接字地址结构的长度；返回时，为内核放在套接字地址结构中的具体字节数。 如果accept成功，返回一个由内核生成的全新套接字描述符，代表与客户的TCP连接。 第一个参数称为监听套接字描述符（由socket函数创建，用于bind和listen函数的参数）。 accept函数的返回值称为已连接套接字描述符。 一个服务器通常只有一个监听套接字，在服务器运行时一直存在。 内核为每个已连接TCP客户端创建一个已连接套接字，在服务器服务结束后，关闭这个已连接套接字。 7. fork和exec函数7.1 fork函数Unix中派生新进程的唯一方法，用于并发服务器。 1234#include &lt;unistd.h&gt;// 返回值: 在子进程中返回0，在父进程中返回子进程ID，出错返回-1pid_t fork(void); fork调用一次，返回两次。 在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID 在子进程中返回一次，返回值为0 返回值是告诉当前进程是父进程还是子进程 这样设置返回值的原因在于，子进程只有唯一的父进程，可以通过getppid获得父进程ID。而父进程无法获得各个子进程的进程ID，所以每次需要记录fork返回值 父进程中，在调用fork打开的所有套接字描述符，在子进程中共享。通常情况下，网络服务器中父进程调用accept后，调用fork，接着子进程读写这个已连接套接字，父进程关闭这个已连接套接字。 fork的典型用法如下： 一个进程创建一个自身的副本，每个副本在另一个副本执行其他任务的同时处理各自的某个操作。网络服务器的典型用法 一个进程想执行另一个程序。该进程调用fork创建一个自身副本，其中一个副本调用exec将自身替换成新的程序。shell之类的程序的典型用法 7.2 exec函数可执行程序被Unix执行的唯一方法是：有一个现有进程调用六个exec函数中的某一个。 exec函数将当前进程映像替换为新的程序文件，新程序通常从main函数开始执行，进程ID不变化。我们称调用exec的进程为调用进程 六个exec函数的区别在于： 待执行的程序文件由文件名指定还是由路径指定 新程序的参数一一列出还是由指针数组引用 调用进程的环境传递给新程序，还是新程序指定新环境 12345678910#include &lt;unistd.h&gt;int execl(const char* pathname, const char* arg0, .../* (char*) */);int execv(const char* pathname, const char* argv[]);int execle(const char* pathname, const char* arg0, .../* (char*) 0, char* const envp[]*/);int execve(const char* pathname, const char* argv[], char* const envp[]);int execlp(const char* pathname, const char* arg0, .../* (char*) 0*/);int execvp(const char* pathname, const char* argv[]); 这些函数之间的关系如下： 一般来说，execve是内核中的系统调用，其他exec函数都是调用execve的库函数 上面的三个函数，把新程序的每个参数作为独立参数，以空指针结束这些参数。 下面的三个函数，有一个指针数组，指向各个参数字符串，并以空指针结尾 左列两个函数指定filename参数，函数使用当前的PATH环境变量将其转化为路径。但是如果filename含有左斜杠/，就不使用PATH环境变量。右两列四个函数以路径名作为参数 左两列4个函数使用外部变量environ的当前值，构造一个环境列表。右列2个函数指定环境列表，envp指针数组以空指针结束 8. 并发服务器并发服务器的框架如下： 12345678910111213141516171819int main(void) &#123; pid_t pid; int listenfd, connfd; listenfd = Socket(..); Bind(listedfd, ..); Listen(listenfd, LISTENQ); for (; ;) &#123; connfd = Accept(listenfd, ..); if ( (pid == Fork()) == 0) &#123; Close(listenfd); do_it(connfd); // 处理请求，传递数据 Close(connfd); exit(0); &#125; Close(connfd); &#125;&#125; 为什么子进程要关闭listenfd? 父进程关闭connfd **每个文件和套接字都有一个引用计数，在文件表项中维护 (APUE P58-59)**。 在fork之后，套接字在子进程中共享，引用计数增加1。所以，父进程关闭connfd和子进程关闭listenfd只是将引用计数从2变为1 具体情况如图： accept之前 accept之后，fork之前 调用fork 父进程关闭connfd，子进程关闭listenfd 9. close函数close函数用于关闭套接字，终止TCP连接 1234#include &lt;unistd.h&gt;// 返回值: 成功返回0 出错返回-1int close(int sockfd); close一个TCP套接字的默认行为是把该套接字标记成已关闭，然后立即返回调用进程，之后该套接字不能被使用。 然后TCP会尝试发送所有排队等待发送的数据，之后发送TCP终止序列 描述符引用计数 如果我们的确想在某个TCP套接字上发送FIN，可以调用shutdown函数代替close 10. getsockname和getpeername函数getsockname返回与某个套接字关联的本地协议地址，getpeername返回与某个套接字关联的外地协议地址 12345#include &lt;sys/socket.h&gt;// 返回值: 成功返回0 出错返回-1int getsockname(int sockfd, struct sockaddr* localaddr, socklen_t* addrlen);int getpeername(int sockfd, struct sockaddr* peeraddr, socklen_t* addrlen); 这两个函数的后两个参数都是值-结果参数 这两个函数某个连接的两端的协议地址，对于IPv4和IPv6说，即IP和端口 这两个函数的用处 使用getsockname获得对应的ip地址和由内核分配的端口号 获得accept函数得到的已连接套接字的ip和端口 当进程调用exec调用服务器时，getpeername是唯一获得客户ip和端口的方式 因为exec会使进程的内存映像替换为新的服务器的程序文件，原先保存对端地址的内存丢失了。但是已连接套接字是跨exec开放的，新服务器获取已连接套接字的方式有两种： 先将套接字转换为字符串，通过命令行参数传递给新程序 约定将某些描述符置为已连接套接字的描述符","categories":[{"name":"unp","slug":"unp","permalink":"http://example.com/categories/unp/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"unp_3.套接字编程简介","slug":"unp-3-套接字编程简介","date":"2021-01-31T14:00:49.000Z","updated":"2021-01-31T14:22:33.547Z","comments":true,"path":"2021/01/31/unp-3-套接字编程简介/","link":"","permalink":"http://example.com/2021/01/31/unp-3-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1. 套接字地址结构大多数套接字函数都需要一个只想套接字地质结构的指针作为参数，每个协议族也定义了自身的套接字地址，这些结构以sockaddr_开头，并以对应每个协议族的唯一后缀结尾。 1.1 IPv4套接字地址结构IPv4套接字地址结构以sockaddr_in命名，定义在&lt;netinet/in.h&gt;头文件中，POSIX定义如下： 1234567891011struct in_addr &#123; in_addr_t s_addr; // 32bit ipv4 address 网络字节序&#125;;struct sockaddr_in &#123; uint8_t sin_len; // 结构体长度 sa_family_t sin_family; // AF_INET in_port_t sin_port; // 16bit TCP/UDP port 网络字节序 struct in_addr sin_addr; // 32bit ipv4 address 网络字节序 char sin_zero[8]; // unused&#125;; sin_len字段不是所有厂家都支持的，且POSIX也不要求有这个成员。我们无需使用它，除非是路由套接字。 由处理来自不同协议族的套接字地址结构的例程，在内核中使用该字段。 POSIX规范只要求结构中的三个字段，sin_family、sin_addr和sin_port。 in_addr_t至少是32位无符号整数，in_port_t至少是16位无符号整数，sa_family_t通常是8位无符号整数，在不支持长度的字段的实现中，他是16位无符号整数。 32位IPv4地址存在两种不同的访问方法，假设serv是一个sockaddr_in数据 通过serv.in_addr，直接访问结构体 通过serv.in_addr.s_addr，直接访问in_addr_t 而IPv4地址是一个结构是因为早期版本将in_addr定义为多种结构的联合体，方便访问每一个字节，以便A、B、C类地址的处理。而现在不需要了。 sin_zero不适用，但是我们总是在使用sockaddr_in前，将整个结构置为0 1.2 通用套接字地址结构通用套接字地址结构定义在&lt;sys/socket.h&gt;头文件中，具体如下： 12345struct sockaddr &#123; uint8_t sa_len; sa_family_t sa_family; // 地址组:内容为AF_XXX char sa_data[14]; // 协议特定的地址 protocol-specific address&#125;; 所有套接字函数都需要将用于特定协议的套接字地址结构强制转换为通用套接字地址结构。 1.3 IPv6套接字地址结构IPv6套接字地址结构在&lt;netinet/in.h&gt;头文件中定义，如下： 1234567891011121314struct in6_addr &#123; uint8_t s6_addr[16]; // 128bit IPv6 address 网络字节序&#125;;#define SIN6_LEN // 编译时的测试需要struct sockaddr_in6 &#123; uint8_t sin6_len; sa_family_t sin6_family; // AF_INET6 in_port_t sin6_port; // 传输层端口 网络字节序 uint32_t sin6_flowinfo; // flow information 未定义 struct in6_addr sin6_addr; // IPv6 address 网络字节序 uint32_t sin6_scopr_id; // set of interface for a scope&#125;; IPv6的地址族是AF_INET6，IPv4是AF_INET 结构中字段的顺序，使得如果sockaddr_in6本身是64位对齐的，那么128位的sin6_addr字段也是64位对齐的。 sin6_flowinfo字段分成两个字段 低序20位是流标(flow label) 高序12位保留 如果地址由范围，sin6_scope_id标识出来。 1.4 新的通用套接字地址结构为了支持IPv6套接字API而定义的新的通用套接字结构地址，克服了原先的通用套接字结构地址的不足，且可以容纳几乎所有套接字，sockaddr_storage定义在&lt;netinet/in.h&gt;中，如： 1234struct sockaddr_storage &#123; uint8_t ss_len; sa_family_t ss_family;&#125;; sockaddr_storage可以满足最苛刻的对齐要求 sockaddr_storage足够大，可以容纳任何套接字地址结构 sockaddr_storage的其他字段对用户是透明的 1.5 套接字地址对比 2. 值-结果参数套接字API以指针形式接受一个套接字地址结构，并且接受该套接字地址的长度。不过地址长度的传递方式取决于套接字的传递方向，从进程到内核，还是从内核到进程。 从进程到内核传递的套接字API有三个：bind、connect和sendto。这些函数的一个参数是套接字指针，另一个是该套接字长度。于是内核知道了需要从进程中复制多少数据进来。 从内核到进程的套接字API是：accept、recvfrom、getsockname和getpeername。这四个函数中的两个参数是套接字指针和该套接字长度的指针。如： 12345struct sockaddr_un cli;socklen_t len;len = sizeof(cli);getpeername(unixfs, (SA*)&amp;cli, &amp;len); 这样是因为，函数调用时，内核写套接字时，可以读取该套接字长度；函数返回试，结构大小是一个结果，告诉对应进程，内核写了多少信息。这种类型阐述称为值-结果(value-result)参数。 3. 字节序转换函数 大端：低序的字节放在高地址 小端：低序的字节放在低地址 判断大小端函数： 123456789101112131415161718192021222324252627#include &lt;unpv13e/unp.h&gt;int main(int argc, char** argv) &#123; union &#123; short s; char c[sizeof(short)]; &#125; un; un.s = 0x0102; printf(&quot;%s: &quot;, CPU_VENDOR_OS); if (sizeof(short) == 2) &#123; if (un.c[0] == 1 &amp;&amp; un.c[1] == 2) &#123; printf(&quot;big endian\\n&quot;); &#125; else if (un.c[0] == 2 &amp;&amp; un.c[1] == 1) &#123; printf(&quot;little endian\\n&quot;); &#125; else &#123; printf(&quot;unknow\\n&quot;); &#125; &#125; else &#123; printf(&quot;sizeof(short) = %d\\n&quot;, sizeof(short)); &#125; exit(0);&#125; 网际协议使用大端来传递多字节整数。 主机字节序和网络字节序的转换由以下函数完成： 12345678#include &lt;netinet/in.h&gt;uint16_t htons(uint16_t host16bitvalue);uint32_t htonl(uint32_t host32bitvalue);uint16_t ntohs(uint16_t net16bitvalue);uint32_t ntoh1(uint32_t net32bitvalue);/* h 代表 host, n 代表 net, s 代表 short, l 代表 long */ 4. 字节操作函数操作字节的函数有两组，一组以b开头，源于4.2BSD，一组以mem开头，源于ANSI C 4.2BSD 1234#include &lt;string.h&gt;void bzero(void* dest, size_t nbytes);void bcopy(const void* src, void* dest, size_t nbytes);void bcmp(const void* ptr1, const void* ptr2, size_t nbytes); ANSI C 1234#include &lt;string.h&gt;void* memset(void* dest, int c, size_t nbytes);void* memcpy(const void* dest, void* stc, size_t nbytes); // 顺序和BSD相反void memcmp(const void* ptr1, const void* ptr2, size_t nbytes); 5. 地址转换函数地址转换函数，使得ASCII字符串与网络字节序的二进制值（套接字地址结构）之间转换。 两组函数的区别在于，第一组只适用于IPv4，第二组IPv4与IPv6都适用。 5.1 inet_aton、inet_addr和inet_ntoa该组函数在点分十进制数串与32位网络字节序二进制值之间转换IPv4地址。 12345678910#include &lt;arpa/inet.h&gt;// 返回值: 如果字符串有效返回1，否则返回0int inet_aton(const char* strptr, struct in_addr* addrptr);// 返回值: 若字符串有效，返回32位二进制网络字节序的IPv4地址，否则为INADDR_NONEin_addr_t inet_addr(const char* strptr);// 返回值: 点分十进制字符串char* inet_ntoa(struct in_addr inaddr) inet_aton，将strptr的字符串转换为32位网络字节序二进制值，成功返回1，否则返回0 inet_addr，将strptr的字符串转换为32位网络字节序二进制值。有一种情况，出错时返回INADDR_NONE，该常量通常是32位均为1的值，所以该函数不能处理255.255.255.255。 该函数已被废弃，应该使用inet_aton取代。 inet_ntoa，将32位网络字节序二进制值转换为对应的点分十进制字符串。该函数返回的字符串驻留在栈内存中。最后，该函数的参数是一个结构体，不是一个指针。 5.2 inet_pton和inet_ntop升级版函数，可以处理IPv4和IPv6，函数名p代表表达(presentation)，n代表数值(numeric)。 地址的表达格式是C字符串，数值格式是套接字地址结构的二进制值 1234567#include &lt;arpa/inet.h&gt;// 返回值: 成功返回1，若输入格式不是有效的，返回0，出错返回-1int inet_pton(int family, const char* strptr, void* addrptr);// 返回值: 成功返回只想结果的指针，出错则为NULLconst char* inet_ntop(int family, const void* addrptr, size_t len); family参数可以是AF_INET和AF_INET6。如果地址族参数不是这两个，两个函数都返回错误，将error置为EAFNOSUPPORT inet_pton，转换strptr指针所指字符串，结果存储到addrptr中。成功返回1，对于指定的family而言，如果字符串格式不对，返回0 inet_ntop，从数值格式转换到表达格式。len参数是目标存储区域的大小，以免缓冲区溢出。 这个len的大小，在&lt;netinet/in.h&gt;中有定义： 1234#include &lt;netinet/in.h&gt;#define INET_ADDRSTRLEN 16; // IPv4 点分十进制#define INET6_ADDRSTRLEN 46; // IPv6 16进制字符串 如果len太小，同拿不了表达格式结果，返回一个空指针，置errno为ENOSPC 5.3 地址转换函数小结 6.sock_ntop与相关函数inet_ntop的问题是：他要求调用者传递一个指向二进制地址的指针，而该地址通常包含在一个套接字地址结构中，所以需要弄清楚该结构的格式和地址族。如: 1234567// IPv4struct sockaddr_in addr;inet_ntop(AF_INET, &amp;addr.sin_addr, str, sizeof(str));// IPv6struct sockaddr_in6 addr6;inet_ntop(AF_INET6, &amp;addr6.sin6_addr, str, sizeof(str)); 此时，代码与协议相关。 为此，我们自己编写一个sock_ntop函数。 1234#include &quot;unp.h&quot;// 返回值: 成功则返回非空指针，出错返回NULLchar* sock_ntop(const struct sockaddr* sockaddr, socklen_t addrlen); 7. readn、writen和readline函数引入readn函数的目的在于： 字节流套接字的read和write函数会引出缓冲区问题。 套接字引入了两个缓冲区，分别为接收缓冲区和发送缓冲区，当我们调用read时，实际上是从接收缓冲区读到内存中。 然而，如果缓冲区快满了，剩余的大小不足n个字节，而我们read了n个字节。只能读取不满n个字节，read函数将返回一个正整数x，代表读取了x个字节。 下次调用read时，会阻塞在此处，直到缓冲区清空，且缓冲区内有数据可读时，被唤醒，进行read操作。 将read封装为readn，确保一定读取了n个字节。具体代码如下： 12345678910111213141516171819202122232425#include &quot;unp.h&quot;ssize_t readn(int fd, void* vptr, size_t n)&#123; size_t nleft; ssize_t nread; charr* ptr; ptr = vptr; nleft = n; while (nleft &gt; 0) &#123; if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123; if (errno = EINTR) &#123; // 后面会详细讨论 nread = 0; &#125; else &#123; return -1; &#125; &#125; else if (nread == 0) &#123; break; // 读取到EOF &#125; nleft -= nread; ptr += nread; &#125; return (n - nleft);&#125; writen引入的目的同readn。 readline函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;unp.h&quot;static int read_cnt;static char *read_ptr;static char read_buf[MAXLINE]; // 调用一次read，将数据读取到自己的缓冲区中// 每次只返回一个字符static ssize_t my_read(int fd, char *ptr)&#123; if(read_cnt &lt;= 0) &#123; again: if( (read_cnt = read(fd, read_buf, sizeof(read_buf)) &lt; 0) &#123; if (errno == EINTR) goto again; return(-1); &#125; else if (read_cnt == 0) &#123; return(0); &#125; read_ptr = read_buf; &#125; read_cnt--; *ptr = *read_ptr++; return (1);&#125; ssize_t readline(int fd, void *vptr, size_t maxlen)&#123; ssize_t n, rc; char c, *ptr; ptr = vptr; for (n = 1; n &lt; maxlen; n++) &#123; if ( (rc = my_read(fd, &amp;c)) == 1) &#123; *ptr++ = c; if (c == &#x27;\\n&#x27;) break; &#125; else if (rc == 0) &#123; *ptr = 0; return(n-1); &#125; else return(-1); &#125; *ptr = 0; return(n);&#125; ssize_t readlinebuf(void** vptrptr)&#123; if (read_cnt) &#123; *vptrptr = read_ptr; &#125; return read_cnt;&#125; my_read每次最多都MAXLINE个字符，但是每次返回一个字符 readlinebuf展示内部缓冲区的状态。 使用静态变量维护信息，结果是这些函数非线程安全","categories":[{"name":"unp","slug":"unp","permalink":"http://example.com/categories/unp/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"apue_2.unix标准及实现","slug":"apue-2-unix标准及实现","date":"2021-01-31T13:54:50.000Z","updated":"2021-01-31T14:29:54.790Z","comments":true,"path":"2021/01/31/apue-2-unix标准及实现/","link":"","permalink":"http://example.com/2021/01/31/apue-2-unix%E6%A0%87%E5%87%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"1. Unix标准与实现Unix标准是不同组织对C程序的库函数设计而提出的规范，主要有以下几种： ISO C IEEE POSIX Single UNIX Specification FIPS Unix实现是对上述标准的提出的接口规范的具体实现，主要有： SVR4 4.4BSD FreeBSD Linux Mac OS X Solaris 2. 限制Unix系统已经定义了很多幻数和常数。为了改善Unix程序的可移植性，有许多方法用于限制这些幻数和常数的定义，以下两种类型的限制是必须的： 编译时限制，如：整型的最大值 运行时限制，如：文件名有多少个字符 编译时限制通常包含在头文件里，程序编译时，包括这些头文件即可。 运行时限制则需要进程调用其他函数来确定。 而限制在某些实现中是固定的，可以从头文件中静态确定。在另外的实现中是动态的，需要运行函数来确定。为了解决这类问题，有三种方法： 编译时限制（头文件） 与文件或目录无关的运行时限制（sysconf函数） 与文件或目录有关的运行时限制（pathconf函数和fpathconf函数） 2.1 ISO C 限制ISO C定义的所有编译时限制全部放在&lt;limits.h&gt;中。定义了一些类型的范围。 &lt;stdio.h&gt;定义了一些 ISO C常量： FOPEN_MAX，可同时打开的标准IO流的最小个数 TMP_MAX，有tmpname函数产生的唯一文件名的最大个数 FILENAME_MAX，避免使用，因为POSIX提供了更好的 2.2 POSIX 限制POSIX的限制和常量主要分为7类： 数值限制：LONG_BIT、SSIZE_MAX和WORD_BIT 最小值： 这些最小值不会随着系统而变化。POSIX.1的实现都需要提供至少这么大的值。 最大值：_POSIX_CLOCKRES_MIN 运行时可以增加的值：CHARCLASS_NAME_MAX COLL_WEIGHTS_MAX LINE_MAX NGROUPS_MAX RE_DUP_MAX 运行时不变值（可能不确定）： 其他不变值：NL_ARGMAX NL_MSGMAX NL_SETMAX NL_TEXTMAX 路径可变值：FILESIZEBITS LINK_MAX MAX_CANON MAX_INPUT NAME_MAX PATH_MAX PIPE_BUF SYMLINK_MAX 2.3 XSI 限制 最小值： 运行时不变值（可能不确定）：IOV_MAX PAGE_SIZE 2.4 函数 sysconf、pathconf和fpathconf1234567#include &lt;unistd.h&gt;long sysconf(int name);long pathconf(const char *pathname, int name);long fpathconf(int fd, int name); 三个函数的name参数都用来标识系统限制，但是种类有所不同 sysconf的name参数以_SC_开头 pathconf和fpathconf的name参数以_PC_开头 三个函数的返回值情况如下 如果name参数不是一个合适的常量，三个函数都返回-1，并将errno置为EINVAL 部分name参数会返回一个变量值(&gt;= 0)，或提示该值是不确定的。不确定通过返回-1标识，但是不改变errno _SC_CLK_TCK的返回值是每秒的时钟滴答数，用于times函数的返回值 对于pathconf的参数pathname和fpathconf的参数fd来说，有很多限制。其中一条不满足，产生未定义的结果 _PC_MAX_CANON和_PC_MAX_INPUT引用的文件必须是终端文件 _PC_LINK_MAX和_PC_TIMESTAMP_RESOLUTION引用的文件可以是文件或目录。如果是目录，返回值仅仅用于目录，不涉及目录内的文件 _PC_FILESIZEBITS和_PC_NAME_MAX引用的文件必须是目录，返回值用于该目录内的文件名 _PC_PATH_MAX引用的文件必须是目录。当引用的是工作目录时，返回为相对路径的最大字节名 _PC_PIPE_BUF引用的文件必须是管道、FIFO或目录。 管道或FIFO，返回值是引用的管道或FIFO的限制 目录，返回值是在该目录中创建任一FIFO的限制值 _PC_SYNLINK_MAX引用的文件必须是目录。返回值用于该目录中符号链接可包含的字符串最大值 2.5 不确定的运行时限制运行时限制一般是不确定的，在使用时需要动态获取这些信息，通常使用上述三个函数之一来获取。 3. 功能测试宏头文件定义了很多符号，大多数实现也添加了自己的符号。但是如果只希望使用POSIX的符号，且不与任何实现的定义起冲突，需要定义常量_POSIX_C_SOURCE。 该常量称为功能测试宏，所有的功能测试宏都以下划线开头。使用时，格式如下： 123cc -D_POSIX_C_SOURCE&#x3D;200809L file.c&#x2F;&#x2F; 也可在头文件第一行加上#define _POSIX_C_SOURCE 200809L 4. 基本系统数据类型&lt;sys/types.h&gt;中定义了一些基本系统数据类型，绝大多数以_t结尾。","categories":[{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"}]},{"title":"apue_1.unix基础知识","slug":"apue-1-unix基础知识","date":"2021-01-31T13:51:04.000Z","updated":"2021-01-31T14:09:28.221Z","comments":true,"path":"2021/01/31/apue-1-unix基础知识/","link":"","permalink":"http://example.com/2021/01/31/apue-1-unix%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"1. Unix体系结构内核：控制硬件，提供程序运行环境。 系统调用：内核的接口，公用函数库建立在系统调用之上 shell：特殊的应用程序，为其他应用程序提供接口 2. 登录2.1 登录名登录名信息在口令文件中（通常在/etc/passwd文件）查看。 登录项又冒号隔开的7个字段组成，分别为： 登录名 加密口令 数字用户ID 数字组ID 注释字段 起始目录 shell程序，系统启动后运行的shell的路径 2.2 shellshell即命令行解释器，读取输入，执行命令，可以从终端或者文件中获取输入。 根据用户项中的信息，启动对应的shell。 3. 文件和目录3.1 文件名文件名中不能出现左斜杠/和空格。左斜杠是路径名中的一部分，空格是用来终止路径名。 推荐使用字母、数字、句点、短横线和下划线。 在创建新目录时，同时创建了两个文件名：点.和点点.. .点：指向当前目录 ..点点：指向父目录 3.2 路径名以斜线开头的为绝对路径，否则为相对路径。 3.3 工作目录每个进程都有个工作目录，所有相对路径前都会加上工作目录，进程可以使用chdir函数更改工作目录 3.4 起始目录登陆后，工作目录设置为起始目录，起始目录在登录项中可以取地 4. 输入和输出4.1 文件描述符文件描述符通常是一个小的非负整数，内核用以标识特定进程访问的文件。 4.2 标准输入、标准输出、标准错误运行一个程序时，shell为其打开三个文件描述符，即标准输入、标准输出和标准错误。一般，这三个描述符都链接到终端。 可以通过重定向来使得三个描述符定向到某个文件 4.3 不带缓冲的IO函数open、read、write、lseek和close提供了不到缓冲的IO 4.4 标准IO标准IO为不带缓冲的IO提供了一个带缓冲的接口。简化了对输入行的处理 5. 程序和进程5.1 程序程序是存储在磁盘某个目录上的可执行文件，内核使用exec函数，将程序读入内存，执行程序。 5.2 进程程序的执行实例被称为进程，每个进程都有唯一的标识符，称为进程ID，总是一个非负整数。 5.3 进程控制主要有三个函数进行进程控制：fork、exec和waitpid 5.4 线程和线程ID 通常，一个进程只有一个线程——某一时刻执行的一组机器指令。但是可以通过额外设置线程来解决问题。 一个进程内的所有线程可以共享同一地址空间、文件描述符、栈以及进程属性。 线程也有线程ID，但是仅仅是对于该进程，对于另外的进程，该进程的线程ID没有意义。 6. 出错处理Unix系统函数出错时，通常返回一个负值，且整型变量errno设置为具有特定信息的值。 &lt;errno.h&gt;中定义了errno及其常值。这些常值都以E开头。 POSIX和ISO C都将errno设置为一个可修改的整型左值。在多线程中，每个线程都有自己的局部errno，避免干扰， 在linux中，errno定义如下： 12extern int *__errno_location(void);#define errno (*__errno_location()); errno的使用注意以下两点 如果没有出错，errno的值不会被清除。因此只在出错时检测errno的值 任何函数都不会将errno的值设为0，且所有errno的常值也不为0 C标准定义了两个函数用于打印出错信息 #include &lt;string.h&gt; char *strerror(int errnum); 1234567 &#96;strerror&#96;将&#96;errno&#96;值映射为一个字符串，并返回字符串指针- &#96;&#96;&#96;c #include &lt;stdio.h&gt; void perror(const char *msg); `perror`函数基于`errno`的当前值，在标准错误输出一条出错信息，然后返回。 首先输出`msg`指向的信息，一个冒号一个空格，接着是`errno`对应的出错信息，最后是换行符。 6.1 出错恢复错误有两类：致命性的和非致命性的。 致命性错误无法恢复，输出一条出错信息后就退出 资源短缺相关的错误通常是非致命性的，常见的恢复方法有，隔段时间后重新访问 7. 用户表示7.1 用户ID用户ID是一个数值，唯一的标识每一个用户，且用户不可更改其用户ID。 7.2 组ID组ID是由系统管理员在用户登陆时分配的，多个用户可以有相同的组ID。组ID可以将用户划分为各个部门、项目中，可以设置权限，使得这一组的用户有权限访问文件。 组文件将组名映射到数值，文件路径通常为/etc/group。 7.3 附属组ID除了组ID为，用户还可以属于另外一些组。 8. 信号信号用于通知进程发生的情况，进程的信号处理的方式有三种： 忽略。但是有些异常，如地址错误等，结果不确定，所以不推荐忽略信号 按照默认方法处理。如除0，系统默认终止进程 提供函数，信号发生时调用。 键盘产生信号的方法有两种： 中断键，中断当前运行进程，ctrl+c 退出键，终端当前运行进程，ctrl+/ 9. 时间值有两种不同的时间值 日历时间，从1970年1月1日00:00:00到现在经过的秒数。 time_t保存这种时间值 进程时间，度量进程使用CPU资源的时间。clock_t保存这种时间值 在度量一个进程的执行时间时，系统为进程维护了3个时间 时钟时间，又称为墙上时钟时间，是进程运行的时间总量，值与系统中同时运行的进程数有关。 用户CPU时间，执行用户指令的时间。 系统CPU时间，进程执行内核程序所经过的时间。 10. 系统调用和库函数Unix中的每个系统调用在标准C库中设置了一个具有相同名字的函数。用户使用标准C库中的函数，函数使用系统要求的技术调用相应的内核服务。 系统调用和库函数的异同： 系统调用和库函数都是以C函数的形式给出 系统调用通常不可以被替换，库函数是可以替换的 如，可以使用malloc实现内存分配，但并不是唯一的方式，Unix系统中实现内存分配的系统调用为sbrk，用户也可以自定义malloc函数，不去调用库函数。","categories":[{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"}]},{"title":"创建型模式-原型模式","slug":"创建型模式-原型模式","date":"2020-11-30T14:19:34.000Z","updated":"2021-01-30T02:02:43.590Z","comments":true,"path":"2020/11/30/创建型模式-原型模式/","link":"","permalink":"http://example.com/2020/11/30/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"5、原型模式5.1 原型模式概述**原型模式(Prototype Pattern)**：使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。原型模式是一种对象创建型模式。 工作原理：将一个原型对象传给那个要创建的对象，这个要创建的对象通过请求原型对象克隆自己来实现创建过程 原型模式结构图中包含3个角色： **Prototype(抽象原型类)**：它是声明克隆方法的接口，是所有具体原型类的父类，可以抽象类、接口，还可以是具体实现类。 **ConcretePrototype(具体原型类)**：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 **Client(客户类)**：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。 下面将介绍两种在Java语言中常用的克隆实现方法： 通用实现法 通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传人新创建的对象中，保证它们的成员变量相同。示意代码如下： 12345678910111213141516171819202122232425262728293031#ifndef PROTOTYPE_H#define PROTOTYPE_Hclass Prototype &#123;public: virtual ~Prototype() &#123;&#125; virtual Prototype* Clone() = 0;&#125;;#endif // PROTOTYPE_H#ifndef CONCRETE_PROTOTYPE_H#define CONCRETE_PROTOTYPE_H#include &quot;prototype.h&quot;class ConcretePrototype : public Prototype &#123;public: ConcretePrototype() &#123;&#125; ConcretePrototype(const ConcretePrototype* other) &#123;&#125; virtual ~ConcretePrototype() &#123;&#125; virtual Prototype* Clone() override &#123; return new ConcretePrototype(*this); &#125;&#125;;#endif // CONCRETE_PROTOTYPE_H 在客户类中，只需要创建一个ConcretePrototype对象作为原型对象，然后调用其clone()方法即可得到对应的克隆对象，代码如下： 12345678910#include &lt;cassert&gt;#include &quot;concrete_prototype.h&quot;int main() &#123; Prototype* objl = new ConcretePrototype(); Prototype* obj2 = objl-&gt;Clone(); assert(objl != obj2);&#125; 这种方法可作为原型模式的通用实现，它与编程语言特性无关，任何面向对象语言都可以使用这种形式来实现对原型的克隆。 在原型模式复制时，需要注意浅复制和深复制。 5.2 原型管理器的引入和实现**原型管理器(Prototype Manager)**是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以便扩展。 具体实例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//抽象公文接口，也可定义为抽象类，提供clone()方法的实现,将业务方法声明为抽象方法#ifndef OFFICIAL_DOCUMENT_H#define OFFICIAL_DOCUMENT_Hclass OfficialDocument &#123;public: virtual ~OfficialDocument() &#123;&#125; virtual OfficialDocument* Clone() = 0; virtual void Display() = 0;&#125;;#endif // OFFICIAL_DOCUMENT_H//可行性分析报告(Feasibility Analysis Report)类#ifndef FAR_H#define FAR_H#include &lt;iostream&gt;#include &quot;official_document.h&quot;class Far : public OfficialDocument &#123;public: Far() &#123;&#125; Far(const Far&amp;) &#123;&#125; virtual ~Far() &#123;&#125; virtual OfficialDocument* Clone() override &#123; return new Far(*this); &#125; virtual void Display() override &#123; std::cout &lt;&lt; &quot;&lt;可行性分析报吿&gt;&quot; &lt;&lt; std::endl; &#125;&#125;;#endif // FAR_H//软件需求规格说明书(Software Requirements Specification)类#ifndef SAS_H#define SAS_H#include &lt;iostream&gt;#include &quot;official_document.h&quot;class Sas : public OfficialDocument &#123;public: Sas() &#123;&#125; Sas(const Sas&amp;) &#123;&#125; virtual ~Sas() &#123;&#125; virtual OfficialDocument* Clone() override &#123; return new Sas(*this); &#125; virtual void Display() override &#123; std::cout &lt;&lt; &quot;&lt;软件需求规格说明书&gt;&quot; &lt;&lt; std::endl; &#125;&#125;;#endif // SAS_H//原型管理器(使用饿汉式单例实现)#ifndef PROTOTYPE_MANAGER_H#define PROTOTYPE_MANAGER_H#include &lt;string&gt;#include &lt;map&gt;#include &quot;far.h&quot;#include &quot;sas.h&quot;class PrototypeManager &#123;public: PrototypeManager() &#123; m_ht[&quot;far&quot;] = new Far(); m_ht[&quot;sas&quot;] = new Sas(); &#125; PrototypeManager(const PrototypeManager&amp;) = delete; PrototypeManager&amp; operator=(const PrototypeManager&amp;) = delete; ~PrototypeManager() &#123;&#125; //增加新的公文对象 void AddOfficialDocument(std::string key, const OfficialDocument* doc) &#123; m_ht[key] = const_cast&lt;OfficialDocument*&gt;(doc)-&gt;Clone(); &#125; //通过浅克隆获取新的公文对象 OfficialDocument* GetOfficialDocument(std::string key) &#123; return m_ht[key]-&gt;Clone(); &#125; static PrototypeManager* GetPrototypeManager() &#123; return &amp;ms_pm; &#125;private: std::map&lt;std::string, OfficialDocument*&gt; m_ht; static PrototypeManager ms_pm;&#125;;PrototypeManager PrototypeManager::ms_pm;#endif // PROTOTYPE_MANAGER_H// 客户端代码如下#include &lt;cassert&gt;#include &quot;prototype_manager.h&quot;int main() &#123; PrototypeManager* pm = PrototypeManager::GetPrototypeManager(); OfficialDocument* doc1, *doc2, *doc3, *doc4; doc1 = pm-&gt;GetOfficialDocument(&quot;far&quot;); doc1-&gt;Display(); doc2 = pm-&gt;GetOfficialDocument(&quot;far&quot;); doc2-&gt;Display(); assert(doc1 != doc2); doc3 = pm-&gt;GetOfficialDocument(&quot;sas&quot;); doc3-&gt;Display(); doc4 = pm-&gt;GetOfficialDocument(&quot;sas&quot;); doc4-&gt;Display(); assert(doc3 != doc4);&#125; 5.3 总结原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中应用较为广泛，很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的典型应用。 5.3.1 优点 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 扩展性较好。由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少具体原型类对原有系统都没有任何影响。 原型模式提供了简化的创建结构。工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。 可以使用深克隆的方式保存对象的状态。使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，例如恢复到某一历史状态，可辅助实现撤销操作。 5.3.2 缺点 需要为每个类配备一个克隆方法，而且该克隆方法位于类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则。 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 5.3.3 适用场景 创建新对象成本较大（例如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式（来实现。 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式-抽象工厂模式","slug":"创建型模式-抽象工厂模式","date":"2020-11-21T09:28:52.000Z","updated":"2021-01-30T02:02:22.210Z","comments":true,"path":"2020/11/21/创建型模式-抽象工厂模式/","link":"","permalink":"http://example.com/2020/11/21/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"4、抽象工厂模式4.1 产品等级结构与产品族产品等级结构 产品等级结构即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 示意图如下 同一形状的物品构成了一个产品等级结构，而同一种颜色的物品因为其厂家相同，由同一个工厂生成，所以是一个产品族。 4.2 抽象工厂模式概述抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比， 抽象工厂模式中的具体工厂不只是创建一种产品， 它负责创建一族产品。抽象工厂模式定义如下： **抽象工厂模式(Abstract Factory Pattern)**：提供一个创建一系列相关或相互依赖的对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。 抽象工厂模式结构图中包含以下4个角色： **AbstractFactory(抽象工厂)**：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 **ConcreteFactory(具体工厂)**：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 **AbstractProduct(抽象产品)**：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 **ConcreteProduct(具体产品)**：它定义具体工厂生产的具体产品对象，实现在抽象产品接口中声明的业务方法。 抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下： 123456789class Truck;class Car;class AbstractFactory &#123;public: virtual Truck* GetTruck() = 0; virtual Car* GetCar() = 0;&#125;; 具体工厂实现了抽象工厂， 每一个具体的工厂方法可以返回一个特定的产品对象，一个具体工厂所创建的产品对象构成了一个产品族。 1234567891011121314151617181920212223242526272829303132333435class BmwFactory : public AbstractFactory &#123;public: virtual Truck* GetTruck() override &#123; return new BmwTruck; &#125; virtual Car* GetCar() override &#123; return new BmwCar; &#125;&#125;;class BenzFactory : public AbstractFactory &#123;public: virtual Truck* GetTruck() override &#123; return new BenzTruck; &#125; virtual Car* GetCar() override &#123; return new BenzCar; &#125;&#125;;class BenzTruck : public Truck &#123;public: virtual void SameMethod() override &#123; std::cout &lt;&lt; &quot;I am benz truck\\n&quot;; &#125;&#125;;class BenzCar : public Car &#123;public: virtual void SameMethod() override &#123; std::cout &lt;&lt; &quot;I am benz car\\n&quot;; &#125;&#125;; 4.3 开闭原则的倾斜性抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为开闭原则的倾斜性。 如，需要在按钮中增加一个radioButton，则需要在抽象工厂和具体工厂中逐一修改代码，违反开闭原则。 增加产品族。对于增加新的产品族，抽象工厂模式很好地支持了开闭原则，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。 增加产品等级结构。对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了开闭原则。 正因为抽象工厂模式存在开闭原则的倾斜性，因此要求设计人员在设计之初就能够全面考虑，产品等级结构不会再日后的维护总发生变化。 4.4 总结4.4.1 优点 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了在抽象工厂中声明的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。因为只用了一个工厂创建。 增加新的产品族很方便，无须修改已有系统，符合开闭原则。 4.4.2 缺点增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则。 4.4.3 适用场景 系统中有多于一个的产品族，而每次只使用其中某一产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束。例如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式-工厂模式","slug":"创建型模式-工厂模式","date":"2020-11-21T09:06:21.000Z","updated":"2021-01-30T02:02:34.151Z","comments":true,"path":"2020/11/21/创建型模式-工厂模式/","link":"","permalink":"http://example.com/2020/11/21/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"3、工厂模式3.1 工厂模式概述工厂方法模式(Factory Method Pattern)**：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual ConstructorPattern)或多态工厂模式(Polymorphic Factory Pattern)**。工厂方法模式是一种类创建型模式。 工厂模式包含四个角色 **Product(抽象产品)**：定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的父类。 **ConcreteProduct(具体产品)**：它实现了抽象产品接口，具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 Factory(抽象工厂)**：在抽象工厂类中，声明了工厂方法(Factory Method)**，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 **ConcreteFactory(具体工厂)**：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 具体实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//日志记录器接口：抽象产品class Logger &#123;public: virtual void Log() = 0;&#125;;//数据库日志记录器：具体产品class DatabaseLogger : public Logger &#123;public: virtual void Log() override &#123; std::cout &lt;&lt; &quot;database log\\n&quot;; &#125;&#125;;//文件日志记录器：具体产品class FileLogger : public Logger &#123;public: virtual void Log() override &#123; std::cout &lt;&lt; &quot;file log\\n&quot;; &#125;&#125;;//日志记录器工厂接口：抽象工厂// 使用前置声明减少头文件依赖class Logger;class Factory &#123;public: virtual Logger* GetLogger() = 0;&#125;;//数据库日志记录器工厂类：具体工厂class DatabaseLoggerFactory : public Factory &#123;public: virtual Logger* GetLogger() override &#123; return new DatabaseLogger; &#125;&#125;;//文件日志记录器工厂类：具体工厂class FileLoggerFactory : public Factory &#123;public: virtual Logger* GetLogger() override &#123; return new FileLogger; &#125;&#125;;// 客户端代码使用如下：int main(int argc, char* argv[]) &#123; Factory* factory; Logger* log; factory = new DatabaseLoggerFactory; log = factory-&gt;GetLogger(); log-&gt;Log();&#125; 3.2 工厂方法的隐藏可在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。 12345678910111213141516class Factory &#123;public: virtual Logger* GetLogger() = 0; virtual void Log() &#123; Logger* logger = this-&gt;GetLogger(); logger-&gt;Log(); delete logger; &#125;&#125;;int main(int argc, char* argv[]) &#123; Factory* factory; factory = new FileLoggerFactory; factory-&gt;Log();&#125; 将业务方法移入工厂类，可以直接使用工厂对象来调用产品对象的业务方法，客户端无须直接使用工厂方法。 3.3 总结3.3.1 优点 在工厂模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加人新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。可扩展性好，完全符合开闭原则。 3.3.2 缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，类的个数将成对增加，增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。 3.3.3 适用场景 客户端不知道其所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式-简单工厂模式","slug":"创建型模式-简单工厂模式","date":"2020-11-19T10:53:52.000Z","updated":"2021-01-30T02:02:38.602Z","comments":true,"path":"2020/11/19/创建型模式-简单工厂模式/","link":"","permalink":"http://example.com/2020/11/19/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"2、简单工厂模式2.1 简单工厂模式概述简单工厂模式并不属于23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下： 首先将需要创建的各种不同对象的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传人相应的参数即可得到一个产品对象。 简单工厂模式(Simple Factory Pattern)**：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法， 因此简单工厂模式又被称为静态工厂方法(StaticFactory Method)**模式，它属于类创建型模式。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 在简单工厂模式结构图中包含以下3个角色。 Factory(工厂角色)：即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。 Product(抽象产品角色)：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引人将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。 ConcreteProduct(具体产品角色)：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#ifndef PRODUCT_H#define PRODUCT_Hclass Product &#123;public: // 所有类公共的方法 void SameMethod() &#123;&#125; // 所有子类的抽象方法 virtual void DiffMethod() = 0;&#125;;#endif // PRODUCT_H#ifndef CONCRETE_PRODUCT_H#define CONCRETE_PRODUCT_H#include &lt;iostream&gt;#include &quot;product.h&quot;class ConcreteProduct : public Product &#123;public: ConcreteProduct() &#123;&#125; ~ConcreteProduct() &#123;&#125; virtual void DiffMethod() override &#123; std::cout &lt;&lt; &quot;I am working!\\n&quot;; &#125;&#125;;#endif // CONCRETE_PRODUCT_H#ifndef FACTORY_H#define FACTORY_H#include &quot;product.h&quot;#include &quot;concerate_product.h&quot;class Factory &#123;public: // 产品用enum声明 static Product* GetProduct(int product_type) &#123; switch (product_type) &#123; case 0: return new ConcreteProduct; break; default: return nullptr; break; &#125; &#125;&#125;;#endif // FACTORY_H#include &quot;product.h&quot;#include &quot;concerate_product.h&quot;#include &quot;factory.h&quot;int main(int argc, char* argv[]) &#123; Product* product = Factory::GetProduct(0); product-&gt;DiffMethod(); delete product;&#125; 2.2 简单工厂模式的简化可以将抽象产品类和工厂类合并，将静态工厂方法放到抽象产品类中，如图： 2.3 总结2.3.1 优点 工厂类可包含判断逻辑，决定创建哪个产品类；使用者直接使用对象，无需创建。简单工厂模式实现了对象创建和使用的分离。 使用者无须知道产品类的类名，简单工厂模式可以在一定程度减少使用者的记忆量。 配置文件(java)，可以在不修改代码的情况下更换和增加新的产品类，提高了系统的灵活性。 2.3.2 缺点 工厂类集中了所有产品的创建逻辑，职责重，一旦不能正常工作，整个系统都要受到影响。 简单工厂模式会增加系统中类的个数(引入新的工厂类)，增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品需要修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 2.3.3 适用场景 工厂类负责创建的对象比较少，由于创建的对象较少，工厂方法中的业务逻辑不会复杂。 使用者只知道传入工厂类的参数，对于如何创建对象并不关心。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式--单例模式","slug":"创建型模式-单例模式","date":"2020-11-17T07:16:46.000Z","updated":"2021-01-30T02:02:28.824Z","comments":true,"path":"2020/11/17/创建型模式-单例模式/","link":"","permalink":"http://example.com/2020/11/17/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"1、单例模式1.1 单例模式概述**单例模式(Singleton Pattern)**：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。 单例模式有3个要点： 某个类只能有一个实例 它必须自行创建这个实例 它必须自行向整个系统提供这个实例 单例模式UML图如下： 在单例类的内部只生成一个实例， 同时它提供一个静态的GetInstance()方法，让客户可以访问它的唯一实例；为了防止在外部对单例类实例化，它的构造函数可见性为private；在单例类内部定义了一个Singleton类型的静态对象，作为供外部共享访问的唯一实例。 1.2 可能存在的问题当第一次调用getInstance()方法创建对象，instance对象为null值，因此系统将执行代码instance = newInstance()，在此过程中，如果对象的创建需要做很大量初始化工作，则需要一段时间创建对象。而在此时，如果在此调用getInstance()(多线程)，则会多次创建对象，引发错误。 1.3 饿汉式单例和懒汉式单例1.3.1 饿汉式单例","text":"1、单例模式1.1 单例模式概述**单例模式(Singleton Pattern)**：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。 单例模式有3个要点： 某个类只能有一个实例 它必须自行创建这个实例 它必须自行向整个系统提供这个实例 单例模式UML图如下： 在单例类的内部只生成一个实例， 同时它提供一个静态的GetInstance()方法，让客户可以访问它的唯一实例；为了防止在外部对单例类实例化，它的构造函数可见性为private；在单例类内部定义了一个Singleton类型的静态对象，作为供外部共享访问的唯一实例。 1.2 可能存在的问题当第一次调用getInstance()方法创建对象，instance对象为null值，因此系统将执行代码instance = newInstance()，在此过程中，如果对象的创建需要做很大量初始化工作，则需要一段时间创建对象。而在此时，如果在此调用getInstance()(多线程)，则会多次创建对象，引发错误。 1.3 饿汉式单例和懒汉式单例1.3.1 饿汉式单例 1234567891011121314151617181920212223242526272829303132333435363738394041424344// EagerSingleten.h/******************************************************* * author : Cytify * date : 20201117 22:33 * version : 1.0 * desc : 饿汉单例*******************************************************/#ifndef eager_singleton_h_#define eager_singletn_h_class EagerSingleton &#123;public: static EagerSingleton* GetInstance() &#123; return ms_instance; &#125; void Delete(); private: EagerSingleton(); ~EagerSingleton(); EagerSingleton(const EagerSingleton&amp; signal); const EagerSingleton&amp; operator=(const EagerSingleton&amp; signal); static EagerSingleton* ms_instance;&#125;;#endif// EagerSingleten.cpp#include &quot;EagerSingleton.h&quot;// 初始化ms_instanceEagerSingleton* EagerSingleton::ms_instance = new EagerSingleton();void EagerSingleton::Delete() &#123; if (ms_instance) &#123; delete ms_instance; ms_instance = nullptr; &#125;&#125; 当类被加载时，静态变量ms_instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。 1.3.2 懒汉式单例 懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为**延迟加载(Lazy Load)**技术，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/******************************************************* * author : Cytify * date : 20201119 18:38 * version : 1.0 * file : lazy_singleton * desc : 加锁的懒汉单例*******************************************************/#ifndef LAZY_SINGLETON_H#define LAZY_SINGLETON_H#include &lt;mutex&gt;class LazySingleton &#123;public: static LazySingleton* GetInstance(); static void DeleteInstance();private: LazySingleton(); ~LazySingleton(); LazySingleton(const LazySingleton&amp;); const LazySingleton&amp; operator=(const LazySingleton&amp;); static LazySingleton* ms_instance; static std::mutex ms_mutex;&#125;;#endif // LAZY_SINGLETON_H/******************************************************* * author : Cytify * date : 20201119 18:39 * version : 1.0 * file : lazy_singleton.cpp * desc : 实现lazy_singleton.h*******************************************************/#include &quot;lazy_singleton.h&quot;LazySingleton* LazySingleton::ms_instance = nullptr;std::mutex LazySingleton::ms_mutex;LazySingleton* LazySingleton::GetInstance() &#123; // 使用双重检查锁的机制，只在判断指针为空的情况下才加锁 // 在多线程的情况下，这样可以减少开销 if (ms_instance = nullptr) &#123; // 使用unique_lock，类似于使用智能指针 std::unique_lock&lt;std::mutex&gt; lock(ms_mutex); if (ms_instance == nullptr) &#123; ms_instance = new (std::nothrow)LazySingleton(); &#125; &#125; return ms_instance;&#125;void LazySingleton::DeleteInstance() &#123; std::unique_lock&lt;std::mutex&gt; lock(ms_mutex); // 加锁 if (ms_instance) &#123; delete ms_instance; ms_instance = nullptr; &#125;&#125; 另一种实现方式 12345678910111213141516171819class LazySingleton &#123; private volatile static LazySingleton instance = null; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; //第一重判断 if (instance == null) &#123; //锁定代码块 synchronized (LazySingleton.class) &#123; //第二重判断 if (instance == null) &#123; instance = new LazySingleton(); //创建单例实例 &#125; &#125; &#125; return instance; &#125;&#125; 1.3.3 饿汉式单例类与懒汉式单例类比较饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。 但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。 懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理多线程，特别是当单例类实例化时涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的几率变得较大， 需要通过双重检查锁定等机制进行控制， 这将导致系统性能受到一定影响。 1.4 较好的单例实现方法123456789101112131415161718192021222324252627282930313233343536373839/******************************************************* * author : Cytify * date : 20201119 18:38 * version : 1.0 * file : lazy_singleton * desc : 局部静态变量的懒汉单例*******************************************************/#ifndef LAZY_SINGLETON_H#define LAZY_SINGLETON_Hclass LazySingleton &#123;public: static LazySingleton* GetInstance();private: LazySingleton(); ~LazySingleton(); LazySingleton(const LazySingleton&amp;); const LazySingleton&amp; operator=(const LazySingleton&amp;);&#125;;#endif // LAZY_SINGLETON_H/******************************************************* * author : Cytify * date : 20201119 18:39 * version : 1.0 * file : lazy_singleton.cpp * desc : 实现lazy_singleton.h*******************************************************/#include &quot;lazy_singleton.h&quot;LazySingleton* LazySingleton::GetInstance() &#123; static LazySingleton lazy_singleton; return &amp;lazy_singleton;&#125; 这种方法代码少，无加锁，且能保证线程安全。 1.5 总结1.5.1 优点 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。 由于在只存在一个对象，可节约系统资源，对于一些需要频繁创建和销毁的对象，可以提高系统的性能。 可以获得多个对象。进行扩展，获得指定个数的实例对象，既节省系统资源，又解决了由于单例对象共享过多有损性能的问题。 1.5.2 缺点 单例模式没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了单一职责原则。因为单例类既提供了业务方法， 又提供了创建对象的方法(工厂方法) ， 将对象的创建和对象本身的功能耦合在一起。 自动垃圾回收技术可能会自动销毁并回收资源，这将导致共享的单例对象状态的丢失。 1.5.3 适用场景 系统只需要一个实例对象。如，系统要求提供一个唯一的序列号生成器或资源管理器，或资源消耗太大而只允许创建一个对象。 类的单个实例只在某一个地方被使用，除此之外，不会再其他地方调用。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"对象模型-4.函数","slug":"cpp-对象模型-第四章-函数","date":"2020-11-17T06:42:00.000Z","updated":"2021-01-30T02:01:15.309Z","comments":true,"path":"2020/11/17/cpp-对象模型-第四章-函数/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%87%BD%E6%95%B0/","excerpt":"1. 成员函数的调用1.1 非静态成员函数(Nonstaic Member Function)成员函数会经过编译器转换为非成员函数： 改变函数的声明，新增一个额外参数，用于访问类内的数据和函数。 123456class Point3d;// non-constPoint3d Point3d::Magnitude(); -&gt; Point3d Point3d::Magnitude(Point3d *const this);// constPoint3d Point3d::Magnitude() const; -&gt; Point3d Point3d::Magnitude(const Point3d *const this); 对成员的访问操作变为this指针的访问 转换函数名称——mangling方法(第三章数据部分提到，用于转换static变量名) 转换后，函数的调用也需要被转换 1234567class Point3d;Point3d obj;Point3d *ptr = new Point3d;// 假设Magnitude名称转换为Magnitude_7Point3dFvobj.Magnitude(); -&gt; Magnitude_7Point3dFv(&amp;obj);ptr-&gt;Magnitude(); -&gt; Magnitude_7Point3dFv(ptr); 假设有如下代码： 1234567891011Point3d Point3d::Normalize() const &#123; register float msg = Magnitude(); return Point3d( x_/msg, y_/msg, z_/msg);&#125;// 经过转换，以及NRV优化void Normalize_7Point3dFv(register const Point3d* const this, Point3d&amp; _result) &#123; register float msg = this-&gt;Magnitude(); _result.Point3d::Point3d(this-&gt;x_/msg, this-&gt;y_/msg, this-&gt;z_/msg); return;&#125;","text":"1. 成员函数的调用1.1 非静态成员函数(Nonstaic Member Function)成员函数会经过编译器转换为非成员函数： 改变函数的声明，新增一个额外参数，用于访问类内的数据和函数。 123456class Point3d;// non-constPoint3d Point3d::Magnitude(); -&gt; Point3d Point3d::Magnitude(Point3d *const this);// constPoint3d Point3d::Magnitude() const; -&gt; Point3d Point3d::Magnitude(const Point3d *const this); 对成员的访问操作变为this指针的访问 转换函数名称——mangling方法(第三章数据部分提到，用于转换static变量名) 转换后，函数的调用也需要被转换 1234567class Point3d;Point3d obj;Point3d *ptr = new Point3d;// 假设Magnitude名称转换为Magnitude_7Point3dFvobj.Magnitude(); -&gt; Magnitude_7Point3dFv(&amp;obj);ptr-&gt;Magnitude(); -&gt; Magnitude_7Point3dFv(ptr); 假设有如下代码： 1234567891011Point3d Point3d::Normalize() const &#123; register float msg = Magnitude(); return Point3d( x_/msg, y_/msg, z_/msg);&#125;// 经过转换，以及NRV优化void Normalize_7Point3dFv(register const Point3d* const this, Point3d&amp; _result) &#123; register float msg = this-&gt;Magnitude(); _result.Point3d::Point3d(this-&gt;x_/msg, this-&gt;y_/msg, this-&gt;z_/msg); return;&#125; 1.2 函数名称转换(Name Mangling)不同编译器的做法不同。以下仅介绍cfront的做法。 类的数据成员通常会加上类名，会变成独特的名称。可以有效防止子类和父类拥有相同变量名。 123456789class Bar &#123; public: int val_; -&gt; val_3Bar&#125;;class Foo : public Bar &#123;public: int val_; -&gt; val_3Foo&#125; 函数由于可以重载。会在函数名后加上类名，再加上参数列表中的类型。 12345class Point &#123;public: void x(float x); -&gt; void x_5PointFf(float x); void x(float x, float y); -&gt; void x_5PointFff(float x, float y);&#125; 名称转换的目的是为了使不正确的调用操作在链接期就被检测出来。比如重载函数调用不正确等。 1.3 虚成员函数(Virtual Member Function)虚函数通过虚函数指针指向的虚函数表调用。 虚函数表，第一格是RTTI有关数据，之后的是虚函数地址。有些编译器将虚函数表-1位置设置为虚基类地址/偏移。 虚函数的转换 1ptr-&gt;Normalize(); -&gt; (*ptr-&gt;vptr[1])(ptr); vptr为虚函数指针，在单继承体系中只有一个，但是在多继承体系中会有多个，因此有可能需要名称转换。 vptr[1]是函数的地址，即Noemalize()函数地址。 第二个ptr为this指针。 12345Point3d Point3d::Normalize() const &#123; register float msg = Magnitude(); return Point3d( x_/msg, y_/msg, z_/msg);&#125;// 假设Magnitude和Noemalize都是虚函数 优化tips 因为Magnitude()**是确定的，所以直接显式调用**会比虚指针转换调用更好。 即，register float msg = Point3d::Magnitude(); 显式调用虚函数，调用过程与非静态成员函数相同 Magnitude()编写为内联函数，更有效率 1.4 静态成员函数(Static Member Function)静态函数的调用与非静态成员函数类似，但有区别，**不会增加额外参数(this指针)**。 12obj.Noemalize(); -&gt; Normalize_7Point3dSFv();ptr-&gt;Normalize(); -&gt; Normalize_7Point3dSFv(); 静态成员函数也需要被转化，其中SFv表示是静态成员函数 静态成员函数不需要通过类的实例调用 1234foo.Obj() &gt; 1;// 转换为(void) foo(); // NRVPoint3d::Obj() &gt; 1; 这样会有额外成本 静态成员函数的地址是非成员函数的地址 &amp;Point3d::Obj(); == unsigned int (*)(); != unsigned int (Point3d::*)(); 静态成员函数可以便于成为回调函数(callback)**，可用于线程函数(pthread)** 2. 虚函数(Virtual Member Function)2.1 单一继承为了支持多态，需要对类提供额外的执行期信息。 每个对象设置一个虚指针，指向虚函数表 虚函数表中设置类的类型信息（支持RTTI），以及虚函数地址 对于虚函数的继承来说，会有以下操作： 父类的虚函数会被子类继承 子类的虚函数会重载父类的虚函数，即在虚函数表中覆盖父类虚函数 子类的新虚函数会加入到虚函数表中，新的虚函数会被放到虚函数表末尾 存在一个pure_virtual_called()函数，它可以是纯虚函数，也可以当作执行器异常处理函数 如： 123456789101112131415161718192021222324252627class Point &#123;public: virtual ~Point(); virtual POint&amp; Mult(float) = 0; virtual float y() const &#123; return 0; &#125; virtual float z() const &#123; return 0; &#125;private: float x_;&#125;class Point2d : public Point &#123;public: virtual ~Point2d(); virtual POint2d&amp; Mult(float); virtual float y() const &#123; return y_; &#125;private: float y_;&#125;class Point3d : public Point2d &#123;public: virtual ~Point3d(); virtual POint3d&amp; Mult(float) = 0; virtual float z() const &#123; return z_; &#125;private: float z_;&#125; 因此，ptr-&gt;z();会被转换为(ptr-&gt;_vptr[4])(ptr) 这一转换在编译器即可完成，但在执行期才能知道调用的是哪一个类的z() 2.2 多继承复杂度主要是：第二个之后的父类，以及调用时this指针的转换问题 12345678910111213141516171819202122232425262728class Base1 &#123;public: Base1(); virtual ~Base1(); virtual void SpeakClearly(); virtual Base1* Clone() const;private: float data_base1_;&#125;;class Base2 &#123;public: Base2(); virtual ~Base2(); virtual void Mumble(); virtual Base2* Clone() const;private: float data_base2_;&#125;;class Derived : public Base1, public Base2 &#123;public: Derived(); virtual ~Derived(); virtual Derived* Clone() const;private: float data_derived_;&#125;; 如果以父类指针指向子类，则对于Base1则没问题，因为Base1地址与子类地址相同，而Base2则需要加减偏移this指针来对齐地址。在调用析构函数时也需要调整this指针。 假设有 Base2 *pbase2 = new Derived，Derived对象的地址需要被调整到Base2子对象的地址。 Derived *temp = new Derived; Base2 *pbase2 = tmep ? temp + sizeof(Base1) : 0; 在删除时，也需要调整指针到整个Derived对象地址。 多重继承之下的含有虚函数的对象模型： 含有多个虚函数表，虚函数表数目与父类数目有关 每一个虚函数表，子类都有一个虚指针对应 对于本例，则有两个虚函数表创建 一个主要实例，子类的虚函数表，与最左端的Base1类共享，涵盖整个对象的虚函数 一个次要实例，与Base2类相关，不包含Base1，即左边的父类的相关虚函数 例如：Base *pb1 = new Derived; Base2 *pb2 = pb1-&gt;Clone(); pb1首先加上offset，调整到Derived类地址，调用Derived::Clone()，返回值需要减去offset，调整到Base2的地址。 Sun编译器 Sun编译器为了解决多虚函数表问题，将虚函数表连在一起，加上指针指向下一个虚函数表，提升了项目的速度。 在虚函数足够小时，使用split function，将函数调整为两个函数，第二个在返回之前，为指针加减offset。 因此，Base1指针和Derived指针不需要调整this指针，而Base2指针调用的是新的函数。 Microsoft使用address points的方法。 2.3 虚拟继承1234567891011121314151617181920class Point2d &#123;public: Point2d(float = 0.0, float =0.0); virtual ~Point2d(); virtual void Mumble(); virtual float Z():private: float x_, y_;&#125;;class Point3d : public virtual Point2d &#123;public: Point3d(float = 0.0, float = 0.0, float = 0.0); virtual ~Point3d(); virtual float Z();private: float z_;&#125; 不同编译器对于虚继承下的虚函数有着眼花缭乱的支持，这里不做详述，太怪异了。 但是谨记，不要在虚基类中声明非静态数据成员。 3. 函数的效率 友元函数、静态成员函数、非静态成员函数的效率差不多，这是易于理解的，因为三者最终的调用方式相同，都被转换为非成员函数。 单继承虚函数需要通过构造函数设定vptr，所以效率降低了。 多继承虚函数有多方面因素，因为多继承，所以构造函数需要多调用一次，其次，可能需要调整this指针而导致效率进一步降低。 虚拟继承虚函数与多继承类似 4. 指向成员函数的指针4.1 非静态、非虚成员函数指针 取非静态、非虚成员函数的地址，得到的是真正地址，但是调用的话需要绑定一个函数对象。 123456double Point::M();// 声明如下double (Point:: *ptr_f) ();// 调用origin.*ptr_f(); -&gt; (ptr_f)(&amp;origin);ptr-&gt;*ptr_f(); -&gt; (ptr_f)(ptr); 4.2 虚成员函数指针 取虚函数的地址，得到的是其在虚函数表中的下标。（在vs2019上测试，结果并不是这样，得到的是一个内存地址） 1234float (Point:: *ptr_f) ();Point *ptr = new Point3d;(ptr-&gt;*ptr_f)(); -&gt; *(ptr-&gt;vptr[(int)ptr_f])(ptr); 为了区分函数指针指向的是非虚函数还是虚函数，编译器必须使ptr_f能够持有两种值，且可以被区分是内存地址还是虚函数表的下标 在cfron中，如此判断 1(((int) ptr_f) &amp; ~127) ? (*ptr_f)(ptr) : *(ptr-&gt;vptr[(int)ptr_f])(ptr); 这样只能限制最多只有128个虚函数。 4.3 多重继承下，成员函数指针为了使成员函数指针支持多重继承和虚拟继承，有以下结构体 12345678struct _mptr &#123; int delta; int index; union &#123; ptrtofunc faddr; int v_offset; &#125;;&#125;; delta指this指针的offset，index指虚函数表的下标，faddr指非虚成员函数地址（当index不指向虚函数表时，设为-1），v_offset指虚基类或多重继承的第二父类的vptr位置。 但是这样每次通过成员函数指针调用都会判断一次。被人诟病。 Microsoft引入vcall thunk，因此，faddr要么指向函数地址、要么指向vcall thunk地址，vcall thunk会自动选定虚函数表中的下标，调用。 该结构体的一个副作用是，当传递一个固定值给成员函数时，可能会产生临时对象。 4.4 效率 5. 内联函数(Inline Function)inline只是个请求，是否被接受，还得看编译器的是否认可inline的做法。 在cfront中，有一套测试法，两个阶段： 分析函数定义，决定函数的**”intrinsic inline ability”**(编译器相关的inline能力) 如果函数因复杂度、建构等问题，不可成为inline，则会转化为static函数 真正的inline函数扩展操作，实在调用函数的那一点上。这会带来参数的求值以及临时对象。 1new_pt.x(lhs.x() + rhs.x()); -&gt; new_pt.x = lhs.x_ + x_5PointFV(&amp;rhs); 这样扩张没有效率提升，所以不会被inline请求不会被处理。 5.1 形式参数 inline函数的形式参数都会被实际参数取代 如果实际参数会导致副作用，会引入临时对象 如果实际参数是常量表达式，直接求值 1234567891011121314151617181920inline int Min(int i, int k) &#123; reutrn i &lt; j ? i : j;&#125;inline int bar &#123; int minval; int val1 = 1024; int val2 = 2048; // 实参代替形参 minval = Min(val1, val2); -&gt; minval = val1 &lt; val2 ? val1 : val2; // 常量表达式，计算结果作为返回值 minval = Min(1024, 2048); -&gt; minval = 1024; // 副作用，引入临时对象 minval = Min(foo(), bar() + 1); -&gt; int t1, t2; -&gt; minval = (t1 = foo()), (t2 = Bar() + 1), r1 &lt; t2? t1 : t2; return minval;&#125; 5.2 局部变量inline函数中的局部变量会在inline函数被调用时被维护。因为这一点，如果参数有副作用，可能会导致扩展码变大。 因此inline函数作为宏的安全处理，为此可能需要扩大扩展码，需要谨慎处理。","categories":[{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"对象模型-3.数据","slug":"cpp-对象模型-第三章-数据","date":"2020-11-17T06:38:32.000Z","updated":"2021-01-30T01:58:33.192Z","comments":true,"path":"2020/11/17/cpp-对象模型-第三章-数据/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE/","excerpt":"","text":"1. 类的大小1234class X &#123;&#125;;class Y : public virtual X &#123;&#125;;class Z : public virtual X &#123;&#125;;class A ; public Y, public Z &#123;&#125;: 以上的继承体系中，类的大小会根据编译器的处理而变化。 X为1bytes，Y，Z为8bytes，A为12bytes X为1bytes 编译器为了确保类的不同对象具有不同地址，会为空类内部安插一个char。 Y，Z为8bytes 首先，我们需要知道，Y，Z的大小收到三部分影响： 语言本身的负担 虚基类、虚函数都会是类内部扩张，具体显示在某种形式的指针(或offset)上。 虚基类的指针会指向虚基类或相关表格或具体偏移量。 虚函数的指针则是指向虚函数表。 编译器对特殊情况的优化 Y，Z是空类，因此需要一个char，被放在类的固定部分的尾部。 某些编译器会对空虚基类进行特殊支持。 内存地址对齐 为了使的读取更有效率，会将内存扩大到4的倍数。 A的12bytes 一个虚基类只会在子类中存在一份实例 因此，A的大小如下： 唯一一份X的实例，1bytes 父类Y的大小，减去虚基类的就开销，结果使4bytes，X同理 A自己的大小，0 对齐，前三项为9bytes，因此最终是12bytes X为1bytes，Y，Z为4bytes，A为8bytes Y，Z为4bytes 有些编译器对空虚基类优化，将其放到子类的最初部分，这样子类就有了member，也就不会有第二点1个char的填充，也不需要对齐，因此只需4bytes。 A为8bytes 有些编译器对空虚基类优化，X实例的1bytes可以省略，因此也没有对齐，所以使8bytes 注意：编译器的的优化仅仅针对空虚基类 2. 数据成员的绑定1234567891011extern float x;class Point3d &#123;public: Point3d(float, float, float); float X() const &#123; reuturn x; &#125; void X(float new_x) const &#123; x = new_x; &#125;private: float x, y, z;&#125; 如今，我们都知道Point3d::X()传回的使类内部的x，然而在早期的编译器上，传回的是全局的x。 为此，为了防止这种情况发生，c++早期有两种防御性程序设计风格 将所有的成员变量放在类声明开始处，确保正确的绑定 将所有的内联函数，无论大小都放到类声明之外 这个古老的语言规则称为”member rewriting rule“，意为一个内联函数在整个类声明结束之前，是不会被解析的。 c++标准以”member scope resolution rules“来精练”rewriting rule“。 然而，这对成员函数的参数列表并不为真，参数列表中的参数在第一次遇见时还是会被解析。因此extern和嵌套typedef还是会出错。如： 1234567891011typedef int length;class Point3d &#123;public: // 此时length被解析为int，val_被解析为Point3d::val_ void Mumble(length val) &#123; val_ = val; &#125; length Mumble() &#123; return val_; &#125;private: typedef float length; length val_;&#125; 因此，需要把类中的嵌套typedef放到类的起始处。 3. 数据成员的布局12345678class Point3d &#123;private: float x_; static List&lt;Point3d*&gt; *free_list_; float y_; static const int chunk_size = 250; float z_;&#125; nonstatic数据成员在类中排列顺序和其声明顺序相同，中间如果存在static变量也不会被放到类之中。 c++标准指出，同一个存取段(access section)中，即public，private，protected，成员变量的排列需要符合较晚声明的变量出现在类中的较高的地址。因此数据成员的地址不需要连续，方便编译器实现内存对齐。 而vptr的位置在传统上是放在所有显式声明的成员变量的末尾，但是也有编译器将其放在开头。 同时，c++标准允许编译器将多个存取段(access section)中的数据成员自由排列。 skill 下面这个模板函数，接受两个成员变量，判断谁先出现在类中。如果两个成员都是不同的存取段中的第一个数据，那么就可以判断哪一个存取段先出现。 12345template &lt;class class_type, class data_type1, class data_type2&gt;char* AccessOrder(data_type1 class_type::*mem1, data_type2 class_type::*mem2) &#123; assert (mem1 != mem2); return mem1 &lt; mem2 ? &quot;member 1 occurs first&quot; : &quot;member 2 occurs first&quot;;&#125; 4. 数据成员的存取12Point3d origin;origin.x = 0.0; x的存取成本是什么？ 视x和Point3d的声明而定，x可能是static/nonstaic，Point3d可能是独立类/继承的类/多重继承/虚拟继承的类。 4.1 静态数据成员(static data members)内部static数据成员 静态数据成员是存放在类之外的全局存储区，因此其存取与类的关联，不会造成任何额外成本。 每次程序调用静态成员时，就会被内部转换为对该extern实例的直接调用。 通过指针和对象，存区静态成员的指令是完全相同的。因为静态成员并不在类对象中，所以不需要通过对象存取静态成员。 复杂继承关系的static数据成员 因为同样静态成员不在类对象中，且实例只有一份，所以存取仍然和上述行为相同。 函数得来的对象 1FooBar().chunk_size_ = 250; 调用FooBar()的行为，在c++预标准(pre-standard)中并没有定义。但在c++标准中明确要求FooBar()被求值，即使其结果没有用处。 123456// 原先的FooBar().chunk_size_ = 250;// 可能的一种转换(void)FooBar();Point3d::chunk_size_ = 250; 静态成员地址 如果取静态成员的地址，得到的是一个静态成员数据类型的指针，因为静态成员不在类中。即： 123&amp;Point3d::chunk_size_;// 结果为const int*; 名称冲突 如果两个类的静态成员名称相同，编译器会对名称转换，转换为一个新编码，此过程称为name-mangling。 每个编译器的做法不同，但是至少要保证以下两点： 推导出独一无二的编码 这些编码需要被轻易的推到回原来的名称 4.2 非静态数据成员(nonstatic data members)非静态数据成员存放在类对象内部。除非经过类对象（显式或隐式），否则无法直接存取他们。 因此，只要程序中的一个成员函数直接处理一个非静态数据成员，就会有隐式对象产生。 123456789101112Point3d Point3d::Translate(const Point3d&amp; pt) &#123; x_ += pt.x_; y_ += pt.y_; z_ += pt.z_;&#125;// 实际代码Point3d Point3d::Translate(Point3d *const this, const Point3d&amp; pt) &#123; this-&gt;x_ += pt.x_; this-&gt;y_ += pt.y_; this-&gt;z_ += pt.z_;&#125; 对一个非静态数据成员的存取操作，编译器需要把类对象初始地址加上数据成员的偏移地址。 123original.x_ = 0.0;// 其地址为&amp;original + (&amp;point3d::x_ - 1); -1的操作，是因为指向成员数据的指针，其偏移量总是被+1，这样编译器可以区分”一个指向成员数据的指针，他指出类的第一个成员“和”一个指向成员数据的指针，他没有指出任何成员“这两种情况。 每一个成员数据的偏移量在编译期即可确定，即使成员变量是属于父类的继承体系（单一继承或多重继承）中。 因此，存取一个非静态数据成员和存取一个结构体成员或一个非子类的成员的效率相同。 虚拟继承 12Point3d *pt;pt-&gt;x_ = 0.0; 当x_是虚基类的成员是，存取效率会慢一些。 12original.x_ = 0.0;pt-&gt;x_ = 0.0; 以上两种存取方式的区别在于：如果x_是虚基类成员变量，那么pt具体指向的类是不明确的，所以指针存取操作会延迟到执行期，经过一个额外的间接引导，才可以完成。 而original因为类型已经确定，所以成员变量的偏移量在编译期就已经确定。 5. 继承与数据成员在c++继承模型中，一个子类的内存是自己的成员数据加上父类的成员数据，至于数据的排列顺序，c++标准没有强制规定。大多数编译器都是父类成员数据先出现。虚基类除外。 5.1 不带多态的继承（没有虚函数）123456789101112131415161718192021222324252627282930313233class Point2d &#123;public: Point2d(float x = 0.0, float y = 0.0) : x_(x), y_(y) &#123;&#125; float x() &#123; return x_; &#125; float y() &#123; return y_; &#125; void x(float x) &#123; x_ = x; &#125; void y(float y) &#123; y_ = y; &#125; void operator+(const Point2d&amp; rhs) &#123; x_ += rhs.x(); y_ += rhs.y(); &#125;private: float x_, y_:&#125;class Point3d &#123;public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point2d(x, y), z_(z) &#123;&#125; float z() &#123; return z_; &#125; void z(float Z) &#123; z_ = z; &#125; void operator+(const Point3d&amp; rhs) &#123; Point2d::operator+(rhs); z_ += rhs.z(); &#125;private: float z_:&#125; 这样设计时，x，y的相关代码都局部化了，且抽象体系更易于理解。 然而，将原本独立的类，组合成继承关系，会造成两个易犯的错误。 重复设计相同功能的函数 point3d和point2d的构造函数和operator+并没有做成内联函数，因为他们需要调用Point2d的函数。 类的继承体系所带来的空间膨胀 1234567class Concrete &#123;private: int val_; char c1_; char c2_; char c3_;&#125; 上述类需要占用8bytes，4 + 1 + 1 + 1 + 1(对齐) 123456789101112131415class Concrete1 &#123;private: int val_; char c1_&#125;class Concrete2 : public Concrete1 &#123;private: char c2_;&#125;class Concrete3 : public Concrete2 &#123;private: char c3_;&#125; 这种情况下，Concrete3需要16bytes，8 + 4 + 4 为什么c++会这么做？而不是将padding填补呢？ 考虑如下： 1234Concrete2 *pc2;Concrete1 *pc1_1. *pc1_2;*pc1_2 = *pc1_1; 上述赋值操作，将会使被指对象的Concrete1部分复制给pc1_2。 如果考虑将padding填补 1234pc1_1 = pc2;// 那么，c2_就会被覆盖了*pc1_2 = *pc1_1 5.2 加上多态12345678910111213141516171819202122232425262728293031323334353637class Point2d &#123;public: Point2d(float x = 0.0, float y = 0.0) : x_(x), y_(y) &#123;&#125; float x() &#123; return x_; &#125; float y() &#123; return y_; &#125; void x(float x) &#123; x_ = x; &#125; void y(float y) &#123; y_ = y; &#125; virtual float z() &#123; return 0.0; &#125; virtual void z(float) &#123;&#125; virtual void operator+(const Point2d&amp; rhs) &#123; x_ += rhs.x(); y_ += rhs.y(); &#125;private: float x_, y_:&#125;class Point3d &#123;public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point2d(x, y), z_(z) &#123;&#125; float z() &#123; return z_; &#125; void z(float Z) &#123; z_ = z; &#125; // 注意，类型是point2d void operator+(const Point2d&amp; rhs) &#123; Point2d::operator+(rhs); z_ += rhs.z(); &#125;private: float z_:&#125; 只有当我们使用多态来处理使，设置一个virtual接口才合适。 为了支持多态，Point2d类会造成一些额外负担： 虚函数表，存放每一个虚函数的地址，表的个数还需要加上一个或两个位置，用来支持RTTI vptr，提供指向虚函数表的执行期链接 强化构造函数，为了使vptr初始化 强化析构函数，删除vptr。析构函数的调用是反向的，从子类到父类 在这种情况下，Point3d中含有一个额外的vptr，继承得来， 多了一个point3d的vtbl。 vptr的位置 目前，c++编译器的一个主要讨论题目是，将vptr放在哪里合适？ 一种做法是放在最后 这样可以保证类继承于结构体，确保了c++和c的兼容性。 另一种做法是放在开头 这种做法，会对多重继承下，通过类成员指针调用虚函数变得方便些。代价是成员变量的偏移拖延到执行期准备。且丧失了对c的兼容。但是有多少程序会从结构体继承下来的呢？ 5.3 多重继承单继承提供了一种自然多态的形式。即子类和父类从同一地址开始，只是大小有区别。 12Point3d p3d;Point2d *p = &amp;p3d; 这样的执行会很自然的发生，不需要额外操作。 如果把vptr放在类起始处，假设父类没有虚函数，而子类有虚函数，那么上述的赋值操作就无法自然发生，就需要编译器调整地址。 123456789101112131415161718192021222324252627class Point2d &#123;public: // 虚函数private: float _x, _y;&#125;;class Point3d &#123;public: // 虚函数private: float _z;&#125;;class Vertex &#123;public: // 虚函数private: Vertex *next;&#125;;class Vertex3d : public Point3d, public Vertex &#123;public: // 虚函数private: float mumble;&#125; 继承体系如下图所示： 多重继承的问题主要是子类和第二个继承的父类的转换问题。 在上述例子中，即将Vertex3d转换为Vertex，这需要编译器额外工作。 多重继承中，子类对象赋值给第一个继承的父类和单一继承相同，起始地址一样。如果是其后的父类，则需要对地址加/减中间的父类对象的大小。 如： 12345678910111213141516171819202122Vertex3d v3d;Vertex *pv;Point2d *p2d;Point3d *p3d;// 该操作会被转换pv = &amp;v3d;pv = (Vertex*)(((char*)&amp;v3d) + sizeof(Point3d));// 下面的操作直接进行p2d = &amp;v3d;p3d = &amp;v3d;Vertex3d *pv3d;Vertex *pv;pv = pv3d;// 被转换成pv = ((Vertex*)pv3d) + sizeof(Point3d);// 如果pv3d是空指针，那么pv的地址 = sizeof(Point3d)，造成错误// 实际的指针转换为pv = pv3d ? ((Vertex*)pv3d) + sizeof(Point3d) : 0; 引用则不需要对空值戒备，因为引用的初始化，不会使用到空对象。 c++标准没有要求父类的排列顺序，因此有些编译器(Meta Ware)设计了一种优化技术，只要第二个父类有虚函数，第一个父类没有，就将他们的顺序调换，这样子类的vptr就可以少产生一个，然而并没有得到广泛认可。 存取每一个父类的数据成员也无需额外操作，因为在编译时就已经处理好了偏移。 5.4 虚继承多重继承的副作用就是，他必须支持某种形式的共享对象继承，典型的例子是iostream库。 1234567891011// 早期的iostreamclass ios &#123;&#125;;class istream : public ios &#123;&#125;;class ostream : public ios &#123;&#125;;class iostream : public istream, public ostream &#123;&#125;;// 如今的iostream，只需要使用一份ios对象即可class ios &#123;&#125;;class istream : public virtual ios &#123;&#125;;class ostream : public virtual ios &#123;&#125;;class iostream : public istream, public ostream &#123;&#125;; 为了保证虚继承的多态，一般实现方法如下： 类如果有虚基类，虚基类会被分为两部分，共享区域和不变区域。 不变区域的部分无论子类怎样继承，都会有固定的偏移，该部分数据可以直接存取。 共享区域，即虚基类部分，每次都会因为继承而产生变化，他们只可以被间接存取。 不同编译器的差异就在于间接部分的不同，以下为三种主流策略。 1) 虚基类指针 12345678910111213141516171819class Point2d &#123;protected: float x_. y_;&#125;;class Vertex : public virtual Point2d &#123;protected: Vertex *next;&#125;;class Point3d : public virtual Poin2d &#123;protected: float z_;&#125;;class Vertex3d : public Vertex, public Point3d &#123;protected: float mumble_;&#125;; 为了获得共享部分，cfront编译器会在每一个子类中设置一些指针，每个指针指向虚基类，访问继承的虚基类成员是，通过指针间接完成 如： 123456789101112void Point3d::operator+=(const Point3d&amp; rhs) &#123; x_ += rhs.x_; y_ += rhs.y_; z_ += rhs.z_;&#125;;// 转换为void Point3d::operator+=(const Point3d&amp; rhs) &#123; _vbcPoint2d-&gt;x_ += rhs._vbcPoint2d-&gt;x_; _vbcPoint2d-&gt;y_ += rhs._vbcPoint2d-&gt;y_; z_ += rhs.z_;&#125;; 子类和父类的转换 123Point2d *p2d = pv3d;// 转换为Point2d *p2d = pv3d ? pv3d-&gt;_vbcPoint2d : 0; 该模型有两个主要的缺点： 每一个对象要对其每一个虚基类设置一个指针，然而我们希望每个对象有固定的指针个数，而不需要根据虚基类的个数而变动。 虚继承结构增加的话，就会导致间接存取层次增加。如果有三次虚继承，就会有三次间接存取。然而我们希望每个虚基类的访问时间是固定的，而不需要根据虚继承体系的深度而变动。 MeraWare等编译器使用第一种方法，他们复制所有虚基类的指针，将其放到子类中，解决固定访问时间的问题。但是付出了空间的代价。 第一个问题主要有两个解决方法。 第一种解决方法——2) 虚基类表 Microsoft编译器使用了虚基类表，每个对象如果有虚基类，则会通过一个虚基类表指针，指向虚基类表。真正的虚基类指针放在虚基类表中。 第二种解决方法——3) 虚函数表偏移策略[-1] 在虚函数表中存放虚基类的偏移量。 1234567891011121314151617void Point3d::operator+=(const Point3d&amp; rhs) &#123; x_ += rhs.x_; y_ += rhs.y_; z_ += rhs.z_;&#125;;// 转换为void Point3d::operator+=(const Point3d&amp; rhs) &#123; (this + _vptr_Point3d[-1])-&gt;x_ += (&amp;rhs + ths._vptr_Point3d[-1])-&gt;x_; (this + _vptr_Point3d[-1])-&gt;y_ += (&amp;rhs + ths._vptr_Point3d[-1])-&gt;y_; z_ += rhs.z_;&#125;;// 子类和虚基类之间的转换Point2d *p2d = pv3d;Point2d *p2d = pv3d ? pv3d + pv3d-&gt;_vptr_Point3d[-1] : 0; 上述方法在存取继承来的成员时代价较高，但是此代价被分散到对成员的使用上，属于局部性成本。 以上三种方法都是一种实现模型，而不是标准，每种模型都是来解决共享区域的数据存储问题。 如果通过非多态的存取操作，可以在编译时期被解析，效率较好。 12Point3d origin;origin.x_; 通常，最有效的使用虚基类的方法是，一个抽象虚基类，没有任何数据成员。 6. 对象成员的效率我们将对聚合、封装以及继承所引发的负担做测试。 局部变量 12345678float pa_x = 1.725, pa_y = 0.875, pa_z = 0.478;float pb_x = 0.315, pb_y = 0.317, pb_z = 0.838;for (int iter = 0; iter &lt; 10000000; ++iter) &#123; pb_x = pa_x - pb_z; pb_y = pa_y + pb_x; pb_z = pa_z + pb_y;&#125; 123class Point1d &#123;&#125;;class Point2d : public virtual Point1d &#123;&#125;;class Point2d : public virtual Point2d &#123;&#125;; 因此，程序的效率不可通过经验判断，需要实际检验。 7. 指向数据成员的指针指向数据成员的指针主要用途有两点。 类成员的底层布局，判断vptr在开头还是末尾 之前在数据成员的布局中提到的，判断类中的存取段(access section)的顺序 1234567class Point3d &#123;public: virtual ~Point3d();protected: static Point3d origin_; float x_, y_, z_;&#125; 去某个成员变量的地址（nonstatic），将达到成员变量在类中的偏移，但是因为vptr的位置没有限制，通常在类开头或结尾，所以可能会有差别。 我们期望分别对x_，y_，z取地址后得到0，4，8或4，8，12。然而实际结果却比期望结果多了1。 注意：在visual studio2019上测试得到的结果是0，4，8，这可能跟编译器的特殊处理有关。 为什么会多1呢？ 为了区分空指针和指向第一个数据成员的指针。 1234567Point3d origin;// 取nonstatic数据成员的地址，得到的是偏移量&amp;Point3d::x_;// 取一个对象的数据成员的地址，得到的是内存中的实际地址&amp;origin::x_;// 将&amp;origin::x_的结果减&amp;Point3d::x_的结果+1，就会得到origin的起始地址 多重继承下的指向数据成员的指针 123456789101112131415161718192021222324252627282930313233343536class Base1 &#123;public: int val1;&#125;;class Base1 &#123;public: int val2;&#125;;class Derived : public Base1, public Base2 &#123;&#125;;void Func1(int Derived::*dmp, Derived *pd) &#123; pd-&gt;*dmp;&#125;void Func2(Derived *pd) &#123; int Base2::*bmp = &amp;Base2::val2; // bmp值为1，但在Derived中，val2地址为5 Func1(bmp, pd);&#125;// 经过转换void Func2(Derived *pd) &#123; int Base2::*bmp = &amp;Base2::val2; // bmp值为1，但在Derived中，val2地址为5 Func1(bmp + sizeof(Base1), pd); // 但是无法确保bmp是否为0&#125;// 经过转换，防止bmp=0void Func2(Derived *pd) &#123; int Base2::*bmp = &amp;Base2::val2; // bmp值为1，但在Derived中，val2地址为5 Func1(bmp ？ bmp+ sizeof(Base1) : 0, pd);&#125; 当bmp被作为Func1的第一个参数时，它的值需要根据Base1的大小而调整，否则会访问Base1的val1。 7.1 指向数据成员的指针的效率指针指向对象的成员： 123Point3d pa;float *ax = &amp;pa.x;*bx = *ax - *bz; 指针指向类的数据成员： 12float Point3d::*ax = &amp;Point3d::x;pa.*ax = pa.*ax - pb.*bz; 加上继承 因为继承的数据成员是直接放在类对象中的，因此继承的方式没有带来什么效率差异。 而虚拟继承的主要影响是对编译器的优化。 因为每次存取Point::x，都会被转换为&amp;pb-&gt;_vbcPoint + (bx - 1)，多了一次间接访问，降低了寄存器的优化能力。","categories":[{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"对象模型-2.构造函数","slug":"cpp-对象模型-第二章-构造函数","date":"2020-11-17T06:36:25.000Z","updated":"2021-01-30T01:54:33.056Z","comments":true,"path":"2020/11/17/cpp-对象模型-第二章-构造函数/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","excerpt":"1. 默认构造函数的生成并不是类没有构造函数时，编译器都会创建一个默认构造函数，只有当编译器需要的时候，才会创建一个默认构造函数。 而如果是程序的需要，那就是程序员的责任去创建构造函数。 c++95声明，当没有用户定义的构造函数时，会隐式创建一个默认构造函数，然而这个隐式构造函数是trivial的（无能的） 1.1 带有默认构造函数的成员类对象如果类没有构造函数，但是其成员类对象拥有默认构造函数，那么该类的隐式默认构造函数是nontrivial的（有用的），编译器就会在构造函数被调用时创建一个隐式构默认造函数。 为了解决不同文件中的同一个类多次创建问题，即在A文件中调用C类，在B文件中调用C类，会将创建的构造、析构、复制构造、赋值以inline方式完成，如果函数太复杂，就会创建explicit non-inline static函数。 12345678910class Foo &#123;public: Foo();&#125;class Bar &#123;public: Foo foo; char* str;&#125; 此时编译器为了满足自身要求，会创建要给构造函数，大体如下：","text":"1. 默认构造函数的生成并不是类没有构造函数时，编译器都会创建一个默认构造函数，只有当编译器需要的时候，才会创建一个默认构造函数。 而如果是程序的需要，那就是程序员的责任去创建构造函数。 c++95声明，当没有用户定义的构造函数时，会隐式创建一个默认构造函数，然而这个隐式构造函数是trivial的（无能的） 1.1 带有默认构造函数的成员类对象如果类没有构造函数，但是其成员类对象拥有默认构造函数，那么该类的隐式默认构造函数是nontrivial的（有用的），编译器就会在构造函数被调用时创建一个隐式构默认造函数。 为了解决不同文件中的同一个类多次创建问题，即在A文件中调用C类，在B文件中调用C类，会将创建的构造、析构、复制构造、赋值以inline方式完成，如果函数太复杂，就会创建explicit non-inline static函数。 12345678910class Foo &#123;public: Foo();&#125;class Bar &#123;public: Foo foo; char* str;&#125; 此时编译器为了满足自身要求，会创建要给构造函数，大体如下： 123inline Bar::Bar() &#123; foo.Foo::Foo();&#125; 但是该构造函数并没有初始化str，这将导致程序运行不正确，然而这一部分功能应该由程序员去实现 假设程序员编写了如下构造函数： 123Bar::Bar() &#123; str = nullptr;&#125; 然而该构造函数没有满足编译器的需求，因此，编译器会扩张该构造函数。 1234Bar::Bar() &#123; foo.Foo::Foo(); str = nullptr;&#125; 如果类由多个成员类对象，则会根据其声明顺序，来扩张构造函数的编写顺序。 1.2 带有默认构造函数的父类这种情况下与前一种情况类似。 如果本类由多个构造函数，但是没有默认构造函数，编译器会扩张每一个构造函数，而不会去创建一个新的默认构造函数。 如果本类中还有带着默认构造函数的成员类对象，这些成员类的默认构造函数也会在父类默认构造函数调用之后被调用。 1.3 带有虚函数的类1234567891011121314151617class Widget &#123;public: virtual void Flip() = 0;&#125;;void Flip(const Widget&amp; widget) &#123; widget.Flip();&#125;// Bell 和 Whistle 都继承Widget类void Foo() &#123; Bell b; Whistle w; Flip(b); Flip(w);&#125; 其中，虚函数的调用部分会被重写成类似形式： 1234// widget.Flip() 的虚函数调用动作(*widget.vptr[1])(&amp;widget)// &amp;widget 表示被调用的函数实例的this指针 为了实现如上调用，编译器会为每一个带有虚函数的类的vptr初始化。 1.4 带有虚基类的类虚基类在不同编译器上的实现方式不同，而每一种实现方式都需要确保虚基类在子类中的位置能在执行期确定 12345678910111213141516171819202122232425262728class X &#123; public: int i;&#125;;class A : public virtual X &#123;public: int j;&#125;;class B : public virtual X &#123;public: double d;&#125;class C : public A, public B &#123;public: int k;&#125;void Foo(const A* pa) &#123; pa-&gt;i = 1024;&#125;int main() &#123; Foo(new A); Foo(new B);&#125; 在上述代码中，编译器无法确定pa中的X::i的具体位置，因为A*的实际类型并不清楚。 因此编译器需要改变代码，在执行期确定X::i。 可能的改变如下： 123void Foo(const A* pa) &#123; pa-&gt;_vbcX-&gt;i = 1024;&#125; 同个一个_vbcX指向具体的虚基类X，编译器也为此在对象创建时初始化该指针。 2. 复制构造函数的操作2.1 复制构造函数的调用在三种情况中，复制构造函数会被调用： 显式地将对象作为另一个对象的初值 123class X &#123;&#125;;X a;X ax = a; 对象通过参数传递给函数 1234class X &#123;&#125;;void Foo(X x);Foo(x); 函数返回类对象 1234void Foo() &#123; X xx; return xx;&#125; 2.2 默认按成员初始化(default memeberwise initialization)如果类没有显式复制构造函数，编译器会以默认按成员初始化，即将类中声明的，或继承的数据成员逐一复制，如果遇到了成员类对象，将会递归地实行按成员初始化。如： 1234567891011121314class String &#123;public: // 缺少显式复制构造函数private: char* str; int len;&#125;;String noun(&quot;book&quot;);String verb = noun;// 类似于verb.str = noun.str;verb.len = noun.len; 此时该对象的默认按成员初始化会发生。 如果该类是另一个类的成员，如下： 1234567class Word &#123;public: // 缺少显式复制构造函数private: int occurs; String word;&#125; 那么word的复制构造函数会以默认按成员初始化的方式进行，先复制occurs，接着在递归调用word的按成员初始化操作。 这种默认按成员初始化的操作时怎么实现的？ 如同默认构造函数，默认复制构造函数的生成会区分为trivial和nontrivial，只有nontrivial的实例会被创建。 而复制构造函数的trivial的标转在于类是否展现出bitwise copy semantics。 ####bitwise copy semantics（按位逐个复制） 如下： 12345class Word &#123;private: int cnt; char* str;&#125;; 以上情况就展现出了bitwise copy semantics，也无需由一个默认复制构造函数来完成初始化操作，通过直接赋值即可完成，默认复制构造函数也不会创建。 然而： 12345678910class Word&#123;private: int cnt; String str;&#125;;class String &#123;public: String(const String&amp;);&#125;; 这种情况下，编译器需要创建默认复制构造函数，调用str的复制构造函数。 编译器合成的复制构造函数都是浅复制 2.3 没有展现出bitwise copy semantics以下四种情况，类不会展现出bitwise copy semantics 类中存在成员类对象，该成员类对象含有一个复制构造函数（不论是程序员显式声明的，还是编译器合成的） 类继承带有复制构造函数的父类（不论是程序员显式声明的，还是编译器合成的） 类具有虚函数 类的继承链中，存在虚继承 2.4 具有虚函数的复制构造函数有如下两类： 1234567891011121314151617class ZooAnimal &#123;public: ZooAnimal(); ~ZooAnimal(); virtual void Animate(); virtual void Draw();&#125;class Bear : public ZooAnimal &#123;public: Bear(); void Animate(); void Draw(); virtual void Dance();&#125; 当ZooAnimal的一个类对象以另一个ZooAnimal的对象作为初值，或Bear的一个类对象以另一个Bear的对象作为初值，都可以直接按位逐个复制完成，此时vptr也会同时复制过去。 当ZooAnimal的一个类对象以Bear的对象作为初值时，就不能将vptr复制过去，复制构造函数会设定vptr指向ZooAnimal的而不是Bear的。 2.5 虚基类的复制构造函数首先，同类对象的复制直接使用按位复制即可，然而，以子类的形式复制会存在问题，如下： 123class ZooAnimal &#123;&#125;;class Raccon : public virtual ZooAnimal &#123;&#125;;class RedPanda : public Raccon &#123;&#125;; 如果将RedPanda的对象复制给Raccon，编译器需要设置虚基类的指针或者偏移量。 3. 程序转换例： 123456class X &#123;&#125;;X Foo() &#123; X xx; return xx;&#125; 在上述函数中会发生以下情况： 每次Foo()被调用时，都会传回xx的值 如果X定义了复制构造函数，return时也会调用复制构造函数 第一种情况的真实性，需要明确X是如何定义的。 第二种情况的真实性，虽然也需要明确X是如何定义，但是主要的还是看编译器是如何优化的。 在不同的编译器上，优化的结果可能导致以上两种情况都不会发生。 3.1 显式的初始化12345678class X &#123;&#125;;X x0;void Foo() &#123; X x1(x0); X x2 = x0; X x3 = X(x0);&#125; 在程序优化过程中，会有两个阶段的动作： 重写每一个定义，初始化操作会被重写。注：严谨的说，定义是指占用内存的行为。 类的复制构造函数被调用 因此，上述转换后可能是这样： 1234567891011void Foo() &#123; // 定义被重写 X x1; X x2; X x3; // 调用复制构造函数 x1.X::X(x0); x2.X::X(x0); x3.X::X(x0);&#125; 3.2 参数传递的初始化c++标准指出，将类对象作为参数或返回值时，相当于如下初始化： 12X xx = arg;// xx表示形式参数或返回值，arg表示实参 如果有如下定义： 123456class X &#123;&#125;;void Foo(X x0);X x;Foo(X x0); 这种情况下，不同编译器的实现方式不同，大体有两种： 引入临时变量，调用复制构造函数将其初始化，但因此函数的声明也需要被改写。 123456X _temp;_temp.X::X(x);Foo(_temp);// Foo函数也需要被改写void Foo(X&amp; x0); 在函数执行完毕后，临时变量也会自动调用析构函数。 拷贝建构(copy construct) 将实参复制到合适的位置上，位置由函数调用的地址而决定，类似于==栈帧== 3.3 返回值的初始化123456class X &#123;&#125;;X Bar() &#123; X xx; reutrn xx;&#125; 返回值的处理也是一个双阶段转换 增加一个额外参数，该参数是类的引用，用来放复制构造产生的返回值 在return之前增加一个复制构造函数的调用操作，初始化这个额外参数 转换后的Bar()函数如下： 1234567void Bar(X&amp; _result)&#123; X xx; xx.X::X(); _result.X::X(xx); return;&#125; 在调用Bar函数时，调用也需要转换 12345678910111213141516X xx = Bar();//转换为X xx;Bar(xx);Bar().Fun();// 转换为X _temp;(Bar(_temp), _temp).Fun();// 函数指针X (*pf)();pf = Bar;// 转换为void (*pf)(X&amp;);pf = Bar; 3.4 在用户层上去优化返回值定义一个计算用的构造函数，即不需要写 12345678910111213class X &#123;&#125;;X Bar() &#123; X xx; // 处理xx reutrn xx;&#125;X Bar(const T&amp; y, const T&amp; z) &#123; X xx; // 以y和z来处理xx return xx;&#125; 这样会导致xx使用复制构造函数，复制到编译器产生_result 优化方法是定义一个X的构造函数，以y，z为初始化条件，因此Bar可以被改写为： 123X Bar(const T&amp; y, const T&amp; z) &#123; return X(y, z);&#125; 这样，被转换之后，效率可以会高一点 1234void Bar(X&amp; _result, const T&amp; y, const T&amp; z) &#123; _result.X::X(y, z); return;&#125; 这样做减少了复制构造函数的成本。但是会导致类中的用于这种方法计算的构造函数数量增加。 3.5 在编译器层上去优化返回值编译器的优化即为： 12345678910111213class X &#123;&#125;;X Bar() &#123; X xx; // 处理xx reutrn xx;&#125;void Bar(X&amp; _result)&#123; _result.X::X(xx); // 处理_result return;&#125; 这样的编译器优化操作，称为**Named Return Value(RNV)**优化。且NRV也是当今c++标准编译器的优化之一。 虽然NRV的优化很好，但是饱受批评。原因有： NRV由编译器完成，他是否真的被执行，并不清楚 如果函数复杂，NRV就难以实行。 在有些程序中，NRV可能会导致程序错误运行 12345void Foo() &#123; // 一个复制构造函数被调用 X xx = Bar(); // 调用析构函数&#125; 此时对称性因为优化被打乱，程序的运行也出错了。 4. 复制构造函数，需要吗？123456class Point3d &#123;public: Point(float x, float y, float z);private: float x, y, z;&#125;; 类设计者需要编写复制构造函数吗？ 答案是不需要！ 首先，类中只有数值类型，编译器提供的复制构造函数足够了，安全，快速。 然而，如果存在大量以按值返回对象的操作，为了保证NRV的施行，需要编写复制构造函数。 123456789101112131415Point3d operator+(const Point3d&amp;, const Point3d&amp;);Point3d operator-(const Point3d&amp;, const Point3d&amp;);Point3d operator*(const Point3d&amp;, int);// 构造函数的编写可以如下：Point3d::Point3d(const Point3d&amp; p) &#123; x = p_x; y = p_y; z = p_z;&#125;// 更好的实现是使用memcpyPoint3d::Point3d(const Point3d&amp; p) &#123; memcpy(this, &amp;p, sizeof(Point3d));&#125; 然而memcpy和memset都需要类仅仅含有内置数据类型。 如果含有虚函数或虚基类，vptr和虚基类指针/编译会被错误设置。 5. 成员初始化列表(Member Initialization List)在以下情况，必须使用成员初始化列表 初始化一个引用对象 初始化const对象 调用父类的构造函数，该构造函数有一组参数 调用成员类对象的构造函数，构造函数有一组参数。 如： 12345678910class Word &#123;public: Word() &#123; name_ = 0; cnt_ = 0; &#125;private: String name_; int cnt_;&#125; 该构造函数会产生一个临时对象，并调用临时对象的operator=操作，最后调用析构函数。 1234567891011121314151617181920// 编译器改写Word::Word() &#123; name_.String::String(); String temp = String(0); name_,String::operator=(temp); temp.String::~String(); cnt_ = 0;&#125;// 较好的方式Word::Word() : name_(0) &#123; cnt_ = 0;&#125;// 编译器改写Word::Word() &#123; name_.String::String(0); cnt_ = 0;&#125; 5.1 陷阱成员初始化列表的顺序 初始化列表中的排列方式并不会影响其初始化顺序，在类中的声明顺序才会决定其初始化顺序。 1234567class X &#123;private: int i; int j;public: X(int val) : j(val), i(j) &#123;&#125;&#125;; 上述代码的本意是先将val值给j，然后将j的值给i，然而真正的执行顺序是按照声明顺序，即将j的值给i，再将val的值给j。 为了达成以上目的，应该这么写： 123X::X(int val) : j(val) &#123; i = j;&#125; 成员初始化列表中的操作是位于函数体内语句之前，因此这样可以正常执行。 初始化列表与成员函数 考虑如下构造函数： 12X::X(int val) : i(Func(val)), j(val) &#123;&#125;// Func是X的成员函数 这样写是正确的，然而存在不确定性，因为你并不知道Func对于类X的依赖性是多少。 因此，将初始化过程放在函数体中执行。 子类的成员函数返回值作为父类构造函数的参数 12345678class FooBar : public X &#123;private: int fval_;public: int fval() &#123; return fval_; &#125;; FooBar(int val) : fval_(val), X(fval()) &#123;&#125;&#125;; 编译器改写： 12345FooBar::FooBar &#123; X::X(this, this-&gt;fval()); fval_ = val;&#125; 显然，很糟糕。 总结 编译器会按照变量声明顺序，对初始化列表的顺序重新排列。且会在构造函数中插入代码，这些代码都位于用户编写的代码之前。","categories":[{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"对象模型-1.关于对象","slug":"cpp-对象模型-第一章-关于对象","date":"2020-11-17T06:34:52.000Z","updated":"2021-01-30T01:47:49.408Z","comments":true,"path":"2020/11/17/cpp-对象模型-第一章-关于对象/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"1. c++对象模型类的非static成员变量在类之中，static成员变量和staic/非static成员函数在类之外。 虚函数会在对象存储一个虚函数表指针(vptr)，该指针指向相关的虚函数表(vtbl)，vptr的初始化、重置由类的构造、析构、赋值决定。每一个类的type_info由vtbl指出，存储在第一个表项中。 2. 类的内存大小 非static成员变量的大小总和 内存对齐，4bytes的整数倍 支持虚函数和虚继承的额外开销 3. 多态中的指针1234567891011121314151617class ZooAnimal &#123;public: virtual void dance();private: int ioc; String name;&#125;class Bear : public ZooAnimal &#123;public:private: enum Dances &#123;...&#125;; Dances dances; int cell_block;&#125; 如上的继承体系，Bear类的内存情况如下： 解析时，指针根据指针的类型，读取对应大小的内存","categories":[{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]}],"categories":[{"name":"unp","slug":"unp","permalink":"http://example.com/categories/unp/"},{"name":"apue","slug":"apue","permalink":"http://example.com/categories/apue/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"unix","slug":"unix","permalink":"http://example.com/tags/unix/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]}