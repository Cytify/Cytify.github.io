{"meta":{"title":"Cytify","subtitle":"","description":"","author":"Cytify","url":"http://example.com","root":"/"},"pages":[{"title":"Category","date":"2021-01-27T15:19:38.000Z","updated":"2021-01-27T15:21:12.419Z","comments":true,"path":"category/index.html","permalink":"http://example.com/category/index.html","excerpt":"","text":""},{"title":"Tag","date":"2021-01-27T15:19:15.000Z","updated":"2021-01-27T15:21:27.868Z","comments":true,"path":"tag/index.html","permalink":"http://example.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"创建型模式-原型模式","slug":"创建型模式-原型模式","date":"2020-11-30T14:19:34.000Z","updated":"2020-11-30T14:58:17.519Z","comments":true,"path":"2020/11/30/创建型模式-原型模式/","link":"","permalink":"http://example.com/2020/11/30/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"5、原型模式5.1 原型模式概述**原型模式(Prototype Pattern)**：使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。原型模式是一种对象创建型模式。 工作原理：将一个原型对象传给那个要创建的对象，这个要创建的对象通过请求原型对象克隆自己来实现创建过程 原型模式结构图中包含3个角色： **Prototype(抽象原型类)**：它是声明克隆方法的接口，是所有具体原型类的父类，可以抽象类、接口，还可以是具体实现类。 **ConcretePrototype(具体原型类)**：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 **Client(客户类)**：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。 下面将介绍两种在Java语言中常用的克隆实现方法： 通用实现法 通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传人新创建的对象中，保证它们的成员变量相同。示意代码如下： 12345678910111213141516171819202122232425262728293031#ifndef PROTOTYPE_H#define PROTOTYPE_Hclass Prototype &#123;public: virtual ~Prototype() &#123;&#125; virtual Prototype* Clone() = 0;&#125;;#endif // PROTOTYPE_H#ifndef CONCRETE_PROTOTYPE_H#define CONCRETE_PROTOTYPE_H#include &quot;prototype.h&quot;class ConcretePrototype : public Prototype &#123;public: ConcretePrototype() &#123;&#125; ConcretePrototype(const ConcretePrototype* other) &#123;&#125; virtual ~ConcretePrototype() &#123;&#125; virtual Prototype* Clone() override &#123; return new ConcretePrototype(*this); &#125;&#125;;#endif // CONCRETE_PROTOTYPE_H 在客户类中，只需要创建一个ConcretePrototype对象作为原型对象，然后调用其clone()方法即可得到对应的克隆对象，代码如下： 12345678910#include &lt;cassert&gt;#include &quot;concrete_prototype.h&quot;int main() &#123; Prototype* objl = new ConcretePrototype(); Prototype* obj2 = objl-&gt;Clone(); assert(objl != obj2);&#125; 这种方法可作为原型模式的通用实现，它与编程语言特性无关，任何面向对象语言都可以使用这种形式来实现对原型的克隆。 在原型模式复制时，需要注意浅复制和深复制。 5.2 原型管理器的引入和实现**原型管理器(Prototype Manager)**是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以便扩展。 具体实例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//抽象公文接口，也可定义为抽象类，提供clone()方法的实现,将业务方法声明为抽象方法#ifndef OFFICIAL_DOCUMENT_H#define OFFICIAL_DOCUMENT_Hclass OfficialDocument &#123;public: virtual ~OfficialDocument() &#123;&#125; virtual OfficialDocument* Clone() = 0; virtual void Display() = 0;&#125;;#endif // OFFICIAL_DOCUMENT_H//可行性分析报告(Feasibility Analysis Report)类#ifndef FAR_H#define FAR_H#include &lt;iostream&gt;#include &quot;official_document.h&quot;class Far : public OfficialDocument &#123;public: Far() &#123;&#125; Far(const Far&amp;) &#123;&#125; virtual ~Far() &#123;&#125; virtual OfficialDocument* Clone() override &#123; return new Far(*this); &#125; virtual void Display() override &#123; std::cout &lt;&lt; &quot;&lt;可行性分析报吿&gt;&quot; &lt;&lt; std::endl; &#125;&#125;;#endif // FAR_H//软件需求规格说明书(Software Requirements Specification)类#ifndef SAS_H#define SAS_H#include &lt;iostream&gt;#include &quot;official_document.h&quot;class Sas : public OfficialDocument &#123;public: Sas() &#123;&#125; Sas(const Sas&amp;) &#123;&#125; virtual ~Sas() &#123;&#125; virtual OfficialDocument* Clone() override &#123; return new Sas(*this); &#125; virtual void Display() override &#123; std::cout &lt;&lt; &quot;&lt;软件需求规格说明书&gt;&quot; &lt;&lt; std::endl; &#125;&#125;;#endif // SAS_H//原型管理器(使用饿汉式单例实现)#ifndef PROTOTYPE_MANAGER_H#define PROTOTYPE_MANAGER_H#include &lt;string&gt;#include &lt;map&gt;#include &quot;far.h&quot;#include &quot;sas.h&quot;class PrototypeManager &#123;public: PrototypeManager() &#123; m_ht[&quot;far&quot;] = new Far(); m_ht[&quot;sas&quot;] = new Sas(); &#125; PrototypeManager(const PrototypeManager&amp;) = delete; PrototypeManager&amp; operator=(const PrototypeManager&amp;) = delete; ~PrototypeManager() &#123;&#125; //增加新的公文对象 void AddOfficialDocument(std::string key, const OfficialDocument* doc) &#123; m_ht[key] = const_cast&lt;OfficialDocument*&gt;(doc)-&gt;Clone(); &#125; //通过浅克隆获取新的公文对象 OfficialDocument* GetOfficialDocument(std::string key) &#123; return m_ht[key]-&gt;Clone(); &#125; static PrototypeManager* GetPrototypeManager() &#123; return &amp;ms_pm; &#125;private: std::map&lt;std::string, OfficialDocument*&gt; m_ht; static PrototypeManager ms_pm;&#125;;PrototypeManager PrototypeManager::ms_pm;#endif // PROTOTYPE_MANAGER_H// 客户端代码如下#include &lt;cassert&gt;#include &quot;prototype_manager.h&quot;int main() &#123; PrototypeManager* pm = PrototypeManager::GetPrototypeManager(); OfficialDocument* doc1, *doc2, *doc3, *doc4; doc1 = pm-&gt;GetOfficialDocument(&quot;far&quot;); doc1-&gt;Display(); doc2 = pm-&gt;GetOfficialDocument(&quot;far&quot;); doc2-&gt;Display(); assert(doc1 != doc2); doc3 = pm-&gt;GetOfficialDocument(&quot;sas&quot;); doc3-&gt;Display(); doc4 = pm-&gt;GetOfficialDocument(&quot;sas&quot;); doc4-&gt;Display(); assert(doc3 != doc4);&#125; 5.3 总结原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中应用较为广泛，很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的典型应用。 5.3.1 优点 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 扩展性较好。由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少具体原型类对原有系统都没有任何影响。 原型模式提供了简化的创建结构。工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。 可以使用深克隆的方式保存对象的状态。使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，例如恢复到某一历史状态，可辅助实现撤销操作。 5.3.2 缺点 需要为每个类配备一个克隆方法，而且该克隆方法位于类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则。 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 5.3.3 适用场景 创建新对象成本较大（例如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式（来实现。 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式-抽象工厂模式","slug":"创建型模式-抽象工厂模式","date":"2020-11-21T09:28:52.000Z","updated":"2021-01-27T15:45:18.220Z","comments":true,"path":"2020/11/21/创建型模式-抽象工厂模式/","link":"","permalink":"http://example.com/2020/11/21/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"4、抽象工厂模式4.1 产品等级结构与产品族产品等级结构 产品等级结构即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 示意图如下 同一形状的物品构成了一个产品等级结构，而同一种颜色的物品因为其厂家相同，由同一个工厂生成，所以是一个产品族。 4.2 抽象工厂模式概述抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比， 抽象工厂模式中的具体工厂不只是创建一种产品， 它负责创建一族产品。抽象工厂模式定义如下： **抽象工厂模式(Abstract Factory Pattern)**：提供一个创建一系列相关或相互依赖的对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。 抽象工厂模式结构图中包含以下4个角色： **AbstractFactory(抽象工厂)**：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 **ConcreteFactory(具体工厂)**：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 **AbstractProduct(抽象产品)**：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 **ConcreteProduct(具体产品)**：它定义具体工厂生产的具体产品对象，实现在抽象产品接口中声明的业务方法。 抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下： 123456789class Truck;class Car;class AbstractFactory &#123;public: virtual Truck* GetTruck() = 0; virtual Car* GetCar() = 0;&#125;; 具体工厂实现了抽象工厂， 每一个具体的工厂方法可以返回一个特定的产品对象，一个具体工厂所创建的产品对象构成了一个产品族。 1234567891011121314151617181920212223242526272829303132333435class BmwFactory : public AbstractFactory &#123;public: virtual Truck* GetTruck() override &#123; return new BmwTruck; &#125; virtual Car* GetCar() override &#123; return new BmwCar; &#125;&#125;;class BenzFactory : public AbstractFactory &#123;public: virtual Truck* GetTruck() override &#123; return new BenzTruck; &#125; virtual Car* GetCar() override &#123; return new BenzCar; &#125;&#125;;class BenzTruck : public Truck &#123;public: virtual void SameMethod() override &#123; std::cout &lt;&lt; &quot;I am benz truck\\n&quot;; &#125;&#125;;class BenzCar : public Car &#123;public: virtual void SameMethod() override &#123; std::cout &lt;&lt; &quot;I am benz car\\n&quot;; &#125;&#125;; 4.3 开闭原则的倾斜性抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为开闭原则的倾斜性。 如，需要在按钮中增加一个radioButton，则需要在抽象工厂和具体工厂中逐一修改代码，违反开闭原则。 增加产品族。对于增加新的产品族，抽象工厂模式很好地支持了开闭原则，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。 增加产品等级结构。对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了开闭原则。 正因为抽象工厂模式存在开闭原则的倾斜性，因此要求设计人员在设计之初就能够全面考虑，产品等级结构不会再日后的维护总发生变化。 4.4 总结4.4.1 优点 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了在抽象工厂中声明的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。因为只用了一个工厂创建。 增加新的产品族很方便，无须修改已有系统，符合开闭原则。 4.4.2 缺点增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则。 4.4.3 适用场景 系统中有多于一个的产品族，而每次只使用其中某一产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束。例如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式-工厂模式","slug":"创建型模式-工厂模式","date":"2020-11-21T09:06:21.000Z","updated":"2020-11-21T09:27:33.218Z","comments":true,"path":"2020/11/21/创建型模式-工厂模式/","link":"","permalink":"http://example.com/2020/11/21/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"3、工厂模式3.1 工厂模式概述工厂方法模式(Factory Method Pattern)**：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual ConstructorPattern)或多态工厂模式(Polymorphic Factory Pattern)**。工厂方法模式是一种类创建型模式。 工厂模式包含四个角色 **Product(抽象产品)**：定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的父类。 **ConcreteProduct(具体产品)**：它实现了抽象产品接口，具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 Factory(抽象工厂)**：在抽象工厂类中，声明了工厂方法(Factory Method)**，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 **ConcreteFactory(具体工厂)**：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 具体实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//日志记录器接口：抽象产品class Logger &#123;public: virtual void Log() = 0;&#125;;//数据库日志记录器：具体产品class DatabaseLogger : public Logger &#123;public: virtual void Log() override &#123; std::cout &lt;&lt; &quot;database log\\n&quot;; &#125;&#125;;//文件日志记录器：具体产品class FileLogger : public Logger &#123;public: virtual void Log() override &#123; std::cout &lt;&lt; &quot;file log\\n&quot;; &#125;&#125;;//日志记录器工厂接口：抽象工厂// 使用前置声明减少头文件依赖class Logger;class Factory &#123;public: virtual Logger* GetLogger() = 0;&#125;;//数据库日志记录器工厂类：具体工厂class DatabaseLoggerFactory : public Factory &#123;public: virtual Logger* GetLogger() override &#123; return new DatabaseLogger; &#125;&#125;;//文件日志记录器工厂类：具体工厂class FileLoggerFactory : public Factory &#123;public: virtual Logger* GetLogger() override &#123; return new FileLogger; &#125;&#125;;// 客户端代码使用如下：int main(int argc, char* argv[]) &#123; Factory* factory; Logger* log; factory = new DatabaseLoggerFactory; log = factory-&gt;GetLogger(); log-&gt;Log();&#125; 3.2 工厂方法的隐藏可在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。 12345678910111213141516class Factory &#123;public: virtual Logger* GetLogger() = 0; virtual void Log() &#123; Logger* logger = this-&gt;GetLogger(); logger-&gt;Log(); delete logger; &#125;&#125;;int main(int argc, char* argv[]) &#123; Factory* factory; factory = new FileLoggerFactory; factory-&gt;Log();&#125; 将业务方法移入工厂类，可以直接使用工厂对象来调用产品对象的业务方法，客户端无须直接使用工厂方法。 3.3 总结3.3.1 优点 在工厂模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加人新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。可扩展性好，完全符合开闭原则。 3.3.2 缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，类的个数将成对增加，增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。 3.3.3 适用场景 客户端不知道其所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"多线程--2、管理线程","slug":"c-并发","date":"2020-11-21T05:44:03.000Z","updated":"2020-11-22T11:29:59.744Z","comments":true,"path":"2020/11/21/c-并发/","link":"","permalink":"http://example.com/2020/11/21/c-%E5%B9%B6%E5%8F%91/","excerpt":"","text":"介绍看《c++并发编程实战》，采用**c++11的thread库(非posix thread)**来学习多线程。以后有空会看看posix thread。 开发平台 windows vs2019 或 clion mingw 为什么使用并发划分关注点——使用并发 将功能不同的代码分离，使用不同的线程进行。有益于理解代码和降低耦合。 提高性能——使用并发 多核系统，并行处理任务，加快任务执行速度。 为什么不使用并发 唯一原因：收益比不上成本 并发代码的复杂度 启动线程的开销，操作系统会分配相关内核资源和堆栈空间 操作系统资源是有限的，太多线程会使操作系统运行变慢（可以使用线程池来优化） 操作系统在线程切换时，进行上下文切换，同样，耗费的时间时间有可能比原本的时间更多 基本线程管理每个c++程序都至少有一个线程，在程序运行时启动，线程运行**main()函数**。 启动线程启动线程使用std::thread类，它可以于任何**可调用(callable)**的类型一同工作。 函数对象作为参数 类中定义**operator()**后，类可作为参数，thread执行operator()中的代码。 函数对象传递时，是以一个临时对象传递 lambda表达式作为参数 一旦声明了thread对象，你需要**在对象销毁前声明线程的运行方式(join—等待完成，detach—自行运行)**，否则程序会被终止。 如果使线程自行运行，需要注意，线程有可能访问已销毁的变量。为此，可以将数据复制到线程中，但是仍需要小心指针和引用。 等待线程完成使用join()即可等待线程完成，可以确保数据访问安全。调用join()会清理所有与该线程相关的存储器，thread对象也不会和现有线程关联。即一旦调用了join()，thread对象就不可连接了，且**joinable()**也会返回false。 joinable()判断**当前的线程是否是可执行线程(能被join或者detach)**，常不能被joinable有以下几种情况： 由thread的缺省构造函数而造成的（thread()没有参数） 该线程被move过（包括move构造和move赋值） 该线程被join或者detach过 在异常环境下等待线程如果函数需要捕捉异常，则需要谨慎考虑join()的位置，确保所有退出路径都调用了join()。 为了简化处理，可以使用**资源获取即初始化(RAII)**的方式对线程进行处理，在析构函数中调用join()或detach()。 1234567891011121314151617181920class ThreadGuard &#123;public: explicit ThreadGuard(std::thread&amp; t) : m_t(t) &#123;&#125; ~ThreadGuard() &#123; if (m_t.joinable()) &#123; m_t.join(); &#125; &#125; // 确保编译器不产生默认复制构造/operator= ThreadGuard(const ThreadGuard&amp;) = delete; ThreadGuard&amp; operator=(const ThreadGuard&amp;) = delete;private: std::thread&amp; m_t;&#125;;// 调用方式std::thread thread(Func);ThreadGuard g(thread); 在函数结束时，会逆序调用析构函数，线程可以正常进行并被join。 在后台运行线程thread对象调用detach后会把线程放在后台运行，所有权转交给c++运行时库。被分离的线程常称为**守护线程(daemon threads)**，常用来执行后台任务，如：监控文件系统，清除对象缓存，优化数据结构等。 例：多页面文档编译器，每打开一个文档，即使用一个分离的线程。 线程传递参数传递参数即将参数放入thread构造函数中，但是参数默认以复制的方式传递。 如果函数需要的使引用参数，但thread的构造函数并不处理参数，全部以复制传递。需要使用**std::ref**包装需要引用传递的参数。 如：std::thread t(Func, std::ref(data))，该机制与std::bind类似，因此，可以将成员函数作为线程 12345678class X &#123;public: void Func() &#123;&#125;&#125;;X x;std::thread thread1(&amp;X::Func, &amp;x);thread1.join(); 这将调用x的Func()，因为x的地址是作为对象指针传递的，thread的第三个参数作为成员函数的第一个参数。 使用移动传递参数 移动语义，c++11中新规定，即类的持有者只有一个，如std::unique_ptr。在传参时，我们需要使用std::move() 1234void Func(std::unique_ptr&lt;Object&gt;);std::unique_ptr&lt;Object&gt; ptr(new Object);std::thread t(Func, std::move(ptr)); 转移线程的所有权转移现成的所有权同样使用std::move() 1234void Func();std::thread t1(Func);std::thread t2 = std::move(t1); 不能将线程移动给一个已经有相关联的线程，否则会终止程序（调用std::terminate()）","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"创建型模式-简单工厂模式","slug":"创建型模式-简单工厂模式","date":"2020-11-19T10:53:52.000Z","updated":"2020-11-21T09:05:37.535Z","comments":true,"path":"2020/11/19/创建型模式-简单工厂模式/","link":"","permalink":"http://example.com/2020/11/19/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"2、简单工厂模式2.1 简单工厂模式概述简单工厂模式并不属于23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下： 首先将需要创建的各种不同对象的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传人相应的参数即可得到一个产品对象。 简单工厂模式(Simple Factory Pattern)**：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法， 因此简单工厂模式又被称为静态工厂方法(StaticFactory Method)**模式，它属于类创建型模式。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 在简单工厂模式结构图中包含以下3个角色。 Factory(工厂角色)：即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。 Product(抽象产品角色)：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引人将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。 ConcreteProduct(具体产品角色)：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#ifndef PRODUCT_H#define PRODUCT_Hclass Product &#123;public: // 所有类公共的方法 void SameMethod() &#123;&#125; // 所有子类的抽象方法 virtual void DiffMethod() = 0;&#125;;#endif // PRODUCT_H#ifndef CONCRETE_PRODUCT_H#define CONCRETE_PRODUCT_H#include &lt;iostream&gt;#include &quot;product.h&quot;class ConcreteProduct : public Product &#123;public: ConcreteProduct() &#123;&#125; ~ConcreteProduct() &#123;&#125; virtual void DiffMethod() override &#123; std::cout &lt;&lt; &quot;I am working!\\n&quot;; &#125;&#125;;#endif // CONCRETE_PRODUCT_H#ifndef FACTORY_H#define FACTORY_H#include &quot;product.h&quot;#include &quot;concerate_product.h&quot;class Factory &#123;public: // 产品用enum声明 static Product* GetProduct(int product_type) &#123; switch (product_type) &#123; case 0: return new ConcreteProduct; break; default: return nullptr; break; &#125; &#125;&#125;;#endif // FACTORY_H#include &quot;product.h&quot;#include &quot;concerate_product.h&quot;#include &quot;factory.h&quot;int main(int argc, char* argv[]) &#123; Product* product = Factory::GetProduct(0); product-&gt;DiffMethod(); delete product;&#125; 2.2 简单工厂模式的简化可以将抽象产品类和工厂类合并，将静态工厂方法放到抽象产品类中，如图： 2.3 总结2.3.1 优点 工厂类可包含判断逻辑，决定创建哪个产品类；使用者直接使用对象，无需创建。简单工厂模式实现了对象创建和使用的分离。 使用者无须知道产品类的类名，简单工厂模式可以在一定程度减少使用者的记忆量。 配置文件(java)，可以在不修改代码的情况下更换和增加新的产品类，提高了系统的灵活性。 2.3.2 缺点 工厂类集中了所有产品的创建逻辑，职责重，一旦不能正常工作，整个系统都要受到影响。 简单工厂模式会增加系统中类的个数(引入新的工厂类)，增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品需要修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 2.3.3 适用场景 工厂类负责创建的对象比较少，由于创建的对象较少，工厂方法中的业务逻辑不会复杂。 使用者只知道传入工厂类的参数，对于如何创建对象并不关心。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"创建型模式--单例模式","slug":"创建型模式-单例模式","date":"2020-11-17T07:16:46.000Z","updated":"2020-11-19T11:04:02.974Z","comments":true,"path":"2020/11/17/创建型模式-单例模式/","link":"","permalink":"http://example.com/2020/11/17/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"1、单例模式1.1 单例模式概述**单例模式(Singleton Pattern)**：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。 单例模式有3个要点： 某个类只能有一个实例 它必须自行创建这个实例 它必须自行向整个系统提供这个实例 单例模式UML图如下： 在单例类的内部只生成一个实例， 同时它提供一个静态的GetInstance()方法，让客户可以访问它的唯一实例；为了防止在外部对单例类实例化，它的构造函数可见性为private；在单例类内部定义了一个Singleton类型的静态对象，作为供外部共享访问的唯一实例。 1.2 可能存在的问题当第一次调用getInstance()方法创建对象，instance对象为null值，因此系统将执行代码instance = newInstance()，在此过程中，如果对象的创建需要做很大量初始化工作，则需要一段时间创建对象。而在此时，如果在此调用getInstance()(多线程)，则会多次创建对象，引发错误。 1.3 饿汉式单例和懒汉式单例1.3.1 饿汉式单例","text":"1、单例模式1.1 单例模式概述**单例模式(Singleton Pattern)**：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。 单例模式有3个要点： 某个类只能有一个实例 它必须自行创建这个实例 它必须自行向整个系统提供这个实例 单例模式UML图如下： 在单例类的内部只生成一个实例， 同时它提供一个静态的GetInstance()方法，让客户可以访问它的唯一实例；为了防止在外部对单例类实例化，它的构造函数可见性为private；在单例类内部定义了一个Singleton类型的静态对象，作为供外部共享访问的唯一实例。 1.2 可能存在的问题当第一次调用getInstance()方法创建对象，instance对象为null值，因此系统将执行代码instance = newInstance()，在此过程中，如果对象的创建需要做很大量初始化工作，则需要一段时间创建对象。而在此时，如果在此调用getInstance()(多线程)，则会多次创建对象，引发错误。 1.3 饿汉式单例和懒汉式单例1.3.1 饿汉式单例 1234567891011121314151617181920212223242526272829303132333435363738394041424344// EagerSingleten.h/******************************************************* * author : Cytify * date : 20201117 22:33 * version : 1.0 * desc : 饿汉单例*******************************************************/#ifndef eager_singleton_h_#define eager_singletn_h_class EagerSingleton &#123;public: static EagerSingleton* GetInstance() &#123; return ms_instance; &#125; void Delete(); private: EagerSingleton(); ~EagerSingleton(); EagerSingleton(const EagerSingleton&amp; signal); const EagerSingleton&amp; operator=(const EagerSingleton&amp; signal); static EagerSingleton* ms_instance;&#125;;#endif// EagerSingleten.cpp#include &quot;EagerSingleton.h&quot;// 初始化ms_instanceEagerSingleton* EagerSingleton::ms_instance = new EagerSingleton();void EagerSingleton::Delete() &#123; if (ms_instance) &#123; delete ms_instance; ms_instance = nullptr; &#125;&#125; 当类被加载时，静态变量ms_instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。 1.3.2 懒汉式单例 懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为**延迟加载(Lazy Load)**技术，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/******************************************************* * author : Cytify * date : 20201119 18:38 * version : 1.0 * file : lazy_singleton * desc : 加锁的懒汉单例*******************************************************/#ifndef LAZY_SINGLETON_H#define LAZY_SINGLETON_H#include &lt;mutex&gt;class LazySingleton &#123;public: static LazySingleton* GetInstance(); static void DeleteInstance();private: LazySingleton(); ~LazySingleton(); LazySingleton(const LazySingleton&amp;); const LazySingleton&amp; operator=(const LazySingleton&amp;); static LazySingleton* ms_instance; static std::mutex ms_mutex;&#125;;#endif // LAZY_SINGLETON_H/******************************************************* * author : Cytify * date : 20201119 18:39 * version : 1.0 * file : lazy_singleton.cpp * desc : 实现lazy_singleton.h*******************************************************/#include &quot;lazy_singleton.h&quot;LazySingleton* LazySingleton::ms_instance = nullptr;std::mutex LazySingleton::ms_mutex;LazySingleton* LazySingleton::GetInstance() &#123; // 使用双重检查锁的机制，只在判断指针为空的情况下才加锁 // 在多线程的情况下，这样可以减少开销 if (ms_instance = nullptr) &#123; // 使用unique_lock，类似于使用智能指针 std::unique_lock&lt;std::mutex&gt; lock(ms_mutex); if (ms_instance == nullptr) &#123; ms_instance = new (std::nothrow)LazySingleton(); &#125; &#125; return ms_instance;&#125;void LazySingleton::DeleteInstance() &#123; std::unique_lock&lt;std::mutex&gt; lock(ms_mutex); // 加锁 if (ms_instance) &#123; delete ms_instance; ms_instance = nullptr; &#125;&#125; 另一种实现方式 12345678910111213141516171819class LazySingleton &#123; private volatile static LazySingleton instance = null; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; //第一重判断 if (instance == null) &#123; //锁定代码块 synchronized (LazySingleton.class) &#123; //第二重判断 if (instance == null) &#123; instance = new LazySingleton(); //创建单例实例 &#125; &#125; &#125; return instance; &#125;&#125; 1.3.3 饿汉式单例类与懒汉式单例类比较饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。 但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。 懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理多线程，特别是当单例类实例化时涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的几率变得较大， 需要通过双重检查锁定等机制进行控制， 这将导致系统性能受到一定影响。 1.4 较好的单例实现方法123456789101112131415161718192021222324252627282930313233343536373839/******************************************************* * author : Cytify * date : 20201119 18:38 * version : 1.0 * file : lazy_singleton * desc : 局部静态变量的懒汉单例*******************************************************/#ifndef LAZY_SINGLETON_H#define LAZY_SINGLETON_Hclass LazySingleton &#123;public: static LazySingleton* GetInstance();private: LazySingleton(); ~LazySingleton(); LazySingleton(const LazySingleton&amp;); const LazySingleton&amp; operator=(const LazySingleton&amp;);&#125;;#endif // LAZY_SINGLETON_H/******************************************************* * author : Cytify * date : 20201119 18:39 * version : 1.0 * file : lazy_singleton.cpp * desc : 实现lazy_singleton.h*******************************************************/#include &quot;lazy_singleton.h&quot;LazySingleton* LazySingleton::GetInstance() &#123; static LazySingleton lazy_singleton; return &amp;lazy_singleton;&#125; 这种方法代码少，无加锁，且能保证线程安全。 1.5 总结1.5.1 优点 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。 由于在只存在一个对象，可节约系统资源，对于一些需要频繁创建和销毁的对象，可以提高系统的性能。 可以获得多个对象。进行扩展，获得指定个数的实例对象，既节省系统资源，又解决了由于单例对象共享过多有损性能的问题。 1.5.2 缺点 单例模式没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了单一职责原则。因为单例类既提供了业务方法， 又提供了创建对象的方法(工厂方法) ， 将对象的创建和对象本身的功能耦合在一起。 自动垃圾回收技术可能会自动销毁并回收资源，这将导致共享的单例对象状态的丢失。 1.5.3 适用场景 系统只需要一个实例对象。如，系统要求提供一个唯一的序列号生成器或资源管理器，或资源消耗太大而只允许创建一个对象。 类的单个实例只在某一个地方被使用，除此之外，不会再其他地方调用。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"cpp-对象模型-第四章-函数","slug":"cpp-对象模型-第四章-函数","date":"2020-11-17T06:42:00.000Z","updated":"2020-11-17T06:44:21.393Z","comments":true,"path":"2020/11/17/cpp-对象模型-第四章-函数/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%87%BD%E6%95%B0/","excerpt":"成员函数的调用非静态成员函数(Nonstaic Member Function)成员函数会经过编译器转换为非成员函数： 改变函数的声明，新增一个额外参数，用于访问类内的数据和函数。 123456class Point3d;// non-constPoint3d Point3d::Magnitude(); -&gt; Point3d Point3d::Magnitude(Point3d *const this);// constPoint3d Point3d::Magnitude() const; -&gt; Point3d Point3d::Magnitude(const Point3d *const this); 对成员的访问操作变为this指针的访问 转换函数名称——mangling方法(第三章数据部分提到，用于转换static变量名) 转换后，函数的调用也需要被转换 1234567class Point3d;Point3d obj;Point3d *ptr = new Point3d;// 假设Magnitude名称转换为Magnitude_7Point3dFvobj.Magnitude(); -&gt; Magnitude_7Point3dFv(&amp;obj);ptr-&gt;Magnitude(); -&gt; Magnitude_7Point3dFv(ptr); 假设有如下代码： 1234567891011Point3d Point3d::Normalize() const &#123; register float msg = Magnitude(); return Point3d( x_/msg, y_/msg, z_/msg);&#125;// 经过转换，以及NRV优化void Normalize_7Point3dFv(register const Point3d* const this, Point3d&amp; _result) &#123; register float msg = this-&gt;Magnitude(); _result.Point3d::Point3d(this-&gt;x_/msg, this-&gt;y_/msg, this-&gt;z_/msg); return;&#125;","text":"成员函数的调用非静态成员函数(Nonstaic Member Function)成员函数会经过编译器转换为非成员函数： 改变函数的声明，新增一个额外参数，用于访问类内的数据和函数。 123456class Point3d;// non-constPoint3d Point3d::Magnitude(); -&gt; Point3d Point3d::Magnitude(Point3d *const this);// constPoint3d Point3d::Magnitude() const; -&gt; Point3d Point3d::Magnitude(const Point3d *const this); 对成员的访问操作变为this指针的访问 转换函数名称——mangling方法(第三章数据部分提到，用于转换static变量名) 转换后，函数的调用也需要被转换 1234567class Point3d;Point3d obj;Point3d *ptr = new Point3d;// 假设Magnitude名称转换为Magnitude_7Point3dFvobj.Magnitude(); -&gt; Magnitude_7Point3dFv(&amp;obj);ptr-&gt;Magnitude(); -&gt; Magnitude_7Point3dFv(ptr); 假设有如下代码： 1234567891011Point3d Point3d::Normalize() const &#123; register float msg = Magnitude(); return Point3d( x_/msg, y_/msg, z_/msg);&#125;// 经过转换，以及NRV优化void Normalize_7Point3dFv(register const Point3d* const this, Point3d&amp; _result) &#123; register float msg = this-&gt;Magnitude(); _result.Point3d::Point3d(this-&gt;x_/msg, this-&gt;y_/msg, this-&gt;z_/msg); return;&#125; 函数名称转换(Name Mangling)不同编译器的做法不同。以下仅介绍cfront的做法。 类的数据成员通常会加上类名，会变成独特的名称。可以有效防止子类和父类拥有相同变量名。 123456789class Bar &#123; public: int val_; -&gt; val_3Bar&#125;;class Foo : public Bar &#123;public: int val_; -&gt; val_3Foo&#125; 函数由于可以重载。会在函数名后加上类名，再加上参数列表中的类型。 12345class Point &#123;public: void x(float x); -&gt; void x_5PointFf(float x); void x(float x, float y); -&gt; void x_5PointFff(float x, float y);&#125; 名称转换的目的是为了使不正确的调用操作在链接期就被检测出来。比如重载函数调用不正确等。 虚成员函数(Virtual Member Function)虚函数通过虚函数指针指向的虚函数表调用。 虚函数表，第一格是RTTI有关数据，之后的是虚函数地址。有些编译器将虚函数表-1位置设置为虚基类地址/偏移。 虚函数的转换 1ptr-&gt;Normalize(); -&gt; (*ptr-&gt;vptr[1])(ptr); vptr为虚函数指针，在单继承体系中只有一个，但是在多继承体系中会有多个，因此有可能需要名称转换。 vptr[1]是函数的地址，即Noemalize()函数地址。 第二个ptr为this指针。 12345Point3d Point3d::Normalize() const &#123; register float msg = Magnitude(); return Point3d( x_/msg, y_/msg, z_/msg);&#125;// 假设Magnitude和Noemalize都是虚函数 优化tips 因为Magnitude()**是确定的，所以直接显式调用**会比虚指针转换调用更好。 即，register float msg = Point3d::Magnitude(); 显式调用虚函数，调用过程与非静态成员函数相同 Magnitude()编写为内联函数，更有效率 静态成员函数(Static Member Function)静态函数的调用与非静态成员函数类似，但有区别，**不会增加额外参数(this指针)**。 12obj.Noemalize(); -&gt; Normalize_7Point3dSFv();ptr-&gt;Normalize(); -&gt; Normalize_7Point3dSFv(); 静态成员函数也需要被转化，其中SFv表示是静态成员函数 静态成员函数不需要通过类的实例调用 1234foo.Obj() &gt; 1;// 转换为(void) foo(); // NRVPoint3d::Obj() &gt; 1; 这样会有额外成本 静态成员函数的地址是非成员函数的地址 &amp;Point3d::Obj(); == unsigned int (*)(); != unsigned int (Point3d::*)(); 静态成员函数可以便于成为回调函数(callback)**，可用于线程函数(pthread)** 虚函数(Virtual Member Function)单一继承为了支持多态，需要对类提供额外的执行期信息。 每个对象设置一个虚指针，指向虚函数表 虚函数表中设置类的类型信息（支持RTTI），以及虚函数地址 对于虚函数的继承来说，会有以下操作： 父类的虚函数会被子类继承 子类的虚函数会重载父类的虚函数，即在虚函数表中覆盖父类虚函数 子类的新虚函数会加入到虚函数表中，新的虚函数会被放到虚函数表末尾 存在一个pure_virtual_called()函数，它可以是纯虚函数，也可以当作执行器异常处理函数 如： 123456789101112131415161718192021222324252627class Point &#123;public: virtual ~Point(); virtual POint&amp; Mult(float) = 0; virtual float y() const &#123; return 0; &#125; virtual float z() const &#123; return 0; &#125;private: float x_;&#125;class Point2d : public Point &#123;public: virtual ~Point2d(); virtual POint2d&amp; Mult(float); virtual float y() const &#123; return y_; &#125;private: float y_;&#125;class Point3d : public Point2d &#123;public: virtual ~Point3d(); virtual POint3d&amp; Mult(float) = 0; virtual float z() const &#123; return z_; &#125;private: float z_;&#125; 因此，ptr-&gt;z();会被转换为(ptr-&gt;_vptr[4])(ptr) 这一转换在编译器即可完成，但在执行期才能知道调用的是哪一个类的z() 多继承复杂度主要是：第二个之后的父类，以及调用时this指针的转换问题 12345678910111213141516171819202122232425262728class Base1 &#123;public: Base1(); virtual ~Base1(); virtual void SpeakClearly(); virtual Base1* Clone() const;private: float data_base1_;&#125;;class Base2 &#123;public: Base2(); virtual ~Base2(); virtual void Mumble(); virtual Base2* Clone() const;private: float data_base2_;&#125;;class Derived : public Base1, public Base2 &#123;public: Derived(); virtual ~Derived(); virtual Derived* Clone() const;private: float data_derived_;&#125;; 如果以父类指针指向子类，则对于Base1则没问题，因为Base1地址与子类地址相同，而Base2则需要加减偏移this指针来对齐地址。在调用析构函数时也需要调整this指针。 假设有 Base2 *pbase2 = new Derived，Derived对象的地址需要被调整到Base2子对象的地址。 Derived *temp = new Derived; Base2 *pbase2 = tmep ? temp + sizeof(Base1) : 0; 在删除时，也需要调整指针到整个Derived对象地址。 多重继承之下的含有虚函数的对象模型： 含有多个虚函数表，虚函数表数目与父类数目有关 每一个虚函数表，子类都有一个虚指针对应 对于本例，则有两个虚函数表创建 一个主要实例，子类的虚函数表，与最左端的Base1类共享，涵盖整个对象的虚函数 一个次要实例，与Base2类相关，不包含Base1，即左边的父类的相关虚函数 例如：Base *pb1 = new Derived; Base2 *pb2 = pb1-&gt;Clone(); pb1首先加上offset，调整到Derived类地址，调用Derived::Clone()，返回值需要减去offset，调整到Base2的地址。 Sun编译器 Sun编译器为了解决多虚函数表问题，将虚函数表连在一起，加上指针指向下一个虚函数表，提升了项目的速度。 在虚函数足够小时，使用split function，将函数调整为两个函数，第二个在返回之前，为指针加减offset。 因此，Base1指针和Derived指针不需要调整this指针，而Base2指针调用的是新的函数。 Microsoft使用address points的方法。 虚拟继承1234567891011121314151617181920class Point2d &#123;public: Point2d(float = 0.0, float =0.0); virtual ~Point2d(); virtual void Mumble(); virtual float Z():private: float x_, y_;&#125;;class Point3d : public virtual Point2d &#123;public: Point3d(float = 0.0, float = 0.0, float = 0.0); virtual ~Point3d(); virtual float Z();private: float z_;&#125; 不同编译器对于虚继承下的虚函数有着眼花缭乱的支持，这里不做详述，太怪异了。 但是谨记，不要在虚基类中声明非静态数据成员。 函数的效率 友元函数、静态成员函数、非静态成员函数的效率差不多，这是易于理解的，因为三者最终的调用方式相同，都被转换为非成员函数。 单继承虚函数需要通过构造函数设定vptr，所以效率降低了。 多继承虚函数有多方面因素，因为多继承，所以构造函数需要多调用一次，其次，可能需要调整this指针而导致效率进一步降低。 虚拟继承虚函数与多继承类似 指向成员函数的指针非静态、非虚成员函数指针 取非静态、非虚成员函数的地址，得到的是真正地址，但是调用的话需要绑定一个函数对象。 123456double Point::M();// 声明如下double (Point:: *ptr_f) ();// 调用origin.*ptr_f(); -&gt; (ptr_f)(&amp;origin);ptr-&gt;*ptr_f(); -&gt; (ptr_f)(ptr); 虚成员函数指针 取虚函数的地址，得到的是其在虚函数表中的下标。（在vs2019上测试，结果并不是这样，得到的是一个内存地址） 1234float (Point:: *ptr_f) ();Point *ptr = new Point3d;(ptr-&gt;*ptr_f)(); -&gt; *(ptr-&gt;vptr[(int)ptr_f])(ptr); 为了区分函数指针指向的是非虚函数还是虚函数，编译器必须使ptr_f能够持有两种值，且可以被区分是内存地址还是虚函数表的下标 在cfron中，如此判断 1(((int) ptr_f) &amp; ~127) ? (*ptr_f)(ptr) : *(ptr-&gt;vptr[(int)ptr_f])(ptr); 这样只能限制最多只有128个虚函数。 多重继承下，成员函数指针为了使成员函数指针支持多重继承和虚拟继承，有以下结构体 12345678struct _mptr &#123; int delta; int index; union &#123; ptrtofunc faddr; int v_offset; &#125;;&#125;; delta指this指针的offset，index指虚函数表的下标，faddr指非虚成员函数地址（当index不指向虚函数表时，设为-1），v_offset指虚基类或多重继承的第二父类的vptr位置。 但是这样每次通过成员函数指针调用都会判断一次。被人诟病。 Microsoft引入vcall thunk，因此，faddr要么指向函数地址、要么指向vcall thunk地址，vcall thunk会自动选定虚函数表中的下标，调用。 该结构体的一个副作用是，当传递一个固定值给成员函数时，可能会产生临时对象。 效率 内联函数(Inline Function)inline只是个请求，是否被接受，还得看编译器的是否认可inline的做法。 在cfront中，有一套测试法，两个阶段： 分析函数定义，决定函数的**”intrinsic inline ability”**(编译器相关的inline能力) 如果函数因复杂度、建构等问题，不可成为inline，则会转化为static函数 真正的inline函数扩展操作，实在调用函数的那一点上。这会带来参数的求值以及临时对象。 1new_pt.x(lhs.x() + rhs.x()); -&gt; new_pt.x = lhs.x_ + x_5PointFV(&amp;rhs); 这样扩张没有效率提升，所以不会被inline请求不会被处理。 形式参数 inline函数的形式参数都会被实际参数取代 如果实际参数会导致副作用，会引入临时对象 如果实际参数是常量表达式，直接求值 1234567891011121314151617181920inline int Min(int i, int k) &#123; reutrn i &lt; j ? i : j;&#125;inline int bar &#123; int minval; int val1 = 1024; int val2 = 2048; // 实参代替形参 minval = Min(val1, val2); -&gt; minval = val1 &lt; val2 ? val1 : val2; // 常量表达式，计算结果作为返回值 minval = Min(1024, 2048); -&gt; minval = 1024; // 副作用，引入临时对象 minval = Min(foo(), bar() + 1); -&gt; int t1, t2; -&gt; minval = (t1 = foo()), (t2 = Bar() + 1), r1 &lt; t2? t1 : t2; return minval;&#125; 局部变量inline函数中的局部变量会在inline函数被调用时被维护。因为这一点，如果参数有副作用，可能会导致扩展码变大。 因此inline函数作为宏的安全处理，为此可能需要扩大扩展码，需要谨慎处理。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"cpp-对象模型-第三章-数据","slug":"cpp-对象模型-第三章-数据","date":"2020-11-17T06:38:32.000Z","updated":"2020-11-17T06:41:16.076Z","comments":true,"path":"2020/11/17/cpp-对象模型-第三章-数据/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE/","excerpt":"类的大小1234class X &#123;&#125;;class Y : public virtual X &#123;&#125;;class Z : public virtual X &#123;&#125;;class A ; public Y, public Z &#123;&#125;: 以上的继承体系中，类的大小会根据编译器的处理而变化。 X为1bytes，Y，Z为8bytes，A为12bytes X为1bytes 编译器为了确保类的不同对象具有不同地址，会为空类内部安插一个char。 Y，Z为8bytes 首先，我们需要知道，Y，Z的大小收到三部分影响： 语言本身的负担 虚基类、虚函数都会是类内部扩张，具体显示在某种形式的指针(或offset)上。 虚基类的指针会指向虚基类或相关表格或具体偏移量。 虚函数的指针则是指向虚函数表。 编译器对特殊情况的优化 Y，Z是空类，因此需要一个char，被放在类的固定部分的尾部。 某些编译器会对空虚基类进行特殊支持。 内存地址对齐 为了使的读取更有效率，会将内存扩大到4的倍数。 A的12bytes 一个虚基类只会在子类中存在一份实例 因此，A的大小如下： 唯一一份X的实例，1bytes 父类Y的大小，减去虚基类的就开销，结果使4bytes，X同理 A自己的大小，0 对齐，前三项为9bytes，因此最终是12bytes X为1bytes，Y，Z为4bytes，A为8bytes Y，Z为4bytes 有些编译器对空虚基类优化，将其放到子类的最初部分，这样子类就有了member，也就不会有第二点1个char的填充，也不需要对齐，因此只需4bytes。 A为8bytes 有些编译器对空虚基类优化，X实例的1bytes可以省略，因此也没有对齐，所以使8bytes 注意：编译器的的优化仅仅针对空虚基类","text":"类的大小1234class X &#123;&#125;;class Y : public virtual X &#123;&#125;;class Z : public virtual X &#123;&#125;;class A ; public Y, public Z &#123;&#125;: 以上的继承体系中，类的大小会根据编译器的处理而变化。 X为1bytes，Y，Z为8bytes，A为12bytes X为1bytes 编译器为了确保类的不同对象具有不同地址，会为空类内部安插一个char。 Y，Z为8bytes 首先，我们需要知道，Y，Z的大小收到三部分影响： 语言本身的负担 虚基类、虚函数都会是类内部扩张，具体显示在某种形式的指针(或offset)上。 虚基类的指针会指向虚基类或相关表格或具体偏移量。 虚函数的指针则是指向虚函数表。 编译器对特殊情况的优化 Y，Z是空类，因此需要一个char，被放在类的固定部分的尾部。 某些编译器会对空虚基类进行特殊支持。 内存地址对齐 为了使的读取更有效率，会将内存扩大到4的倍数。 A的12bytes 一个虚基类只会在子类中存在一份实例 因此，A的大小如下： 唯一一份X的实例，1bytes 父类Y的大小，减去虚基类的就开销，结果使4bytes，X同理 A自己的大小，0 对齐，前三项为9bytes，因此最终是12bytes X为1bytes，Y，Z为4bytes，A为8bytes Y，Z为4bytes 有些编译器对空虚基类优化，将其放到子类的最初部分，这样子类就有了member，也就不会有第二点1个char的填充，也不需要对齐，因此只需4bytes。 A为8bytes 有些编译器对空虚基类优化，X实例的1bytes可以省略，因此也没有对齐，所以使8bytes 注意：编译器的的优化仅仅针对空虚基类 数据成员的绑定1234567891011extern float x;class Point3d &#123;public: Point3d(float, float, float); float X() const &#123; reuturn x; &#125; void X(float new_x) const &#123; x = new_x; &#125;private: float x, y, z;&#125; 如今，我们都知道Point3d::X()传回的使类内部的x，然而在早期的编译器上，传回的是全局的x。 为此，为了防止这种情况发生，c++早期有两种防御性程序设计风格 将所有的成员变量放在类声明开始处，确保正确的绑定 将所有的内联函数，无论大小都放到类声明之外 这个古老的语言规则称为”member rewriting rule“，意为一个内联函数在整个类声明结束之前，是不会被解析的。 c++标准以”member scope resolution rules“来精练”rewriting rule“。 然而，这对成员函数的参数列表并不为真，参数列表中的参数在第一次遇见时还是会被解析。因此extern和嵌套typedef还是会出错。如： 1234567891011typedef int length;class Point3d &#123;public: // 此时length被解析为int，val_被解析为Point3d::val_ void Mumble(length val) &#123; val_ = val; &#125; length Mumble() &#123; return val_; &#125;private: typedef float length; length val_;&#125; 因此，需要把类中的嵌套typedef放到类的起始处。 数据成员的布局12345678class Point3d &#123;private: float x_; static List&lt;Point3d*&gt; *free_list_; float y_; static const int chunk_size = 250; float z_;&#125; nonstatic数据成员在类中排列顺序和其声明顺序相同，中间如果存在static变量也不会被放到类之中。 c++标准指出，同一个存取段(access section)中，即public，private，protected，成员变量的排列需要符合较晚声明的变量出现在类中的较高的地址。因此数据成员的地址不需要连续，方便编译器实现内存对齐。 而vptr的位置在传统上是放在所有显式声明的成员变量的末尾，但是也有编译器将其放在开头。 同时，c++标准允许编译器将多个存取段(access section)中的数据成员自由排列。 skill 下面这个模板函数，接受两个成员变量，判断谁先出现在类中。如果两个成员都是不同的存取段中的第一个数据，那么就可以判断哪一个存取段先出现。 12345template &lt;class class_type, class data_type1, class data_type2&gt;char* AccessOrder(data_type1 class_type::*mem1, data_type2 class_type::*mem2) &#123; assert (mem1 != mem2); return mem1 &lt; mem2 ? &quot;member 1 occurs first&quot; : &quot;member 2 occurs first&quot;;&#125; 数据成员的存取12Point3d origin;origin.x = 0.0; x的存取成本是什么？ 视x和Point3d的声明而定，x可能是static/nonstaic，Point3d可能是独立类/继承的类/多重继承/虚拟继承的类。 静态数据成员(static data members)内部static数据成员 静态数据成员是存放在类之外的全局存储区，因此其存取与类的关联，不会造成任何额外成本。 每次程序调用静态成员时，就会被内部转换为对该extern实例的直接调用。 通过指针和对象，存区静态成员的指令是完全相同的。因为静态成员并不在类对象中，所以不需要通过对象存取静态成员。 复杂继承关系的static数据成员 因为同样静态成员不在类对象中，且实例只有一份，所以存取仍然和上述行为相同。 函数得来的对象 1FooBar().chunk_size_ = 250; 调用FooBar()的行为，在c++预标准(pre-standard)中并没有定义。但在c++标准中明确要求FooBar()被求值，即使其结果没有用处。 123456// 原先的FooBar().chunk_size_ = 250;// 可能的一种转换(void)FooBar();Point3d::chunk_size_ = 250; 静态成员地址 如果取静态成员的地址，得到的是一个静态成员数据类型的指针，因为静态成员不在类中。即： 123&amp;Point3d::chunk_size_;// 结果为const int*; 名称冲突 如果两个类的静态成员名称相同，编译器会对名称转换，转换为一个新编码，此过程称为name-mangling。 每个编译器的做法不同，但是至少要保证以下两点： 推导出独一无二的编码 这些编码需要被轻易的推到回原来的名称 非静态数据成员(nonstatic data members)非静态数据成员存放在类对象内部。除非经过类对象（显式或隐式），否则无法直接存取他们。 因此，只要程序中的一个成员函数直接处理一个非静态数据成员，就会有隐式对象产生。 123456789101112Point3d Point3d::Translate(const Point3d&amp; pt) &#123; x_ += pt.x_; y_ += pt.y_; z_ += pt.z_;&#125;// 实际代码Point3d Point3d::Translate(Point3d *const this, const Point3d&amp; pt) &#123; this-&gt;x_ += pt.x_; this-&gt;y_ += pt.y_; this-&gt;z_ += pt.z_;&#125; 对一个非静态数据成员的存取操作，编译器需要把类对象初始地址加上数据成员的偏移地址。 123original.x_ = 0.0;// 其地址为&amp;original + (&amp;point3d::x_ - 1); -1的操作，是因为指向成员数据的指针，其偏移量总是被+1，这样编译器可以区分”一个指向成员数据的指针，他指出类的第一个成员“和”一个指向成员数据的指针，他没有指出任何成员“这两种情况。 每一个成员数据的偏移量在编译期即可确定，即使成员变量是属于父类的继承体系（单一继承或多重继承）中。 因此，存取一个非静态数据成员和存取一个结构体成员或一个非子类的成员的效率相同。 虚拟继承 12Point3d *pt;pt-&gt;x_ = 0.0; 当x_是虚基类的成员是，存取效率会慢一些。 12original.x_ = 0.0;pt-&gt;x_ = 0.0; 以上两种存取方式的区别在于：如果x_是虚基类成员变量，那么pt具体指向的类是不明确的，所以指针存取操作会延迟到执行期，经过一个额外的间接引导，才可以完成。 而original因为类型已经确定，所以成员变量的偏移量在编译期就已经确定。 继承与数据成员在c++继承模型中，一个子类的内存是自己的成员数据加上父类的成员数据，至于数据的排列顺序，c++标准没有强制规定。大多数编译器都是父类成员数据先出现。虚基类除外。 不带多态的继承（没有虚函数）123456789101112131415161718192021222324252627282930313233class Point2d &#123;public: Point2d(float x = 0.0, float y = 0.0) : x_(x), y_(y) &#123;&#125; float x() &#123; return x_; &#125; float y() &#123; return y_; &#125; void x(float x) &#123; x_ = x; &#125; void y(float y) &#123; y_ = y; &#125; void operator+(const Point2d&amp; rhs) &#123; x_ += rhs.x(); y_ += rhs.y(); &#125;private: float x_, y_:&#125;class Point3d &#123;public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point2d(x, y), z_(z) &#123;&#125; float z() &#123; return z_; &#125; void z(float Z) &#123; z_ = z; &#125; void operator+(const Point3d&amp; rhs) &#123; Point2d::operator+(rhs); z_ += rhs.z(); &#125;private: float z_:&#125; 这样设计时，x，y的相关代码都局部化了，且抽象体系更易于理解。 然而，将原本独立的类，组合成继承关系，会造成两个易犯的错误。 重复设计相同功能的函数 point3d和point2d的构造函数和operator+并没有做成内联函数，因为他们需要调用Point2d的函数。 类的继承体系所带来的空间膨胀 1234567class Concrete &#123;private: int val_; char c1_; char c2_; char c3_;&#125; 上述类需要占用8bytes，4 + 1 + 1 + 1 + 1(对齐) 123456789101112131415class Concrete1 &#123;private: int val_; char c1_&#125;class Concrete2 : public Concrete1 &#123;private: char c2_;&#125;class Concrete3 : public Concrete2 &#123;private: char c3_;&#125; 这种情况下，Concrete3需要16bytes，8 + 4 + 4 为什么c++会这么做？而不是将padding填补呢？ 考虑如下： 1234Concrete2 *pc2;Concrete1 *pc1_1. *pc1_2;*pc1_2 = *pc1_1; 上述赋值操作，将会使被指对象的Concrete1部分复制给pc1_2。 如果考虑将padding填补 1234pc1_1 = pc2;// 那么，c2_就会被覆盖了*pc1_2 = *pc1_1 加上多态12345678910111213141516171819202122232425262728293031323334353637class Point2d &#123;public: Point2d(float x = 0.0, float y = 0.0) : x_(x), y_(y) &#123;&#125; float x() &#123; return x_; &#125; float y() &#123; return y_; &#125; void x(float x) &#123; x_ = x; &#125; void y(float y) &#123; y_ = y; &#125; virtual float z() &#123; return 0.0; &#125; virtual void z(float) &#123;&#125; virtual void operator+(const Point2d&amp; rhs) &#123; x_ += rhs.x(); y_ += rhs.y(); &#125;private: float x_, y_:&#125;class Point3d &#123;public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point2d(x, y), z_(z) &#123;&#125; float z() &#123; return z_; &#125; void z(float Z) &#123; z_ = z; &#125; // 注意，类型是point2d void operator+(const Point2d&amp; rhs) &#123; Point2d::operator+(rhs); z_ += rhs.z(); &#125;private: float z_:&#125; 只有当我们使用多态来处理使，设置一个virtual接口才合适。 为了支持多态，Point2d类会造成一些额外负担： 虚函数表，存放每一个虚函数的地址，表的个数还需要加上一个或两个位置，用来支持RTTI vptr，提供指向虚函数表的执行期链接 强化构造函数，为了使vptr初始化 强化析构函数，删除vptr。析构函数的调用是反向的，从子类到父类 在这种情况下，Point3d中含有一个额外的vptr，继承得来， 多了一个point3d的vtbl。 vptr的位置 目前，c++编译器的一个主要讨论题目是，将vptr放在哪里合适？ 一种做法是放在最后 这样可以保证类继承于结构体，确保了c++和c的兼容性。 另一种做法是放在开头 这种做法，会对多重继承下，通过类成员指针调用虚函数变得方便些。代价是成员变量的偏移拖延到执行期准备。且丧失了对c的兼容。但是有多少程序会从结构体继承下来的呢？ 多重继承单继承提供了一种自然多态的形式。即子类和父类从同一地址开始，只是大小有区别。 12Point3d p3d;Point2d *p = &amp;p3d; 这样的执行会很自然的发生，不需要额外操作。 如果把vptr放在类起始处，假设父类没有虚函数，而子类有虚函数，那么上述的赋值操作就无法自然发生，就需要编译器调整地址。 123456789101112131415161718192021222324252627class Point2d &#123;public: // 虚函数private: float _x, _y;&#125;;class Point3d &#123;public: // 虚函数private: float _z;&#125;;class Vertex &#123;public: // 虚函数private: Vertex *next;&#125;;class Vertex3d : public Point3d, public Vertex &#123;public: // 虚函数private: float mumble;&#125; 继承体系如下图所示： 多重继承的问题主要是子类和第二个继承的父类的转换问题。 在上述例子中，即将Vertex3d转换为Vertex，这需要编译器额外工作。 多重继承中，子类对象赋值给第一个继承的父类和单一继承相同，起始地址一样。如果是其后的父类，则需要对地址加/减中间的父类对象的大小。 如： 12345678910111213141516171819202122Vertex3d v3d;Vertex *pv;Point2d *p2d;Point3d *p3d;// 该操作会被转换pv = &amp;v3d;pv = (Vertex*)(((char*)&amp;v3d) + sizeof(Point3d));// 下面的操作直接进行p2d = &amp;v3d;p3d = &amp;v3d;Vertex3d *pv3d;Vertex *pv;pv = pv3d;// 被转换成pv = ((Vertex*)pv3d) + sizeof(Point3d);// 如果pv3d是空指针，那么pv的地址 = sizeof(Point3d)，造成错误// 实际的指针转换为pv = pv3d ? ((Vertex*)pv3d) + sizeof(Point3d) : 0; 引用则不需要对空值戒备，因为引用的初始化，不会使用到空对象。 c++标准没有要求父类的排列顺序，因此有些编译器(Meta Ware)设计了一种优化技术，只要第二个父类有虚函数，第一个父类没有，就将他们的顺序调换，这样子类的vptr就可以少产生一个，然而并没有得到广泛认可。 存取每一个父类的数据成员也无需额外操作，因为在编译时就已经处理好了偏移。 虚继承多重继承的副作用就是，他必须支持某种形式的共享对象继承，典型的例子是iostream库。 1234567891011// 早期的iostreamclass ios &#123;&#125;;class istream : public ios &#123;&#125;;class ostream : public ios &#123;&#125;;class iostream : public istream, public ostream &#123;&#125;;// 如今的iostream，只需要使用一份ios对象即可class ios &#123;&#125;;class istream : public virtual ios &#123;&#125;;class ostream : public virtual ios &#123;&#125;;class iostream : public istream, public ostream &#123;&#125;; 为了保证虚继承的多态，一般实现方法如下： 类如果有虚基类，虚基类会被分为两部分，共享区域和不变区域。 不变区域的部分无论子类怎样继承，都会有固定的偏移，该部分数据可以直接存取。 共享区域，即虚基类部分，每次都会因为继承而产生变化，他们只可以被间接存取。 不同编译器的差异就在于间接部分的不同，以下为三种主流策略。 1、虚基类指针 12345678910111213141516171819class Point2d &#123;protected: float x_. y_;&#125;;class Vertex : public virtual Point2d &#123;protected: Vertex *next;&#125;;class Point3d : public virtual Poin2d &#123;protected: float z_;&#125;;class Vertex3d : public Vertex, public Point3d &#123;protected: float mumble_;&#125;; 为了获得共享部分，cfront编译器会在每一个子类中设置一些指针，每个指针指向虚基类，访问继承的虚基类成员是，通过指针间接完成 如： 123456789101112void Point3d::operator+=(const Point3d&amp; rhs) &#123; x_ += rhs.x_; y_ += rhs.y_; z_ += rhs.z_;&#125;;// 转换为void Point3d::operator+=(const Point3d&amp; rhs) &#123; _vbcPoint2d-&gt;x_ += rhs._vbcPoint2d-&gt;x_; _vbcPoint2d-&gt;y_ += rhs._vbcPoint2d-&gt;y_; z_ += rhs.z_;&#125;; 子类和父类的转换 123Point2d *p2d = pv3d;// 转换为Point2d *p2d = pv3d ? pv3d-&gt;_vbcPoint2d : 0; 该模型有两个主要的缺点： 每一个对象要对其每一个虚基类设置一个指针，然而我们希望每个对象有固定的指针个数，而不需要根据虚基类的个数而变动。 虚继承结构增加的话，就会导致间接存取层次增加。如果有三次虚继承，就会有三次间接存取。然而我们希望每个虚基类的访问时间是固定的，而不需要根据虚继承体系的深度而变动。 MeraWare等编译器使用第一种方法，他们复制所有虚基类的指针，将其放到子类中，解决固定访问时间的问题。但是付出了空间的代价。 第一个问题主要有两个解决方法。 第一种解决方法——2、虚基类表 Microsoft编译器使用了虚基类表，每个对象如果有虚基类，则会通过一个虚基类表指针，指向虚基类表。真正的虚基类指针放在虚基类表中。 第二种解决方法——3、虚函数表偏移策略[-1] 在虚函数表中存放虚基类的偏移量。 1234567891011121314151617void Point3d::operator+=(const Point3d&amp; rhs) &#123; x_ += rhs.x_; y_ += rhs.y_; z_ += rhs.z_;&#125;;// 转换为void Point3d::operator+=(const Point3d&amp; rhs) &#123; (this + _vptr_Point3d[-1])-&gt;x_ += (&amp;rhs + ths._vptr_Point3d[-1])-&gt;x_; (this + _vptr_Point3d[-1])-&gt;y_ += (&amp;rhs + ths._vptr_Point3d[-1])-&gt;y_; z_ += rhs.z_;&#125;;// 子类和虚基类之间的转换Point2d *p2d = pv3d;Point2d *p2d = pv3d ? pv3d + pv3d-&gt;_vptr_Point3d[-1] : 0; 上述方法在存取继承来的成员时代价较高，但是此代价被分散到对成员的使用上，属于局部性成本。 以上三种方法都是一种实现模型，而不是标准，每种模型都是来解决共享区域的数据存储问题。 如果通过非多态的存取操作，可以在编译时期被解析，效率较好。 12Point3d origin;origin.x_; 通常，最有效的使用虚基类的方法是，一个抽象虚基类，没有任何数据成员。 对象成员的效率我们将对聚合、封装以及继承所引发的负担做测试。 局部变量 12345678float pa_x = 1.725, pa_y = 0.875, pa_z = 0.478;float pb_x = 0.315, pb_y = 0.317, pb_z = 0.838;for (int iter = 0; iter &lt; 10000000; ++iter) &#123; pb_x = pa_x - pb_z; pb_y = pa_y + pb_x; pb_z = pa_z + pb_y;&#125; 123class Point1d &#123;&#125;;class Point2d : public virtual Point1d &#123;&#125;;class Point2d : public virtual Point2d &#123;&#125;; 因此，程序的效率不可通过经验判断，需要实际检验。 指向数据成员的指针指向数据成员的指针主要用途有两点。 类成员的底层布局，判断vptr在开头还是末尾 之前在数据成员的布局中提到的，判断类中的存取段(access section)的顺序 1234567class Point3d &#123;public: virtual ~Point3d();protected: static Point3d origin_; float x_, y_, z_;&#125; 去某个成员变量的地址（nonstatic），将达到成员变量在类中的偏移，但是因为vptr的位置没有限制，通常在类开头或结尾，所以可能会有差别。 我们期望分别对x_，y_，z取地址后得到0，4，8或4，8，12。然而实际结果却比期望结果多了1。 注意：在visual studio2019上测试得到的结果是0，4，8，这可能跟编译器的特殊处理有关。 为什么会多1呢？ 为了区分空指针和指向第一个数据成员的指针。 1234567Point3d origin;// 取nonstatic数据成员的地址，得到的是偏移量&amp;Point3d::x_;// 取一个对象的数据成员的地址，得到的是内存中的实际地址&amp;origin::x_;// 将&amp;origin::x_的结果减&amp;Point3d::x_的结果+1，就会得到origin的起始地址 多重继承下的指向数据成员的指针 123456789101112131415161718192021222324252627282930313233343536class Base1 &#123;public: int val1;&#125;;class Base1 &#123;public: int val2;&#125;;class Derived : public Base1, public Base2 &#123;&#125;;void Func1(int Derived::*dmp, Derived *pd) &#123; pd-&gt;*dmp;&#125;void Func2(Derived *pd) &#123; int Base2::*bmp = &amp;Base2::val2; // bmp值为1，但在Derived中，val2地址为5 Func1(bmp, pd);&#125;// 经过转换void Func2(Derived *pd) &#123; int Base2::*bmp = &amp;Base2::val2; // bmp值为1，但在Derived中，val2地址为5 Func1(bmp + sizeof(Base1), pd); // 但是无法确保bmp是否为0&#125;// 经过转换，防止bmp=0void Func2(Derived *pd) &#123; int Base2::*bmp = &amp;Base2::val2; // bmp值为1，但在Derived中，val2地址为5 Func1(bmp ？ bmp+ sizeof(Base1) : 0, pd);&#125; 当bmp被作为Func1的第一个参数时，它的值需要根据Base1的大小而调整，否则会访问Base1的val1。 指向数据成员的指针的效率指针指向对象的成员： 123Point3d pa;float *ax = &amp;pa.x;*bx = *ax - *bz; 指针指向类的数据成员： 12float Point3d::*ax = &amp;Point3d::x;pa.*ax = pa.*ax - pb.*bz; 加上继承 因为继承的数据成员是直接放在类对象中的，因此继承的方式没有带来什么效率差异。 而虚拟继承的主要影响是对编译器的优化。 因为每次存取Point::x，都会被转换为&amp;pb-&gt;_vbcPoint + (bx - 1)，多了一次间接访问，降低了寄存器的优化能力。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"cpp-对象模型-第二章-构造函数","slug":"cpp-对象模型-第二章-构造函数","date":"2020-11-17T06:36:25.000Z","updated":"2020-11-17T06:37:57.462Z","comments":true,"path":"2020/11/17/cpp-对象模型-第二章-构造函数/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","excerpt":"默认构造函数的生成并不是类没有构造函数时，编译器都会创建一个默认构造函数，只有当编译器需要的时候，才会创建一个默认构造函数。 而如果是程序的需要，那就是程序员的责任去创建构造函数。 c++95声明，当没有用户定义的构造函数时，会隐式创建一个默认构造函数，然而这个隐式构造函数是trivial的(无能的) 带有默认构造函数的成员类对象如果类没有构造函数，但是其成员类对象拥有默认构造函数，那么该类的隐式默认构造函数就是**nontrivial(有用的)**，编译器就会在构造函数被调用时创建一个隐式构默认造函数。 为了解决不同文件中的同一个类多次创建问题，即在A文件中调用C类，在B文件中调用C类，会将创建的构造、析构、复制构造、赋值以inline方式完成，如果函数太复杂，就会创建explicit non-inline static函数。 12345678910class Foo &#123;public: Foo();&#125;class Bar &#123;public: Foo foo; char* str;&#125; 此时编译器为了满足自身要求，会创建要给构造函数，大体如下：","text":"默认构造函数的生成并不是类没有构造函数时，编译器都会创建一个默认构造函数，只有当编译器需要的时候，才会创建一个默认构造函数。 而如果是程序的需要，那就是程序员的责任去创建构造函数。 c++95声明，当没有用户定义的构造函数时，会隐式创建一个默认构造函数，然而这个隐式构造函数是trivial的(无能的) 带有默认构造函数的成员类对象如果类没有构造函数，但是其成员类对象拥有默认构造函数，那么该类的隐式默认构造函数就是**nontrivial(有用的)**，编译器就会在构造函数被调用时创建一个隐式构默认造函数。 为了解决不同文件中的同一个类多次创建问题，即在A文件中调用C类，在B文件中调用C类，会将创建的构造、析构、复制构造、赋值以inline方式完成，如果函数太复杂，就会创建explicit non-inline static函数。 12345678910class Foo &#123;public: Foo();&#125;class Bar &#123;public: Foo foo; char* str;&#125; 此时编译器为了满足自身要求，会创建要给构造函数，大体如下： 123inline Bar::Bar() &#123; foo.Foo::Foo();&#125; 但是该构造函数并没有初始化str，这将导致程序运行不正确，然而这一部分功能应该由程序员去实现 假设程序员编写了如下构造函数： 123Bar::Bar() &#123; str = nullptr;&#125; 然而该构造函数没有满足编译器的需求，因此，编译器会扩张该构造函数。 1234Bar::Bar() &#123; foo.Foo::Foo(); str = nullptr;&#125; 如果类由多个成员类对象，则会根据其声明顺序，来扩张构造函数的编写顺序。 带有默认构造函数的父类这种情况下与前一种情况类似。 如果本类由多个构造函数，但是没有默认构造函数，编译器会扩张每一个构造函数，而不会去创建一个新的默认构造函数。 如果本类中还有带着默认构造函数的成员类对象，这些成员类的默认构造函数也会在父类默认构造函数调用之后被调用。 带有虚函数的类1234567891011121314151617class Widget &#123;public: virtual void Flip() = 0;&#125;;void Flip(const Widget&amp; widget) &#123; widget.Flip();&#125;// Bell 和 Whistle 都继承Widget类void Foo() &#123; Bell b; Whistle w; Flip(b); Flip(w);&#125; 其中，虚函数的调用部分会被重写成类似形式： 1234// widget.Flip() 的虚函数调用动作(*widget.vptr[1])(&amp;widget)// &amp;widget 表示被调用的函数实例的this指针 为了实现如上调用，编译器会为每一个带有虚函数的类的vptr初始化。 带有虚基类的类虚基类在不同编译器上的实现方式不同，而每一种实现方式都需要确保虚基类在子类中的位置能在执行期确定 12345678910111213141516171819202122232425262728class X &#123; public: int i;&#125;;class A : public virtual X &#123;public: int j;&#125;;class B : public virtual X &#123;public: double d;&#125;class C : public A, public B &#123;public: int k;&#125;void Foo(const A* pa) &#123; pa-&gt;i = 1024;&#125;int main() &#123; Foo(new A); Foo(new B);&#125; 在上述代码中，编译器无法确定pa中的X::i的具体位置，因为A*的实际类型并不清楚。 因此编译器需要改变代码，在执行期确定X::i。 可能的改变如下： 123void Foo(const A* pa) &#123; pa-&gt;_vbcX-&gt;i = 1024;&#125; 同个一个_vbcX指向具体的虚基类X，编译器也为此在对象创建时初始化该指针。 复制构造函数的操作复制构造函数的调用在三种情况中，复制构造函数会被调用： 显式地将对象作为另一个对象的初值 123class X &#123;&#125;;X a;X ax = a; 对象通过参数传递给函数 1234class X &#123;&#125;;void Foo(X x);Foo(x); 函数返回类对象 1234void Foo() &#123; X xx; return xx;&#125; 默认按成员初始化(default memeberwise initialization)如果类没有显式复制构造函数，编译器会以默认按成员初始化，即将类中声明的，或继承的数据成员逐一复制，如果遇到了成员类对象，将会递归地实行按成员初始化。如： 1234567891011121314class String &#123;public: // 缺少显式复制构造函数private: char* str; int len;&#125;;String noun(&quot;book&quot;);String verb = noun;// 类似于verb.str = noun.str;verb.len = noun.len; 此时该对象的默认按成员初始化会发生。 如果该类是另一个类的成员，如下： 1234567class Word &#123;public: // 缺少显式复制构造函数private: int occurs; String word;&#125; 那么word的复制构造函数会以默认按成员初始化的方式进行，先复制occurs，接着在递归调用word的按成员初始化操作。 这种默认按成员初始化的操作时怎么实现的？ 如同默认构造函数，默认复制构造函数的生成会区分为trivial和nontrivial，只有nontrivial的实例会被创建。 而复制构造函数的trivial的标转在于类是否展现出bitwise copy semantics。 ####bitwise copy semantics（按位逐个复制） 如下： 12345class Word &#123;private: int cnt; char* str;&#125;; 以上情况就展现出了bitwise copy semantics，也无需由一个默认复制构造函数来完成初始化操作，通过直接赋值即可完成，默认复制构造函数也不会创建。 然而： 12345678910class Word&#123;private: int cnt; String str;&#125;;class String &#123;public: String(const String&amp;);&#125;; 这种情况下，编译器需要创建默认复制构造函数，调用str的复制构造函数。 编译器合成的复制构造函数都是浅复制 没有展现出bitwise copy semantics以下四种情况，类不会展现出bitwise copy semantics 类中存在成员类对象，该成员类对象含有一个复制构造函数（不论是程序员显式声明的，还是编译器合成的） 类继承带有复制构造函数的父类（不论是程序员显式声明的，还是编译器合成的） 类具有虚函数 类的继承链中，存在虚继承 具有虚函数的复制构造函数有如下两类： 1234567891011121314151617class ZooAnimal &#123;public: ZooAnimal(); ~ZooAnimal(); virtual void Animate(); virtual void Draw();&#125;class Bear : public ZooAnimal &#123;public: Bear(); void Animate(); void Draw(); virtual void Dance();&#125; 当ZooAnimal的一个类对象以另一个ZooAnimal的对象作为初值，或Bear的一个类对象以另一个Bear的对象作为初值，都可以直接按位逐个复制完成，此时vptr也会同时复制过去。 当ZooAnimal的一个类对象以Bear的对象作为初值时，就不能将vptr复制过去，复制构造函数会设定vptr指向ZooAnimal的而不是Bear的。 虚基类的复制构造函数首先，同类对象的复制直接使用按位复制即可，然而，以子类的形式复制会存在问题，如下： 123class ZooAnimal &#123;&#125;;class Raccon : public virtual ZooAnimal &#123;&#125;;class RedPanda : public Raccon &#123;&#125;; 如果将RedPanda的对象复制给Raccon，编译器需要设置虚基类的指针或者偏移量。 程序转换例： 123456class X &#123;&#125;;X Foo() &#123; X xx; return xx;&#125; 在上述函数中会发生以下情况： 每次Foo()被调用时，都会传回xx的值 如果X定义了复制构造函数，return时也会调用复制构造函数 第一种情况的真实性，需要明确X是如何定义的。 第二种情况的真实性，虽然也需要明确X是如何定义，但是主要的还是看编译器是如何优化的。 在不同的编译器上，优化的结果可能导致以上两种情况都不会发生。 显式的初始化12345678class X &#123;&#125;;X x0;void Foo() &#123; X x1(x0); X x2 = x0; X x3 = X(x0);&#125; 在程序优化过程中，会有两个阶段的动作： 重写每一个定义，初始化操作会被重写。注：严谨的说，定义是指占用内存的行为。 类的复制构造函数被调用 因此，上述转换后可能是这样： 1234567891011void Foo() &#123; // 定义被重写 X x1; X x2; X x3; // 调用复制构造函数 x1.X::X(x0); x2.X::X(x0); x3.X::X(x0);&#125; 参数传递的初始化c++标准指出，将类对象作为参数或返回值时，相当于如下初始化： 12X xx = arg;// xx表示形式参数或返回值，arg表示实参 如果有如下定义： 123456class X &#123;&#125;;void Foo(X x0);X x;Foo(X x0); 这种情况下，不同编译器的实现方式不同，大体有两种： 引入临时变量，调用复制构造函数将其初始化，但因此函数的声明也需要被改写。 123456X _temp;_temp.X::X(x);Foo(_temp);// Foo函数也需要被改写void Foo(X&amp; x0); 在函数执行完毕后，临时变量也会自动调用析构函数。 拷贝建构(copy construct) 将实参复制到合适的位置上，位置由函数调用的地址而决定，类似于==栈帧== 返回值的初始化123456class X &#123;&#125;;X Bar() &#123; X xx; reutrn xx;&#125; 返回值的处理也是一个双阶段转换 增加一个额外参数，该参数是类的引用，用来放复制构造产生的返回值 在return之前增加一个复制构造函数的调用操作，初始化这个额外参数 转换后的Bar()函数如下： 1234567void Bar(X&amp; _result)&#123; X xx; xx.X::X(); _result.X::X(xx); return;&#125; 在调用Bar函数时，调用也需要转换 12345678910111213141516X xx = Bar();//转换为X xx;Bar(xx);Bar().Fun();// 转换为X _temp;(Bar(_temp), _temp).Fun();// 函数指针X (*pf)();pf = Bar;// 转换为void (*pf)(X&amp;);pf = Bar; 在用户层上去优化返回值定义一个计算用的构造函数，即不需要写 12345678910111213class X &#123;&#125;;X Bar() &#123; X xx; // 处理xx reutrn xx;&#125;X Bar(const T&amp; y, const T&amp; z) &#123; X xx; // 以y和z来处理xx return xx;&#125; 这样会导致xx使用复制构造函数，复制到编译器产生_result 优化方法是定义一个X的构造函数，以y，z为初始化条件，因此Bar可以被改写为： 123X Bar(const T&amp; y, const T&amp; z) &#123; return X(y, z);&#125; 这样，被转换之后，效率可以会高一点 1234void Bar(X&amp; _result, const T&amp; y, const T&amp; z) &#123; _result.X::X(y, z); return;&#125; 这样做减少了复制构造函数的成本。但是会导致类中的用于这种方法计算的构造函数数量增加。 在编译器层上去优化返回值编译器的优化即为： 12345678910111213class X &#123;&#125;;X Bar() &#123; X xx; // 处理xx reutrn xx;&#125;void Bar(X&amp; _result)&#123; _result.X::X(xx); // 处理_result return;&#125; 这样的编译器优化操作，称为**Named Return Value(RNV)**优化。且NRV也是当今c++标准编译器的优化之一。 虽然NRV的优化很好，但是饱受批评。原因有： NRV由编译器完成，他是否真的被执行，并不清楚 如果函数复杂，NRV就难以实行。 在有些程序中，NRV可能会导致程序错误运行 12345void Foo() &#123; // 一个复制构造函数被调用 X xx = Bar(); // 调用析构函数&#125; 此时对称性因为优化被打乱，程序的运行也出错了。 复制构造函数，需要吗？123456class Point3d &#123;public: Point(float x, float y, float z);private: float x, y, z;&#125;; 类设计者需要编写复制构造函数吗？ 答案是不需要！ 首先，类中只有数值类型，编译器提供的复制构造函数足够了，安全，快速。 然而，如果存在大量以按值返回对象的操作，为了保证NRV的施行，需要编写复制构造函数。 123456789101112131415Point3d operator+(const Point3d&amp;, const Point3d&amp;);Point3d operator-(const Point3d&amp;, const Point3d&amp;);Point3d operator*(const Point3d&amp;, int);// 构造函数的编写可以如下：Point3d::Point3d(const Point3d&amp; p) &#123; x = p_x; y = p_y; z = p_z;&#125;// 更好的实现是使用memcpyPoint3d::Point3d(const Point3d&amp; p) &#123; memcpy(this, &amp;p, sizeof(Point3d));&#125; 然而memcpy和memset都需要类仅仅含有内置数据类型。 如果含有虚函数或虚基类，vptr和虚基类指针/编译会被错误设置。 成员初始化列表(Member Initialization List)在以下情况，必须使用成员初始化列表 初始化一个引用对象 初始化const对象 调用父类的构造函数，该构造函数有一组参数 调用成员类对象的构造函数，构造函数有一组参数。 如： 12345678910class Word &#123;public: Word() &#123; name_ = 0; cnt_ = 0; &#125;private: String name_; int cnt_;&#125; 该构造函数会产生一个临时对象，并调用临时对象的operator=操作，最后调用析构函数。 1234567891011121314151617181920// 编译器改写Word::Word() &#123; name_.String::String(); String temp = String(0); name_,String::operator=(temp); temp.String::~String(); cnt_ = 0;&#125;// 较好的方式Word::Word() : name_(0) &#123; cnt_ = 0;&#125;// 编译器改写Word::Word() &#123; name_.String::String(0); cnt_ = 0;&#125; 陷阱成员初始化列表的顺序 初始化列表中的排列方式并不会影响其初始化顺序，在类中的声明顺序才会决定其初始化顺序。 1234567class X &#123;private: int i; int j;public: X(int val) : j(val), i(j) &#123;&#125;&#125;; 上述代码的本意是先将val值给j，然后将j的值给i，然而真正的执行顺序是按照声明顺序，即将j的值给i，再将val的值给j。 为了达成以上目的，应该这么写： 123X::X(int val) : j(val) &#123; i = j;&#125; 成员初始化列表中的操作是位于函数体内语句之前，因此这样可以正常执行。 初始化列表与成员函数 考虑如下构造函数： 12X::X(int val) : i(Func(val)), j(val) &#123;&#125;// Func是X的成员函数 这样写是正确的，然而存在不确定性，因为你并不知道Func对于类X的依赖性是多少。 因此，将初始化过程放在函数体中执行。 子类的成员函数返回值作为父类构造函数的参数 12345678class FooBar : public X &#123;private: int fval_;public: int fval() &#123; return fval_; &#125;; FooBar(int val) : fval_(val), X(fval()) &#123;&#125;&#125;; 编译器改写： 12345FooBar::FooBar &#123; X::X(this, this-&gt;fval()); fval_ = val;&#125; 显然，很糟糕。 总结 编译器会按照变量声明顺序，对初始化列表的顺序重新排列。且会在构造函数中插入代码，这些代码都位于用户编写的代码之前。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"cpp-对象模型-第一章-关于对象","slug":"cpp-对象模型-第一章-关于对象","date":"2020-11-17T06:34:52.000Z","updated":"2021-01-30T01:42:32.287Z","comments":true,"path":"2020/11/17/cpp-对象模型-第一章-关于对象/","link":"","permalink":"http://example.com/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"1. c++对象模型类的非static成员变量在类之中，static成员变量和staic/非static成员函数在类之外。 虚函数会在对象存储一个虚函数表指针(vptr)**，该指针指向相关的虚函数表(vtbl)**，vptr的初始化、重置由类的构造、析构、赋值决定。每一个类的type_info由vtbl指出，存储在第一个表项中。 2. 类的内存大小 非static成员变量的大小总和 内存对齐，4bytes的整数倍 支持虚函数和虚继承的额外开销 3. 多态中的指针1234567891011121314151617class ZooAnimal &#123;public: virtual void dance();private: int ioc; String name;&#125;class Bear : public ZooAnimal &#123;public:private: enum Dances &#123;...&#125;; Dances dances; int cell_block;&#125; 如上的继承体系，Bear类的内存情况如下： 解析时，指针根据指针的类型，读取对应大小的内存","categories":[{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]}],"categories":[{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"c++对象模型","slug":"c-对象模型","permalink":"http://example.com/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]}