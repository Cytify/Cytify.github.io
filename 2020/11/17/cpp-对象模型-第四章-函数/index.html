<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Cytify">





<title>对象模型-4.函数 | Cytify</title>



    <link rel="icon" href="/0.jfif">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Cytify&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Cytify&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">对象模型-4.函数</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Cytify</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 17, 2020&nbsp;&nbsp;14:42:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">c++对象模型</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="1-成员函数的调用"><a href="#1-成员函数的调用" class="headerlink" title="1. 成员函数的调用"></a>1. 成员函数的调用</h2><h3 id="1-1-非静态成员函数-Nonstaic-Member-Function"><a href="#1-1-非静态成员函数-Nonstaic-Member-Function" class="headerlink" title="1.1 非静态成员函数(Nonstaic Member Function)"></a>1.1 非静态成员函数(Nonstaic Member Function)</h3><p><strong>成员函数</strong>会经过编译器转换为<strong>非成员函数</strong>：</p>
<ul>
<li><p>改变函数的声明，新增一个额外参数，用于访问类内的数据和函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>;</span></span><br><span class="line"><span class="comment">// non-const</span></span><br><span class="line"><span class="function">Point3d <span class="title">Point3d::Magnitude</span><span class="params">()</span></span>; -&gt; <span class="function">Point3d <span class="title">Point3d::Magnitude</span><span class="params">(Point3d *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="function">Point3d <span class="title">Point3d::Magnitude</span><span class="params">()</span> <span class="keyword">const</span></span>; -&gt; <span class="function">Point3d <span class="title">Point3d::Magnitude</span><span class="params">(<span class="keyword">const</span> Point3d *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对成员的访问操作变为<strong>this指针</strong>的访问</p>
</li>
<li><p>转换函数名称——<strong>mangling方法</strong>(第三章数据部分提到，用于转换static变量名)</p>
</li>
<li><p>转换后，函数的调用也需要被转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>;</span></span><br><span class="line">Point3d obj;</span><br><span class="line">Point3d *ptr = <span class="keyword">new</span> Point3d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设Magnitude名称转换为Magnitude_7Point3dFv</span></span><br><span class="line">obj.Magnitude(); -&gt; Magnitude_7Point3dFv(&amp;obj);</span><br><span class="line">ptr-&gt;Magnitude(); -&gt; Magnitude_7Point3dFv(ptr);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>假设有如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point3d <span class="title">Point3d::Normalize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">float</span> msg = Magnitude();</span><br><span class="line">    <span class="keyword">return</span> Point3d( x_/msg, y_/msg, z_/msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过转换，以及NRV优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Normalize_7Point3dFv</span><span class="params">(<span class="keyword">register</span> <span class="keyword">const</span> Point3d* <span class="keyword">const</span> <span class="keyword">this</span>, Point3d&amp; _result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">float</span> msg = <span class="keyword">this</span>-&gt;Magnitude();</span><br><span class="line">    _result.Point3d::Point3d(<span class="keyword">this</span>-&gt;x_/msg, <span class="keyword">this</span>-&gt;y_/msg, <span class="keyword">this</span>-&gt;z_/msg);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="1-2-函数名称转换-Name-Mangling"><a href="#1-2-函数名称转换-Name-Mangling" class="headerlink" title="1.2 函数名称转换(Name Mangling)"></a>1.2 函数名称转换(Name Mangling)</h3><p>不同编译器的做法不同。以下仅介绍<strong>cfront</strong>的做法。</p>
<ul>
<li><p>类的数据成员通常会加上类名，会变成独特的名称。可以有效防止<strong>子类和父类拥有相同变量名</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> val_; -&gt; val_3Bar</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> Bar &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val_; -&gt; val_3Foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数由于可以<strong>重载</strong>。会在函数名后加上类名，<strong>再加上参数列表中的类型</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> x)</span></span>; -&gt; <span class="function"><span class="keyword">void</span> <span class="title">x_5PointFf</span><span class="params">(<span class="keyword">float</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>; -&gt; <span class="function"><span class="keyword">void</span> <span class="title">x_5PointFff</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>名称转换的目的是为了使<strong>不正确的调用操作在链接期就被检测出来</strong>。比如重载函数调用不正确等。</p>
</li>
</ul>
<h3 id="1-3-虚成员函数-Virtual-Member-Function"><a href="#1-3-虚成员函数-Virtual-Member-Function" class="headerlink" title="1.3 虚成员函数(Virtual Member Function)"></a>1.3 虚成员函数(Virtual Member Function)</h3><p>虚函数通过<strong>虚函数指针</strong>指向的<strong>虚函数表</strong>调用。</p>
<p>虚函数表，第一格是RTTI有关数据，之后的是虚函数地址。有些编译器将<strong>虚函数表-1位置</strong>设置为虚基类地址/偏移。</p>
<p><strong>虚函数的转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;Normalize(); -&gt; (*ptr-&gt;vptr[<span class="number">1</span>])(ptr);</span><br></pre></td></tr></table></figure>

<ul>
<li>vptr为虚函数指针，在<strong>单继承体系中只有一个</strong>，但是在<strong>多继承体系中会有多个</strong>，因此有可能需要名称转换。</li>
<li>vptr[1]是函数的地址，即<code>Noemalize()</code>函数地址。</li>
<li>第二个ptr为<strong>this</strong>指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point3d <span class="title">Point3d::Normalize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">float</span> msg = Magnitude();</span><br><span class="line">    <span class="keyword">return</span> Point3d( x_/msg, y_/msg, z_/msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设Magnitude和Noemalize都是虚函数</span></span><br></pre></td></tr></table></figure>

<p><strong>优化tips</strong></p>
<ul>
<li><p>因为<strong>Magnitude()**是确定的，所以直接</strong>显式调用**会比虚指针转换调用更好。</p>
<p>即，<code>register float msg = Point3d::Magnitude();</code></p>
</li>
<li><p><strong>显式调用虚函数</strong>，调用过程与<strong>非静态成员函数</strong>相同</p>
</li>
<li><p><code>Magnitude()</code>编写为<strong>内联函数</strong>，更有效率</p>
</li>
</ul>
<h3 id="1-4-静态成员函数-Static-Member-Function"><a href="#1-4-静态成员函数-Static-Member-Function" class="headerlink" title="1.4 静态成员函数(Static Member Function)"></a>1.4 静态成员函数(Static Member Function)</h3><p>静态函数的调用与非静态成员函数<strong>类似</strong>，但有<strong>区别</strong>，**不会增加额外参数(this指针)**。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.Noemalize(); -&gt; Normalize_7Point3dSFv();</span><br><span class="line">ptr-&gt;Normalize(); -&gt; Normalize_7Point3dSFv();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>静态成员函数也需要被转化，其中SFv表示是静态成员函数</p>
</li>
<li><p>静态成员函数<strong>不需要通过类的实例调用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.Obj() &gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 转换为</span></span><br><span class="line">(<span class="keyword">void</span>) foo(); <span class="comment">// NRV</span></span><br><span class="line">Point3d::Obj() &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这样会有<strong>额外成本</strong></p>
</li>
<li><p>静态成员函数的地址是<strong>非成员函数</strong>的地址</p>
<p><code>&amp;Point3d::Obj(); == unsigned int (*)(); != unsigned int (Point3d::*)();</code></p>
</li>
<li><p>静态成员函数可以便于成为<strong>回调函数(callback)**，可用于</strong>线程函数(pthread)**</p>
</li>
</ul>
<h2 id="2-虚函数-Virtual-Member-Function"><a href="#2-虚函数-Virtual-Member-Function" class="headerlink" title="2. 虚函数(Virtual Member Function)"></a>2. 虚函数(Virtual Member Function)</h2><h3 id="2-1-单一继承"><a href="#2-1-单一继承" class="headerlink" title="2.1 单一继承"></a>2.1 单一继承</h3><p>为了支持多态，需要对类提供额外的<strong>执行期信息</strong>。</p>
<ul>
<li>每个对象设置一个<strong>虚指针</strong>，指向<strong>虚函数表</strong></li>
<li>虚函数表中设置类的<strong>类型信息</strong>（支持RTTI），以及<strong>虚函数地址</strong></li>
</ul>
<p>对于虚函数的<strong>继承</strong>来说，会有以下操作：</p>
<ul>
<li>父类的虚函数会被子类继承</li>
<li>子类的虚函数会重载父类的虚函数，即在虚函数表中覆盖父类虚函数</li>
<li>子类的新虚函数会加入到虚函数表中，新的虚函数会被放到虚函数表末尾</li>
<li>存在一个<code>pure_virtual_called()</code>函数，它可以是纯虚函数，也可以当作执行器异常处理函数</li>
</ul>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> POint&amp; <span class="title">Mult</span><span class="params">(<span class="keyword">float</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> :</span> <span class="keyword">public</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Point2d();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> POint2d&amp; <span class="title">Mult</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> y_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> y_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point2d &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Point3d();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> POint3d&amp; <span class="title">Mult</span><span class="params">(<span class="keyword">float</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> z_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> z_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%87%BD%E6%95%B0/image-20201117093220735.png" alt="image-20201117093220735" style="zoom:80%;">

<p>因此，<code>ptr-&gt;z();</code>会被转换为<code>(ptr-&gt;_vptr[4])(ptr)</code></p>
<p>这一转换在编译器即可完成，但在执行期才能知道调用的是哪一个类的<code>z()</code></p>
<h3 id="2-2-多继承"><a href="#2-2-多继承" class="headerlink" title="2.2 多继承"></a>2.2 多继承</h3><p>复杂度主要是：第二个之后的父类，以及调用时<strong>this指针的转换问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base1();</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SpeakClearly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base1* <span class="title">Clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> data_base1_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2();</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Mumble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base2* <span class="title">Clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> data_base2_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived();</span><br><span class="line">    <span class="keyword">virtual</span> ~Derived();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">Clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> data_derived_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果以父类指针指向子类，则对于Base1则没问题，因为Base1地址与子类地址相同，而Base2则需要<strong>加减偏移this指针</strong>来对齐地址。在调用析构函数时也需要<strong>调整this指针</strong>。</p>
<p>假设有 <code>Base2 *pbase2 = new Derived</code>，Derived对象的地址需要被调整到Base2子对象的地址。</p>
<p><code>Derived *temp = new Derived;</code></p>
<p><code>Base2 *pbase2 = tmep ? temp + sizeof(Base1) : 0;</code></p>
<p>在删除时，也需要调整指针到整个Derived对象地址。</p>
<p><strong>多重继承之下的含有虚函数的对象模型</strong>：</p>
<ul>
<li><strong>含有多个虚函数表</strong>，虚函数表数目与父类数目有关</li>
<li>每一个虚函数表，子类都有一个<strong>虚指针对应</strong></li>
</ul>
<p>对于本例，则有两个虚函数表创建</p>
<ul>
<li>一个<strong>主要实例</strong>，子类的虚函数表，与最左端的Base1类<strong>共享</strong>，涵盖整个对象的虚函数</li>
<li>一个<strong>次要实例</strong>，与Base2类相关，不包含Base1，即左边的父类的相关虚函数</li>
</ul>
<img src="/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%87%BD%E6%95%B0/image-20201117100521963.png" alt="image-20201117100521963" style="zoom:80%;">

<p>例如：<code>Base *pb1 = new Derived; Base2 *pb2 = pb1-&gt;Clone();</code></p>
<p>pb1首先加上offset，调整到Derived类地址，调用<code>Derived::Clone()</code>，返回值需要减去offset，调整到Base2的地址。</p>
<p><strong>Sun编译器</strong></p>
<p>Sun编译器为了解决多虚函数表问题，将虚函数表连在一起，加上指针指向下一个虚函数表，提升了项目的速度。</p>
<p>在虚函数足够小时，使用<strong>split function</strong>，将函数调整为两个函数，第二个在返回之前，为指针加减offset。</p>
<p>因此，Base1指针和Derived指针不需要调整this指针，而Base2指针调用的是新的函数。</p>
<p><strong>Microsoft</strong>使用<strong>address points</strong>的方法。</p>
<h3 id="2-3-虚拟继承"><a href="#2-3-虚拟继承" class="headerlink" title="2.3 虚拟继承"></a>2.3 虚拟继承</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Point2d(<span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> =<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~Point2d();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Mumble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">Z</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line">	float x_, y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point2d &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~Point3d();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">Z</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> z_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%87%BD%E6%95%B0/image-20201117102619630.png" alt="image-20201117102619630" style="zoom:80%;">

<p>不同编译器对于虚继承下的虚函数有着眼花缭乱的支持，这里不做详述，太怪异了。</p>
<p>但是谨记，<strong>不要在虚基类中声明非静态数据成员</strong>。</p>
<h2 id="3-函数的效率"><a href="#3-函数的效率" class="headerlink" title="3. 函数的效率"></a>3. 函数的效率</h2><img src="/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%87%BD%E6%95%B0/image-20201117103113863.png" alt="image-20201117103113863" style="zoom:80%;">

<p><strong>友元函数、静态成员函数、非静态成员函数</strong>的效率差不多，这是易于理解的，因为三者最终的调用方式相同，都被<strong>转换为非成员函数</strong>。</p>
<p><strong>单继承虚函数</strong>需要通过构造函数设定vptr，所以效率降低了。</p>
<p><strong>多继承虚函数</strong>有多方面因素，因为多继承，所以构造函数需要多调用一次，其次，可能需要调整this指针而导致效率进一步降低。</p>
<p><strong>虚拟继承虚函数</strong>与多继承类似</p>
<h2 id="4-指向成员函数的指针"><a href="#4-指向成员函数的指针" class="headerlink" title="4. 指向成员函数的指针"></a>4. 指向成员函数的指针</h2><h3 id="4-1-非静态、非虚成员函数指针"><a href="#4-1-非静态、非虚成员函数指针" class="headerlink" title="4.1 非静态、非虚成员函数指针"></a>4.1 非静态、非虚成员函数指针</h3><ul>
<li>取<strong>非静态、非虚成员函数</strong>的地址，得到的是<strong>真正地址</strong>，但是调用的话需要绑定一个<strong>函数对象</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::M</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 声明如下</span></span><br><span class="line"><span class="keyword">double</span> (Point:: *ptr_f) ();</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">origin.*ptr_f(); -&gt; (ptr_f)(&amp;origin);</span><br><span class="line">ptr-&gt;*ptr_f(); -&gt; (ptr_f)(ptr);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-虚成员函数指针"><a href="#4-2-虚成员函数指针" class="headerlink" title="4.2 虚成员函数指针"></a>4.2 虚成员函数指针</h3><ul>
<li>取虚函数的地址，得到的是其在<strong>虚函数表中的下标</strong>。（<em>在vs2019上测试，结果并不是这样，得到的是一个内存地址</em>）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> (Point:: *ptr_f) ();</span><br><span class="line">Point *ptr = <span class="keyword">new</span> Point3d;</span><br><span class="line"></span><br><span class="line">(ptr-&gt;*ptr_f)(); -&gt; *(ptr-&gt;vptr[(<span class="keyword">int</span>)ptr_f])(ptr);</span><br></pre></td></tr></table></figure>

<p>为了区分函数指针指向的是非虚函数还是虚函数，编译器必须使<code>ptr_f</code>能够持有<strong>两种值</strong>，且<strong>可以被区分是内存地址还是虚函数表的下标</strong></p>
<p>在cfron中，如此判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((<span class="keyword">int</span>) ptr_f) &amp; ~<span class="number">127</span>) ? (*ptr_f)(ptr) : *(ptr-&gt;vptr[(<span class="keyword">int</span>)ptr_f])(ptr);</span><br></pre></td></tr></table></figure>

<p>这样只能限制最多只有128个虚函数。</p>
<h3 id="4-3-多重继承下，成员函数指针"><a href="#4-3-多重继承下，成员函数指针" class="headerlink" title="4.3 多重继承下，成员函数指针"></a>4.3 多重继承下，成员函数指针</h3><p>为了使成员函数指针支持多重继承和虚拟继承，有以下结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">mptr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> delta;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ptrtofunc faddr;</span><br><span class="line">        <span class="keyword">int</span> v_offset;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>delta</strong>指this指针的offset，<strong>index</strong>指虚函数表的下标，<strong>faddr</strong>指非虚成员函数地址（当index不指向虚函数表时，设为-1），<strong>v_offset</strong>指虚基类或多重继承的第二父类的vptr位置。</p>
<p>但是这样每次通过成员函数指针调用都会判断一次。被人诟病。</p>
<p><strong>Microsoft</strong>引入<strong>vcall thunk</strong>，因此，<strong>faddr</strong>要么指向函数地址、要么指向<strong>vcall thunk</strong>地址，<strong>vcall thunk</strong>会自动选定虚函数表中的下标，调用。</p>
<p>该结构体的一个副作用是，当传递一个固定值给成员函数时，可能会产生临时对象。</p>
<h3 id="4-4-效率"><a href="#4-4-效率" class="headerlink" title="4.4 效率"></a>4.4 效率</h3><img src="/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%87%BD%E6%95%B0/image-20201117110854558.png" alt="image-20201117110854558" style="zoom:80%;">

<h2 id="5-内联函数-Inline-Function"><a href="#5-内联函数-Inline-Function" class="headerlink" title="5. 内联函数(Inline Function)"></a>5. 内联函数(Inline Function)</h2><p><strong>inline只是个请求</strong>，是否被接受，还得看编译器的是否认可inline的做法。</p>
<p>在<strong>cfront</strong>中，有一套测试法，两个阶段：</p>
<ul>
<li><p>分析函数定义，决定函数的**”intrinsic inline ability”**(编译器相关的inline能力)</p>
<p>如果函数因复杂度、建构等问题，不可成为inline，则会转化为static函数</p>
</li>
<li><p>真正的inline函数扩展操作，实在调用函数的那一点上。这会带来参数的求值以及临时对象。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_pt.x(lhs.x() + rhs.x()); -&gt; new_pt.x = lhs.x_ + x_5PointFV(&amp;rhs);</span><br></pre></td></tr></table></figure>

<p>这样扩张没有效率提升，所以不会被inline请求不会被处理。</p>
<h3 id="5-1-形式参数"><a href="#5-1-形式参数" class="headerlink" title="5.1 形式参数"></a>5.1 形式参数</h3><ul>
<li>inline函数的<strong>形式参数都会被实际参数取代</strong></li>
<li>如果实际参数会导致副作用，会引入<strong>临时对象</strong></li>
<li>如果实际参数是<strong>常量表达式</strong>，直接求值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    reutrn i &lt; j ? i : j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> bar &#123;</span><br><span class="line">	<span class="keyword">int</span> minval;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实参代替形参</span></span><br><span class="line">    minval = Min(val1, val2); -&gt; minval = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">    <span class="comment">// 常量表达式，计算结果作为返回值</span></span><br><span class="line">    minval = Min(<span class="number">1024</span>, <span class="number">2048</span>); -&gt; minval = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 副作用，引入临时对象</span></span><br><span class="line">    minval = Min(foo(), bar() + <span class="number">1</span>); </span><br><span class="line">    -&gt; <span class="keyword">int</span> t1, t2;</span><br><span class="line">    -&gt; minval = (t1 = foo()), (t2 = Bar() + <span class="number">1</span>), r1 &lt; t2? t1 : t2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-局部变量"><a href="#5-2-局部变量" class="headerlink" title="5.2 局部变量"></a>5.2 局部变量</h3><p>inline函数中的局部变量会在inline函数被调用时被维护。因为这一点，如果参数有副作用，<strong>可能会导致扩展码变大</strong>。</p>
<p>因此inline函数作为宏的安全处理，为此可能需要扩大扩展码，需要谨慎处理。</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/c/"># c++</a>
                    
                        <a href="/tags/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"># c++对象模型</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/11/17/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">创建型模式--单例模式</a>
            
            
            <a class="next" rel="next" href="/2020/11/17/cpp-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE/">对象模型-3.数据</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span></span>
    </div>
</footer>

    </div>
</body>
</html>
